; multitest.jal
;
; This file keeps the test cases related to the current developement 
; and at the bottom of this file, there is a todo-list.
; Once a part is finished, the code is put into a test-file in the 
; test directory, so they become part of the regression test set.
;
;

; current: single bitvars, which breaks down into:
; (- create a bitvar in global context)
; (- access it (read, write))         )
; (- pass it to procedures            )
; (  (by value)                       )
; (  (by ref => won't be supported!)  )
; (  (by code)                        )
; - 'at' mapping of the bitvar
; - pseudo vars to this bitvar
; - assignment at definition-time (global, local)


var byte alpha
var bit b0 at alpha:0 

b0 = 1
print_var(alpha)
b0 = 0
print_var(alpha)





;------------------------------------------------------------------------------
; TODO - Test                                                                
;                                                     
;  - test all relevant combinations of in/out with call by reference & code (not value)
;    with different parameter sizes. (see test_004 for supported combinations) 
;
;  - test proper casting on procedure parameters.
;
;  - test if all 'pragma' keywords (like data) are valid identifiers at any point.
;
;  - test of aliasses in various contexts  
;
;  - test of 'var prototypes' extern var
;    format: 'var byte foo is foo' defines foo to be a byte. 
;    Unlike 'var byte foo', the var is not added to the C output.
;    Maybe it is wise to put in a prototype 'extern uint8_t foo;', but that
;    will restrict the use for more complex types.
;    Anyway, this will become more relevant when typing by JAT (rather then 
;    the C-compiler) becomes stronger.
;
;------------------------------------------------------------------------------
; TODO - short term
; 
;  - support use of pseudo vars as parameters (value/reference/code)
;  (code vars is done)                                                      
;
;  - include files only once.
;
; - check for self-reference of pseudo-vars when generate code, so
;   this_function is not required.
;
;  - support bit variables, both single bit as multibit and at offset of a byte
;  (for now, I intend to limit to bits into one byte or maybe other vars)
;
;  - support of 'at', at least for bit variables.
;
;  - support of arrays (have not thought of this yet, passing of arrays may require quite a lot of rework)
;
;  - stronger enforcement of typing.
;    
;------------------------------------------------------------------------------
; TODO - intermediate term
;
;  - find a sollution for (expr == true)
;  C has no bit vars, so any value that is not false is considered true. Of course we 
;  could just replace this particular compare, but that would not catch similar statements
;  like (true == expr),( expr == on) where on equals to true etc. It would be nice if
;  there was a sollution without replacing all expression evaluation of C,
;  
;  - better parser error support - try leaving out 'is' from a valid procedure definition and you know
;  what I mean.  
;
;  - extend var prototypes to support pointers to vars.
;    (but how can we do this without breaking the jal grammar?)
;
;  - rework parsing so procedure defs are always encountered in pass one.
;  currently, a procedure def within if, loop etc is not recoginised.
;  (guess more rework is required to support conditional compile...)  
;
;  - use C 'volatile' keyword when relevant.
;
;------------------------------------------------------------------------------
;  TODO - Later, maybe never
;
;  - support of odd-sized vars, like byte*3 (below 32 bits)
;  
;  - support of long vars, like byte*8 (beyond 32 bits).
;  
;  - conditional compile (if an expression of an if-statement contains constants only, irrelevant code is
;     not compiled. Code does not need to be valid (e.g. can contain vars that does not exist), but when
;     we leave it out of C, we get the same effect.
;   
;  - support reference-parameter as input for call-by-code
;  Probably requires analysis of procedure call and write wrapping-code before 
;  actuall printing code as the program does now.         
;  => such a scan is pretty complex, since it has to determine where it can safely put
;  the code. A procedure/ function call can be part of an if-statment, an assign,
;  within loop etc. 
;  (It is tempting to place the wrapper immediately after the var is defined, but that
;  kills the requisted volatile behaviour - it should be as close before and after
;  the actual use)
; (It seems that JAL does not support this either, but there may be also a bug involved.)


