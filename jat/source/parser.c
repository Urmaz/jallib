// parser - parse source.  
//
// Adapted-by: Joep Suijs
// Compiler: >=2.4m
//
// This file is part of jallib (http://jallib.googlecode.com)
// Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
//
// Description: 
//
//
// based on:
// Example of a grammar for parsing C sources,
// Adapted from Java equivalent example, by Terence Parr
// Author: Jim Idle - April 2007
// Permission is granted to use this example code in any way you want, so long as
// all the original authors are cited.
//

#include "jat.h"


pjalLexer		    lxr;
pjalParser				psr;


jalParser_program_return ParseSource(pANTLR3_UINT8 fName)
{
    // The ANTLR3 character input stream, which abstracts the input source such that
    // it is easy to provide input from different sources such as files, or 
    // memory strings.
    pANTLR3_INPUT_STREAM    input;

   // The lexer (ANTLR generated) is supplied with a pANTLR3_INPUT_STREAM from whence it consumes its
   // input and generates a token stream as output.
   // (moved to global)   pjalLexer		    lxr;

   // The token stream (ANTLR generated)
   pANTLR3_COMMON_TOKEN_STREAM	    tstream;

   // The C parser (ANTLR generated)
   // (moved to global)  pjalParser				psr;
   
   // Create the input stream using the supplied file name
   input	= antlr3AsciiFileStreamNew(fName);
   if ( input == NULL) {
      CodeOutput(VERBOSE_M, "Failed to open file %s\n", (char *)fName);
      fprintf(stderr, "Failed to open file %s\n", (char *)fName);
      exit(1);
   }
   
   // Our input stream is now open and all set to go, so we can create a new instance of our
   // lexer and set the lexer input to our input stream:
   //  (file | memory | ?) --> inputstream -> lexer --> tokenstream --> parser ( --> treeparser )?
   //
   lxr	    = jalLexerNew(input);	    // CLexerNew is generated by ANTLR
   
   assert(lxr != NULL) ; // Unable to create the lexer due to malloc() failure1
   
   // Our lexer is in place, so we can create the token stream from it
   // NB: Nothing happens yet other than the file has been read. We are just 
   // connecting all these things together and they will be invoked when we
   // call the parser rule. ANTLR3_SIZE_HINT can be left at the default usually
   // unless you have a very large token stream/input. Each generated lexer
   // provides a token source interface, which is the second argument to the
   // token stream creator.
   // Note that even if you implement your own token structure, it will always
   // contain a standard common token within it and this is the pointer that
   // you pass around to everything else. A common token as a pointer within
   // it that should point to your own outer token structure.
   //
   tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
   
   assert (tstream != NULL); // Out of memory trying to allocate token stream

    // Finally, now that we have our lexer constructed, we can create the parser
    //
    psr	    = jalParserNew(tstream);  // CParserNew is generated by ANTLR3

    assert (psr != NULL); // Out of memory trying to allocate parser
   
   // We are all ready to go. Though that looked complicated at first glance,
   // I am sure, you will see that in fact most of the code above is dealing
   // with errors and there isn't really that much to do (isn't this always the
   // case in C? ;-).
   //
   // So, we now invoke the parser. All elements of ANTLR3 generated C components
   // as well as the ANTLR C runtime library itself are pseudo objects. This means
   // that they are represented as pointers to structures, which contain any
   // instance data they need, and a set of pointers to other interfaces or
   // 'methods'. Note that in general, these few pointers we have created here are
   // the only things you will ever explicitly free() as everything else is created
   // via factories, that allocated memory efficiently and free() everything they use
   // automatically when you close the parser/lexer/etc.
   //
   // Note that this means only that the methods are always called via the object
   // pointer and the first argument to any method, is a pointer to the structure itself.
   // It also has the side advantage, if you are using an IDE such as VS2005 that can do it
   // that when you type ->, you will see a list of tall the methods the object supports.
   //
   jalParser_program_return r = psr->program(psr);       // js 'program' is the root element of our language grammar


   // If the parser ran correctly, we will have a tree to parse. In general I recommend 
   // keeping your own flags as part of the error trapping, but here is how you can 
   // work out if there were errors if you are using the generic error messages 
   // 
   if (psr->pParser->rec->state->errorCount > 0) { 
      fprintf(stderr, "The parser returned %d errors, tree walking aborted.\n", psr->pParser->rec->state->errorCount); 
      exit(1);
   }       
   
   return r;
}


typedef struct IncludeNameList_struct {
   char *FileName;
   struct IncludeNameList_struct *Next;   
} IncludeNameList;

IncludeNameList *InlRoot = NULL;
            
static int GetIncludePath(char *String, int Reset);

            
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
pANTLR3_INPUT_STREAM JalOpenInclude(char *Line) 
{  int State, i;
   char *BaseName;                       
   char FileName[MAX_FILENAME_SIZE];  
   char FilePath[MAX_FILENAME_SIZE];
   IncludeNameList *Inl;
   
   pANTLR3_INPUT_STREAM    in;

   if (NoInclude) {
      CodeOutput(VERBOSE_M, "// Ignore include line %s\n", Line);
      return NULL;
   }
   
//   printf("// JalInclude line: %s\n", Line);

   //---------------------------------------------
   // extract filename from include statement line
   //---------------------------------------------
   State = 0;
   for (i=0; ((Line[i] != 0)&(State != 3)); i++) {
      switch(State) {
         case 0 : { // search for first whitespace
            if ((Line[i] == ' ') | (Line[i] == '\t')) {
               State = 1;
            }
            break;  
         }          
         case 1 : { // search for non-whitespace, which is start of filename/path
            if ((Line[i] != ' ') & (Line[i] != '\t')) {
               BaseName = &Line[i];
               State = 2;
            }
            break;  
         }          
         case 2 : { // search for first whitespace, which is end of filename/path
            if ((Line[i] == ' ') | (Line[i] == '\t') | (Line[i] == '\r') | (Line[i] == '\n')) {
               Line[i] = 0; // terminate string
               State = 3;
            }
            break;  
         }               
         default : {
            CodeOutput(VERBOSE_ALL, "Error state: %d, i: %d\n", State, i);     
            break;
         }
      }
   }
   CodeOutput(VERBOSE_M, "// include BaseName: _%s_\n", BaseName);   

   // base filename retrieved.
   sprintf(FileName, "%s.jal", BaseName);

   //------------------------------------------
   // check if file is already included
   //------------------------------------------
   Inl = InlRoot;
   while (Inl) {
      if (strcmp(BaseName, Inl->FileName) == 0) {
         // file found
         CodeOutput(VERBOSE_M, "// File '%s' already included, so ignore now\n", BaseName);
         return NULL;
      }              
      Inl = Inl->Next;
   }
   // not found, so add
   Inl = malloc(sizeof(IncludeNameList));
   Inl->Next = InlRoot;
   Inl->FileName = CreateName(BaseName);
   InlRoot = Inl;
   

   //------------------------------------------
   // try to open filename at current location.
   //------------------------------------------
   strcpy(FilePath, FileName);
   CodeOutput(VERBOSE_L, "// Try first %s \n", FilePath); 
   in = antlr3AsciiFileStreamNew(FilePath);

   if (in == NULL) {
      //------------------------------------------
      // file not at current location, so
      // walk include path to find file.                                  
      //------------------------------------------
   GetIncludePath(NULL, 1); // reset include path   
      for (;;) {
         if (GetIncludePath(FilePath, 0)) {
            // got a path.
            strcat(FilePath, FileName);
            CodeOutput(VERBOSE_L, "// Try path %s \n", FilePath); 
            in = antlr3AsciiFileStreamNew(FilePath);
            if (in != NULL) break;  // found the file!

            // else next file
            continue;
         }
         CodeOutput(VERBOSE_L, "// Path done without succes...\n"); 
         break;      
      }
   }

   if (in == NULL) {
      CodeOutput(VERBOSE_ERROR, "Error opening include file %s\n", FileName);
      exit(1);
   }

   // note: PUSHSTREAM macro only works in LEX context (not in this code, nor PARSER context).
   // So leave PUSHSTREAM in the gramar-file.
   return in;
}


// return 1 if path, 0 if none.
static int GetIncludePath(char *String, int Reset)
{  static int Index;
   int i;
      
   if (Reset) {
      Index = 0;
      return 0;
   }                      
   
   // no include path
   if (IncludePath == NULL) return 0;
      
   // string already handled      
   if (IncludePath[Index] == 0) return 0;
      
   for (i=0;; i++) {   
      String[i] = IncludePath[i+Index];
      if (String[i] == 0) {
        // end of string
        Index += i;
        break;
      }
      if (String[i] == ';') {
         // end of single path
         String[i] = 0;
         Index += (i+1);
         break;
      }
   }     
   strcat(String, "/");
   return 1;
   
}
