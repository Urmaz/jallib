include 16f886
enable_digital_io() 

pragma target clock 20_000_000 -- Osc
pragma target OSC	hs
pragma target WDT	disabled
pragma target LVP	disabled
pragma target MCLR	external

const byte hewo[] = "Hello World!\n"
const byte version[] = "V0.0.6\n"
const byte done[] = "Done!\n"
const byte test1[] = "ABCDEFGHIJKLMNOPQRST"
const byte test2[] = "UVWXYZabcdefghijklmn"
const byte test3[] = "opqrstuvwxyz01234567"
const byte test4[] = "89!@#$%^&*()€~<>/"
const byte test5[] = "\|[]{}*-+,.:;?"
const byte adcte[] = "Lichtsensor:"
--const byte cr[] = "c K-4U.nl 2005-2010"

-- -------- ADC setup -----------
const ADC_CHANNEL_A             = 0            -- AN11 (pin_B4)
const byte ADC_NVREF            = 0             -- no external Vref
const word ADC_RSOURCE          = 5_000         -- 5K potmeter
const bit ADC_HIGH_RESOLUTION   = TRUE          -- high resolution
include adc/adc                                     -- include ADC library
adc_init()                                      -- init library
set_analog_pin(ADC_CHANNEL_A)                   -- init used ADC channel
var word measure_a                              -- ADC channel A

-- -------- PWM setup -----------
pin_CCP1_direction = output
include pwm/pwm_hardware
pwm_max_resolution(1)
pwm1_on()

-------- UART setup -----------
include delay
const USART_HW_Serial     = true     --true = RS232, false = SPI
const Serial_HW_Baudrate  = 19_200   --1_250_000 ;115_200
include serial_hardware
Serial_HW_init

serial_hw_printf(hewo)
serial_hw_printf(version)

var byte x			=	0
var byte pwmValue	=	0
while pwmValue != 255 loop
	pwm1_set_dutycycle(pwmValue)
	pwmValue = pwmValue + 1
	delay_1ms(10)
end loop

-------- GLCD setup -----------
include glcd
lcd_init()
--Just print some nonsense to the screen.. like.. "Hello World!"

lcd_print(0, 0, hewo)
lcd_print(0, 8, test1)
lcd_print(0, 16, test2)
lcd_print(0, 24, test3)
lcd_print(0, 32, test4)
lcd_print(0, 40, test5)

var byte timer
for 150 using timer loop
	--Draw a box! :D
	lcd_prg_hor(0, 49, 54, 150-timer, 150, 1)
	delay_1ms(10)
end loop

lcd_clearscreen()
--lcd_write_pixel(64,32,1)
--lcd_circle(64,32, 10)
lcd_print(0, 0, adcte)

var word oldADC
var byte ADCLowRes
var bit e1, e2
serial_hw_printf(done)

var byte graphLeft 		= 8		-- X
var byte graphRight		= 126	-- X
var byte graphTop		= 18	-- Y
var byte graphBottom	= 63	-- Y
var byte graphHeight	= graphBottom - graphTop

var byte graphX = graphLeft
var dword graphY = 0
--lcd_filled_rect(8, 18, 126, 63, 0)
--Draw the graph:
lcd_line(graphLeft, graphBottom, graphRight, graphBottom, 1)
lcd_line(graphLeft, graphTop, graphLeft, graphBottom, 1)
forever loop
--	graphX = graphX + 1
	measure_a = adc_read(ADC_CHANNEL_A)
	e1 = (measure_a < (oldADC - 3))
	e2 = (measure_a > (oldADC + 3))
	if e1 | e2 then
		lcd_num(0, 8, measure_a)
		oldADC = measure_a
		--serial_hw_word(measure_a)
		--serial_hw_write(0x0A)
		ADCLowRes = adc_read_low_res(ADC_CHANNEL_A)
		graphY = ADCLowRes * 100
		graphY = graphY / 255
--		graphY = graphY * 45
--		graphY = graphY / 100
--		graphY = graphY + 18
	end if
--	-- Set a dot!
--	lcd_write_pixel(graphX, graphY, 1)
--	lcd_line_invert(graphX + 2, 18, graphX + 2, 63 - 1)
--	delay_1ms(50)
--	if graphX == 126 then
--		--Draw the graph:
--		graphX = 8
--		lcd_line_invert(graphX + 1, 18, graphX + 1, 63 - 1)
--		lcd_line_invert(graphX + 2, 18, graphX + 2, 63 - 1)
--		lcd_line(8, 63, 126, 63)
--		lcd_line(8, 18, 8, 63)
--	end if
end loop
