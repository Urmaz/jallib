-- ------------------------------------------------------
-- Title: vcxo.jal - 
--
-- Author: Joep Suijs, Copyright (c) 2008..2010, all rights reserved.
--
-- Adapted-by:
--
-- Compiler: 2.4l
--
-- This file is part of jallib  (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description:                   
--
-- Sources:
--
-- Notes:
--
-- ------------------------------------------------------

include 16f690
pragma target clock 10_000_000      -- oscillator frequency
pragma target OSC  RC_NOCLKOUT      -- external osc
pragma target WDT  disabled         -- no watchdog (tenminste, niet door fuses geforceerd)
pragma target MCLR external         -- reset externally


alias   led1      is pin_a2
pin_a2_direction =  output

enable_digital_io()

OPTION_REG_NRAPU = false -- enable pull-up on port A
WPUA = 0b0000_0100          -- pull-up off voor alle pins behalve A2.
                        
;WDTCON_SWDTEN = true    -- enable watchdog
;OPTION_REG_PSA = false  -- no prescaler
;WDTCON_WDTPS = 11       -- divide 31kHz by 64k => 2 secs timeout
;asm clrwdt              -- clear timeout

-- serial poort (voor debug)
var bit dummy
alias serial_ctsinv  is  dummy               -- incoming data flow control
const  bit serial_overflow_discard = false   -- With transmit buffer overflow:
                                             --   TRUE: discard data (non-blocking)
                                             --   FALSE: wait for free space (blocking)

const   SERIAL_XMTBUFSIZE  = 80      -- size of transmit buffer
const   SERIAL_RCVBUFSIZE  = 12      -- size of receive buffer

const serial_hw_baudrate = 4800
include serial_hw_int_cts
serial_hw_init()               

include print
include delay


include gps_converter

-- ----------------------------------------------------------------------------
-- setup 10 kHz isr & pwm 
-- ----------------------------------------------------------------------------
-- 10 kHz ISR - which is based on the VCXO clock - increments a counter to 
-- provide an internal time base to lock at the GPS time. 
--
-- 10 Khz @ 10 MHz clock = prescaler 1, count to 250 (*4)
-- ----------------------------------------------------------------------------
T2CON_TOUTPS = 0b00                       -- postscaler 1:1
T2CON_T2CKPS = 0b00                       -- prescaler 1:1
T2CON_TMR2ON = TRUE
PR2 = 249   -- count from 0 to 249 and skip back to 0 = 250 steps

ccp1con_p1m = 0  -- alleen output op pin P1A
ccp1con_ccp1m = 0b1100  -- pwm mode
pin_c5_direction = output

PIE1_TMR2IE = true
INTCON_GIE = true
INTCON_PEIE = true

var volatile word Ticks = 0   
var byte TicksLowByte at Ticks

const byte str1[] = "Vcxo V0.1\n"  
print_string(serial_hw_data, str1)      

procedure SetDutyCycle (word in duty) is
   
   if (duty > 999) then 
      duty = 999
      serial_hw_data = "E"
   end if                
   
   ccpr1l = byte(duty >> 2)
   ccp1con_dc1b = byte(duty) & 0b11
   
end procedure



; 10 kHz ISR
procedure isr is
   pragma interrupt

   if (PIR1_TMR2IF) then
      PIR1_TMR2IF = false
      Ticks = Ticks + 1
      if (Ticks > 9999) then
         Ticks = 0
      end if
   end if   
   
end procedure

; laat reset zien door korte flitsen
for 8 loop
;forever loop
   led1 = ! led1 
   delay_1ms(50)
end loop

SetDutyCycle(500)


var byte ch

forever loop    
;   delay_100ms(1)


;   ch = serial_hw_data
;   
;   if (ch > 0) then
;      serial_hw_data = ch
;   end if   
 
 gpstakt()
;   print_word_dec(serial_hw_data, Ticks) 
;   serial_hw_data = " "
;   print_word_dec(serial_hw_data, NextBitTimeHires) 
;   serial_hw_data = " "
;   print_byte_dec(serial_hw_data, TicksLowByte) 
;   serial_hw_data = " "
;   print_byte_dec(serial_hw_data, NextBitTime[1]) 
;  serial_hw_data = " "
;   print_byte_hex(serial_hw_data, RxShift)
;   print_crlf(serial_hw_data)

;   print_byte_hex(serial_hw_data, OPTION_REG)
;   serial_hw_data = " "
;   print_byte_hex(serial_hw_data, TMR0)
;   print_crlf(serial_hw_data)


;   print_byte_hex(serial_hw_data, RxDone)
;   print_crlf(serial_hw_data)

   
end loop
--
