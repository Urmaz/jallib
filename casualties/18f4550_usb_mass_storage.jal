-- -----------------------------------------------------------------------------
-- Title: demo of usb_serial library
-- Author: Albert Faber, Copyright (c) 2009, all rights reserved.
-- Adapted-by: -
-- Compiler: >=2.4j
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: This application demonstratesest USB Serial library, this application
-- will emulate a RS-232 terminal device. Once the USB device has been detected by the
-- host operating system, it will create a virtual COM port. When opening this COM
-- on the host computer, using a standard terminal application, it should show a
-- welcome message, after the welcome message all input characters are echoed back
-- to the terminal application
-- --
--
-- Sources: http://www.usb.org for USB specifications
--
-- Notes: compiled with following flags
-- -loader18 -no-fuse  ; when the microchip 18f bootloader is present
-- add -no-variable-reuse when debugging flags are set due to a compiler issue
-- -
-- Some instructions for use:
-- -
-- 1. Make sure you logon as administrator, or with administrator privileges,
--    on Windows XP.
-- 2. If needed convert to the correct PIC device (change include file),
--    adapt fuses fuses and speed
-- 3. Create a basic board with USB PIC device
-- 4. Compile the this file and program the hex file into the PIC.
-- 5. After a (short) while you'll get the "new hardware found" message for
--    "JALLIB Serial". Point Windows manually to the driver in the
--    driver directory xp_drivers The drivers can be found at:
--    http://groups.google.com/group/jallib/ (usb_cdc_drivers_winxp32.zip)
--    Ignore the warning that this driver doesn't have a certificate.
--    Wait for the installation to complete.
-- 6. Open the Windows Device Manager and check out the "ports" section. A new
--    communications port will be there, with a COM number.
-- 7. Open a terminal program (for example HyperTerminal) and select the COM
--    port you found in the previous step. Pick any baudrate, Windows will
--    accommodate automatically, and use 8-N-1-no for the other settings.
-- 8. Press enter and read the message. Now everything you type will be echoed
--    back.
-- 9. Have fun, adapt to your needs
--
-- ------------------------------------------------------
--
--
-- This file has been generated from:
--    * board: board_18f4550_af.jal
--    * test : test_usb_serial.jal
--

;@jallib section chipdef
-- chip setup
include 18f4550

;@jallib section chipdef
-- chip setup
include 18f4550

-- even though the external crystal is 20 MHz, the configuration is such that
-- the CPU clock is derived from the 96 Mhz PLL clock (div2), therefore set
-- target frequency to 48 MHz
pragma target clock       48_000_000


-- fuses
pragma target PLLDIV        P5          -- divide by 5 - 20MHZ_INPUT
pragma target CPUDIV        P2          -- OSC1_OSC2_SRC_1_96MHZ_PLL_SRC_2
pragma target USBPLL        F48MHZ      -- CLOCK_SRC_FROM_96MHZ_PLL_2
pragma target OSC           HS_PLL
pragma target FCMEN         DISABLED
pragma target IESO          DISABLED
pragma target PWRTE         DISABLED    -- power up timer
pragma target VREGEN        ENABLED     -- USB voltage regulator
pragma target VOLTAGE       MINIMUM     -- brown out voltage
pragma target BROWNOUT      DISABLED    -- no brownout detection
pragma target WDTPS         P32K        -- watch dog saler setting
pragma target WDT           DISABLED    -- no watchdog
pragma target CCP2MUX       ENABLED     -- CCP2 pin C1
pragma target PBADEN        DIGITAL     -- digital input port<0..4>
pragma target LPT1OSC       LOW_POWER   -- low power timer 1
pragma target MCLR          EXTERNAL    -- master reset on RE3
pragma target STVR          DISABLED    -- reset on stack over/under flow
pragma target LVP           DISABLED    -- no low-voltage programming
pragma target XINST         ENABLED     -- extended instruction set
pragma target DEBUG         DISABLED    -- background debugging
pragma target CP0           DISABLED    -- code block 0 not protected
pragma target CP1           DISABLED    -- code block 1 not protected
pragma target CP2           DISABLED    -- code block 2 not protected
pragma target CP3           DISABLED    -- code block 3 not protected
pragma target CPB           DISABLED    -- bootblock code not write protected
pragma target CPD           DISABLED    -- eeprom code not write protected
pragma target WRT0          DISABLED    -- table writeblock 0 not protected
pragma target WRT1          DISABLED    -- table write block 1 not protected
pragma target WRT2          DISABLED    -- table write block 2 not protected
pragma target WRT3          DISABLED    -- table write block 3 not protected
pragma target WRTB          DISABLED    -- bootblock not write protected
pragma target WRTD          DISABLED    -- eeprom not write protected
pragma target WRTC          DISABLED    -- config not write protected
pragma target EBTR0         DISABLED    -- table read block 0 not protected
pragma target EBTR1         DISABLED    -- table read block 1 not protected
pragma target EBTR2         DISABLED    -- table read block 2 not protected
pragma target EBTR3         DISABLED    -- table read block 3 not protected
pragma target EBTRB         DISABLED    -- boot block not protected

enable_digital_io()                -- make all pins digital I/O

-- led def
alias   led      is pin_A0
pin_A0_direction =  output

include delay
include print

-- setup uart for communication
const serial_hw_baudrate  = 115200    -- set the baud rate
include serial_hardware
serial_hw_init()

-- consts to enable debugging
const USB_DEBUG = 0
const USB_DEBUG_HIGH = 0
const USB_MSD_DEBUG = 1
const USB_MSD_DEBUG_HIGH = 1

-- usb definitions
include usb_defs


-- my defs
var byte msd_ready_to_reply = false

-- MSD Constants
const byte USB_MSD_DATA_ENDPOINT = 1

-- defs
alias msd_out_stat is usb_bd1out_stat
alias msd_out_cnt is usb_bd1out_cnt
alias msd_out_addr is usb_bd1out_addr
alias msd_out_addrl is usb_bd1out_addrl
alias msd_out_addrh is usb_bd1out_addrh

alias msd_in_stat is usb_bd1in_stat
alias msd_in_cnt is usb_bd1in_cnt
alias msd_in_addr is usb_bd1in_addr
alias msd_in_addrl is usb_bd1in_addrl
alias msd_in_addrh is usb_bd1in_addrh

-- --------------------------------------------------------------------------------------
-- This function returns the status of the SIE tx buffer. Either the SIE can own the
-- transmit buffer (tranmit is pending) or it can be owned by the CPU. This function
-- return true if the SIE owns the buffer, otherwise false is returned
-- --------------------------------------------------------------------------------------
function does_sie_owns_tx_buffer() return bit is
   pragma inline
   var bit uown_bit shared at msd_in_stat:USB_BDSTATUS_UOWN
   return uown_bit
end function

-------------------------------------------------------------------------
-- Setup USB endpoints, 1 enpoint is required for a MSD class
-------------------------------------------------------------------------
const bit USB_EP0 = 1

const byte USB_EP0_OUT_SIZE = 64
const word USB_EP0_OUT_ADDR = (USB_BASE_ADDRESS + 0x0010 )
const byte USB_EP0_IN_SIZE  = 64
const word USB_EP0_IN_ADDR  = (USB_EP0_OUT_ADDR + USB_EP0_OUT_SIZE )

var volatile byte usb_ep0out_buf[ USB_EP0_OUT_SIZE ] at USB_EP0_OUT_ADDR
var volatile byte usb_ep0in_buf[ USB_EP0_IN_SIZE ] at USB_EP0_IN_ADDR

const bit USB_EP1 = 1
const byte USB_EP1_OUT_SIZE = 64
const word USB_EP1_OUT_ADDR = (USB_BASE_ADDRESS + 64)
const byte USB_EP1_IN_SIZE  = 64
const word USB_EP1_IN_ADDR  = (USB_EP1_OUT_ADDR + USB_EP1_OUT_SIZE )

var volatile byte usb_ep1out_buf[ USB_EP1_OUT_SIZE ] at USB_EP1_OUT_ADDR
var volatile byte usb_ep1in_buf[ USB_EP1_IN_SIZE ] at USB_EP1_IN_ADDR

const bit USB_EP2 = 0
const bit USB_EP3 = 0

-- -----------------------------------------------------------------------
-- USB_MSD_TX_BUFFER_SIZE contains the size of the transmit FIFO buffer
-- -----------------------------------------------------------------------
const byte USB_MSD_TRANSMIT_BUFFER_SIZE = 128
var byte msd_transmit_buffer[USB_MSD_TRANSMIT_BUFFER_SIZE]
-- -----------------------------------------------------------------------
-- USB_MSD_RX_BUFFER_SIZE contains the size of the receive FIFO buffer
-- -----------------------------------------------------------------------
const byte USB_MSD_RECEIVE_BUFFER_SIZE = 128
var byte msd_receive_buffer[USB_MSD_RECEIVE_BUFFER_SIZE]

-------------------------------------------------------------------------
-- define the buffer in dual port of the USB SIE, so data is
-- accessible from the JAL code
-------------------------------------------------------------------------
var volatile byte usb_msd_buffer_in[USB_EP1_IN_SIZE] at USB_EP1_IN_ADDR
var volatile byte usb_msd_buffer_out[USB_EP1_OUT_SIZE] at USB_EP1_OUT_ADDR

-- other constants & vars
const byte USB_MSD_BULK_OUT_EP_SIZE = USB_EP1_OUT_SIZE
const byte USB_MSD_BULK_IN_EP_SIZE  = USB_EP1_IN_SIZE

const word USB_MSD_BULK_OUT_EP_ADDR = USB_EP1_OUT_ADDR
const word USB_MSD_BULK_IN_EP_ADDR = USB_EP1_IN_ADDR

var volatile byte usb_msd_eptx_buffer[USB_EP1_IN_SIZE] at USB_EP1_IN_ADDR
var volatile byte usb_msd_eprx_buffer[USB_EP1_OUT_SIZE] at USB_EP1_OUT_ADDR

-- -----------------------------------------------------------------------
-- Sets the default USB_DEVICE_DESCRIPTOR record.
-- -----------------------------------------------------------------------
const byte USB_DEVICE_DESCRIPTOR[USB_DEVICE_DESCRIPTOR_SIZE] =
{
0x12, -- Descriptor size in bytes (18)
0x01, --Descriptor type (DEVICE)
0x00,
0x02, -- USB specification release (BCD) (2.00)
0x00, -- Class (specified at interface level)
0x00, -- Subclass (specified at interface level)
0x00, -- Protocol (specified at interface level)
0x40, -- Maximum packet size for endpoint zero (64)
0xD8,
0x04, -- Vendor ID (Microchip Technology; assigned by USB-IF)
0x09,
0x00, -- Product ID (assigned by vendor)
0x00,
0x01, -- Device release number (BCD, assigned by vendor) (1.00)
0x01, -- Manufacturer string index
0x02, -- Product string index
0x03, -- Serial number string index
0x01 -- Number of possible configurations
}


-- -----------------------------------------------------------------------
-- Sets the default USB_CONFIGURATION_DESCRIPTOR record.
-- -----------------------------------------------------------------------
const USB_CONFIGURATION_DESCRIPTOR_SIZE = 0x09 + 0x09 + 0x07 + 0x07
const byte USB_CONFIGURATION_DESCRIPTOR[ USB_CONFIGURATION_DESCRIPTOR_SIZE ]=
{
--Configuration Descriptor
0x09, -- Descriptor size in bytes (9)
0x02, -- Descriptor type (CONFIGURATION)
0x20,
0x00, -- Total length of this and subordinate descriptors
0x01, -- Number of interfaces in this configuration
0x01, -- Identifier for this configuration
0x00, -- Configuration string index (no string defined)
0xC0, -- Attributes: self powered, no remote wakeup
0x32, -- Maximum power consumption (100 mA)

--Interface Descriptor
0x09, -- Descriptor size in bytes (9)
0x04, -- Descriptor type (INTERFACE)
0x00, -- Interface Number
0x00, -- Alternate Setting Number
0x02, -- Number of endpoints in this interface
0x08, -- Class code (mass storage)
0x06, -- Subclass code (SCSI transparent command set)
0x50, -- Protocol code (bulk-only transport)
0x00, -- Interface string index (no string defined)

--Endpoint Descriptor
0x07, -- Descriptor size in bytes (7)
0x05, -- Descriptor type (ENDPOINT)
0x81, -- Endpoint number and direction (1 IN)
0x02, -- Transfer type (bulk)
0x40,
0x00, -- Maximum packet size (64)
0x00, -- Maximum latency (doesn't apply to full-speed bulk endpoints)

--Endpoint Descriptor
0x07, -- Descriptor size in bytes (7)
0x05, -- Descriptor type (ENDPOINT)
0x01, -- Endpoint number and direction (1 OUT)
0x02, -- Transfer type (bulk)
0x40,
0x00, -- Maximum packet size (64)
0x00 -- Maximum latency/high-speed OUT NAK rate (doesn't apply to full-speed bulk endpoints)
}

const byte USB_STRING0[] =
{
0x04,   -- bLength
USB_DT_STRING,   -- bDescriptorType
0x09,   -- wLANGID[0] (low byte)
0x04   -- wLANGID[0] (high byte)
}

const byte USB_STRING1[0x34] =
{
0x34,   -- bLength
USB_DT_STRING,   -- bDescriptorType
"M", 0x00,
"i", 0x00,
"c", 0x00,
"r", 0x00,
"o", 0x00,
"c", 0x00,
"h", 0x00,
"i", 0x00,
"p", 0x00,
" ", 0x00,
"T", 0x00,
"e", 0x00,
"c", 0x00,
"h", 0x00,
"n", 0x00,
"o", 0x00,
"l", 0x00,
"o", 0x00,
"g", 0x00,
"y", 0x00,
" ", 0x00,
"I", 0x00,
"n", 0x00,
"c", 0x00,
".", 0x00
}


const byte USB_STRING2[0x3A] =
{
0x3A,   -- bLength
USB_DT_STRING,   -- bDescriptorType
"M", 0x00,
"i", 0x00,
"c", 0x00,
"r", 0x00,
"o", 0x00,
"c", 0x00,
"h", 0x00,
"i", 0x00,
"p", 0x00,
" ", 0x00,
"M", 0x00,
"a", 0x00,
"s", 0x00,
"s", 0x00,
" ", 0x00,
"S", 0x00,
"t", 0x00,
"o", 0x00,
"r", 0x00,
"a", 0x00,
"g", 0x00,
"e", 0x00,
" ", 0x00,
"D", 0x00,
"r", 0x00,
"i", 0x00,
"v", 0x00,
"e", 0x00
}

const byte USB_STRING3[0x1A] =
{
0x1A,   -- bLength
USB_DT_STRING,   -- bDescriptorType
"1", 0x00,
"2", 0x00,
"3", 0x00,
"4", 0x00,
"5", 0x00,
"6", 0x00,
"7", 0x00,
"8", 0x00,
"9", 0x00,
"A", 0x00,
"B", 0x00,
"C", 0x00
}

-------------------------------------------------------------------------
-- procs
-------------------------------------------------------------------------

-- --------------------------------------------------------------------------------------
-- This procedure will handle the transmission of the (bulk) data. The procedure check
-- if there are pending characters in the tranmit FIFO. These character(s) are send in
-- chunk(s), the chunk size is dependent on the conifguration of the bulk interface
-- endpoint
-- --------------------------------------------------------------------------------------

var volatile byte cdc_tx_wr = 0
var volatile byte cdc_tx_rd = 0
var volatile byte cdc_tx_free = USB_MSD_TRANSMIT_BUFFER_SIZE
var bit last_packet_is_full = false
procedure usb_cdc_handle_tx() is

	var byte bytes_to_send

	-- var word cdc_tx_addr
	if ( does_sie_owns_tx_buffer() ) then
		-- if there's already something in play
		return
	end if
		
	-- anything in the fifo?
    if ( cdc_tx_wr == cdc_tx_rd ) then
		-- and we don't have to send an empty packet
		if ( !last_packet_is_full ) then
			-- nothing to do, so return
			return
		end if
		bytes_to_send = 0
	else	

		if ( cdc_tx_wr > cdc_tx_rd ) then
			bytes_to_send = cdc_tx_wr - cdc_tx_rd
		else
			-- to keep it simple, don't support splitted buffers
			-- so we don't have to copy the bytes into another array
			bytes_to_send = USB_MSD_TRANSMIT_BUFFER_SIZE - cdc_tx_rd
		end if

    end if

	-- clip to maximum EP transfer size
	if ( bytes_to_send  > USB_MSD_BULK_IN_EP_SIZE ) then
		bytes_to_send  = USB_MSD_BULK_IN_EP_SIZE
	end if


	if USB_MSD_DEBUG > 0  then
		const byte str[] = "send="
		serial_hw_write(">")
		print_string(serial_hw_data,str)
		print_byte_hex(serial_hw_data,bytes_to_send)
		serial_hw_write(" ")
		print_byte_hex(serial_hw_data,cdc_tx_rd)
		serial_hw_write(">")
		print_byte_hex(serial_hw_data,cdc_tx_wr)
		serial_hw_write("#")
	end if
	
	

		var byte idx	
	-- copy bytes
	for bytes_to_send using idx loop
		usb_msd_eptx_buffer[ idx ] = msd_transmit_buffer[ cdc_tx_rd + idx ]
	end loop
	
	
	
	msd_in_addr = USB_MSD_BULK_IN_EP_ADDR

	if USB_MSD_DEBUG > 0  then
		print_byte_hex(serial_hw_data, msd_in_addrh )
		print_byte_hex(serial_hw_data, msd_in_addrl )
		serial_hw_write("#")
		print_byte_hex(serial_hw_data, msd_in_stat )
		serial_hw_write("#")
	end if
	
	msd_in_cnt = bytes_to_send

	
	var volatile bit dts_bit at msd_in_stat : USB_BDSTATUS_DTS
	if ( dts_bit  ) then
		if USB_MSD_DEBUG > 0  then
			print_byte_hex(serial_hw_data, 0b_1000_1000 )
		end if	
		msd_in_stat = 0b_1000_1000
	else
		if USB_MSD_DEBUG > 0  then
			print_byte_hex(serial_hw_data, 0b_1100_1000 )
		end if	
		msd_in_stat = 0b_1100_1000
	end if

	-- advance read pointer
	var byte next_tx_rd = cdc_tx_rd + bytes_to_send

	if (next_tx_rd > ( USB_MSD_TRANSMIT_BUFFER_SIZE - 1 ))  then
		next_tx_rd = 0
 	end if
 	cdc_tx_rd = next_tx_rd

	-- Mark if we got a full packet (8 bytes),
	last_packet_is_full = ( bytes_to_send == 8 )
	
end procedure

procedure usb_ep_data_in_callback(byte in end_point, word in buffer_addr, byte in byte_count) is
    pragma inline
    if USB_MSD_DEBUG > 0  then
        const byte str[] = " EP data in: "
        const byte str1[] = " bytes "
        print_string(serial_hw_data,str)
        print_byte_hex(serial_hw_data,byte_count & 0xFF)
        print_string(serial_hw_data,str1)
    end if

    -- data has been sent, so do we need to send more?
    if (end_point == USB_MSD_DATA_ENDPOINT) then
        -- it's the data end point
        usb_cdc_handle_tx()
    end if
end procedure

procedure usb_cdc_putc(byte in c) is
    var byte cdc_tx_next

    cdc_tx_next = cdc_tx_wr + 1	-- get next buffer position

    if (cdc_tx_next == USB_MSD_TRANSMIT_BUFFER_SIZE) then
		-- if we're at the end
		cdc_tx_next = 0	-- wrap to the beginning
    end if

    -- put it in
	msd_transmit_buffer[cdc_tx_wr] = c
	
	-- move pointer along
   cdc_tx_wr = cdc_tx_next
end procedure


procedure msd_respond() is
      usb_cdc_putc(0x00)
      usb_cdc_putc(0x80)
      usb_cdc_putc(0x04)
      usb_cdc_putc(0x02)
      usb_cdc_putc(0x20)
      usb_cdc_putc(0x00)
      usb_cdc_putc(0x00)
      usb_cdc_putc(0x00)
      usb_cdc_putc("M")
      usb_cdc_putc("i")
      usb_cdc_putc("c")
      usb_cdc_putc("r")
      usb_cdc_putc("o")
      usb_cdc_putc("c")
      usb_cdc_putc("h")
      usb_cdc_putc("p")
      usb_cdc_putc("M")
      usb_cdc_putc("a")
      usb_cdc_putc("s")
      usb_cdc_putc("s")
      usb_cdc_putc(" ")
      usb_cdc_putc("s")
      usb_cdc_putc("t")
      usb_cdc_putc("o")
      usb_cdc_putc("r")
      usb_cdc_putc("a")
      usb_cdc_putc("g")
      usb_cdc_putc("e")
      usb_cdc_putc(" ")
      usb_cdc_putc(" ")
      usb_cdc_putc(" ")
      usb_cdc_putc(" ")
      usb_cdc_putc("0")
      usb_cdc_putc("0")
      usb_cdc_putc("0")
      usb_cdc_putc("1")
end procedure

--working data recieve to pic
var volatile byte cdc_rx_wr = 0
var volatile byte cdc_rx_rd = 0
var volatile byte cdc_rx_free = USB_MSD_RECEIVE_BUFFER_SIZE
procedure usb_ep_data_out_callback(byte in end_point, word in buffer_addr, byte in byte_count) is
   pragma inline
   var byte cdc_rx_next
   if USB_MSD_DEBUG > 0  then
      const byte str[] = " EP data out: "
      const byte str1[] = " bytes "
      print_string(serial_hw_data,str)
      print_byte_hex(serial_hw_data,byte_count)
      print_string(serial_hw_data,str1)
   end if
   
   -- We have some data!
   if (end_point == USB_MSD_DATA_ENDPOINT) then


      serial_hw_data = "-"
      print_byte_dec(serial_hw_data,does_sie_owns_tx_buffer())
      serial_hw_data = "-"
      
      -- it's the data end point
      var byte count
      
      var byte src_ptr[2] AT buffer_addr
      
      FSR1L = src_ptr[0]
      FSR1H = src_ptr[1]
      
      for byte_count using count loop
         
         cdc_rx_next = cdc_rx_wr + 1   -- get next buffer position
         
         if (cdc_rx_next == USB_MSD_RECEIVE_BUFFER_SIZE) then
            -- if we're at the end
            cdc_rx_next = 0   -- then wrap to the beginning
         end if
         
         if (cdc_rx_next != cdc_rx_rd) then
            -- if space in the fifo
            var byte ch = POSTINC1
            
            if USB_MSD_DEBUG > 0  then
               serial_hw_write("$")
               print_byte_hex(serial_hw_data,cdc_rx_wr)
               serial_hw_write("$")
               print_byte_hex(serial_hw_data,ch)
               serial_hw_data = 13
               serial_hw_data = 10
            end if
            msd_receive_buffer[cdc_rx_wr] = ch
            cdc_rx_wr = cdc_rx_next  -- and move pointer along
            cdc_rx_free = cdc_rx_free - 1
         else
            -- else... just ignore it, we've lost a byte, no room in the fifo
         end if
      end loop

   msd_ready_to_reply = true
      
   else
      if USB_MSD_DEBUG > 0 then
         const byte str[] = "data for ep "
         print_string(serial_hw_data,str)
         print_byte_hex(serial_hw_data,end_point)
      end if
   end if

end procedure

-------------------------------------------------------------------------
-- Include reset of USB driver libraries
-------------------------------------------------------------------------
include usb_drv_core
include usb_drv

procedure usb_msd_init() is
   -- setup the USB device
   usb_setup()
   usb_enable_module()
end procedure

procedure usb_msd_flush() is
   pragma inline
   usb_handle_isr()
end procedure

-- --------------------------------------------------------------------------------------
-- This function returns there has been a character received, function will return true
-- if there is at least one pending receive character, false otherwise
-- --------------------------------------------------------------------------------------
;function usb_msd_rx_avail() return bit is
;return cdc_rx_rd != cdc_rx_wr
;end function

-- --------------------------------------------------------------------------------------
-- This function returns the empty status of the transmit FIFO, it will return true if
-- transmit FIFO is empty, false otherwise
-- --------------------------------------------------------------------------------------
;function usb_msd_tx_empty() return byte is
;return cdc_tx_rd == cdc_tx_wr
;end function

usb_msd_init()

const  byte str_welcome[] = "JALLIB Mass Storage Device Demo app\n"
var bit has_shown_welcome_msg = true

-- main loop
forever loop
   -- poll the usb ISR function on a regular base, in order to
   -- serve the USB requests
   usb_msd_flush()
   
   -- check if USB device has been configured by the HOST
   if usb_is_configured()  then
      if !has_shown_welcome_msg then
         has_shown_welcome_msg = true
         print_string( serial_hw_data, str_welcome )
      end if
   else
      has_shown_welcome_msg = false
   end if
   
   if msd_ready_to_reply == true then
      ;msd_respond()
      ;usb_send_data_chunk()
      ;msd_ready_to_reply = false
      var byte test[36]

      test[0] = (0x00)
      test[1] = (0x80)
      test[2] = (0x04)
      test[3] = (0x02)
      test[4] = (0x20)
      test[5] = (0x00)
      test[6] = (0x00)
      test[7] = (0x00)
      test[8] = ("M")
      test[9] = ("i")
      test[10] = ("c")
      test[11] = ("r")
      test[12] = ("o")
      test[13] = ("c")
      test[14] = ("h")
      test[15] = ("p")
      test[16] = ("M")
      test[17] = ("a")
      test[18] = ("s")
      test[19] = ("s")
      test[20] = (" ")
      test[21] = ("s")
      test[22] = ("t")
      test[23] = ("o")
      test[24] = ("r")
      test[25] = ("a")
      test[26] = ("g")
      test[27] = ("e")
      test[28] = (" ")
      test[29] = (" ")
      test[30] = (" ")
      test[31] = (" ")
      test[32] = ("0")
      test[33] = ("0")
      test[34] = ("0")
      test[35] = ("1")

      usb_send_data (USB_MSD_DATA_ENDPOINT, test, 36, low)
      usb_send_data_chunk()
   end if
   
   
end loop
