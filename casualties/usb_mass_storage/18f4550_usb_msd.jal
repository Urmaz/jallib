-- Title: USB Mass Storage Sample
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4o
--
-- This file is part of jallib  (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: Test program for mass storage with SD Card.
--

-- chip setup
include 18f4550

-- even though the external crystal is 20 MHz, the configuration is such that
-- the CPU clock is derived from the 96 Mhz PLL clock (div2), therefore set
-- target frequency to 48 MHz
pragma target clock       48_000_000


-- fuses
pragma target PLLDIV        P5          -- divide by 5 - 20MHZ_INPUT
pragma target CPUDIV        P2          -- OSC1_OSC2_SRC_1_96MHZ_PLL_SRC_2
pragma target USBPLL        F48MHZ      -- CLOCK_SRC_FROM_96MHZ_PLL_2
pragma target OSC           HS_PLL
pragma target FCMEN         DISABLED
pragma target IESO          DISABLED
pragma target PWRTE         DISABLED    -- power up timer
pragma target VREGEN        ENABLED     -- USB voltage regulator
pragma target VOLTAGE       MINIMUM     -- brown out voltage
pragma target BROWNOUT      DISABLED    -- no brownout detection
pragma target WDTPS         P32K        -- watch dog saler setting
pragma target WDT           DISABLED    -- no watchdog
pragma target CCP2MUX       ENABLED     -- CCP2 pin C1
pragma target PBADEN        DIGITAL     -- digital input port<0..4>
pragma target LPT1OSC       LOW_POWER   -- low power timer 1
pragma target MCLR          EXTERNAL    -- master reset on RE3
pragma target STVR          DISABLED    -- reset on stack over/under flow
pragma target LVP           DISABLED    -- no low-voltage programming
pragma target XINST         ENABLED     -- extended instruction set
pragma target DEBUG         DISABLED    -- background debugging
pragma target CP0           DISABLED    -- code block 0 not protected
pragma target CP1           DISABLED    -- code block 1 not protected
pragma target CP2           DISABLED    -- code block 2 not protected
pragma target CP3           DISABLED    -- code block 3 not protected
pragma target CPB           DISABLED    -- bootblock code not write protected
pragma target CPD           DISABLED    -- eeprom code not write protected
pragma target WRT0          DISABLED    -- table writeblock 0 not protected
pragma target WRT1          DISABLED    -- table write block 1 not protected
pragma target WRT2          DISABLED    -- table write block 2 not protected
pragma target WRT3          DISABLED    -- table write block 3 not protected
pragma target WRTB          DISABLED    -- bootblock not write protected
pragma target WRTD          DISABLED    -- eeprom not write protected
pragma target WRTC          DISABLED    -- config not write protected
pragma target EBTR0         DISABLED    -- table read block 0 not protected
pragma target EBTR1         DISABLED    -- table read block 1 not protected
pragma target EBTR2         DISABLED    -- table read block 2 not protected
pragma target EBTR3         DISABLED    -- table read block 3 not protected
pragma target EBTRB         DISABLED    -- boot block not protected


include delay


-- setup serial software
const serial_sw_baudrate = 9600
alias serial_sw_tx_pin is pin_B4
alias serial_sw_rx_pin is pin_B5
pin_B4_direction = output
pin_B5_direction = input
include serial_software
serial_sw_init()
-- some aliases so it is easy to change from serial hw to serial sw.
alias serial_write is serial_sw_write
alias serial_data is serial_sw_data


-- whether or not using the serial port
const HAS_SERIAL_DEBUG_PORT = 1

include format
include print

const bit USB_DEBUG = FALSE
const bit USB_DEBUG_HIGH = FALSE

;const bit USB_HID_DEBUG = TRUE
;const bit USB_HID_DEBUG_HIGH = TRUE

-- setup debug lib
alias debug_data is serial_data
const bit DEBUG_MASTER_ENABLE = TRUE    -- enables debugging
include debug
--
-- turn on and off debug levels.
debug_lvl_0 = ON
debug_lvl_1 = ON
debug_lvl_2 = ON
--
var byte debug_text1[] = "DEBUG STARTED"
debug_string(DEBUG_1,debug_text1)
debug_crlf(DEBUG_1)

procedure serial_print_spc() is
   debug_char(1, " ")
end procedure

procedure serial_newline() is
   debug_crlf(1)
end procedure


include usb_drv_msd_class

-- -----------------------------------------------------------------------------

var bit adc_enabled = false


procedure usb_ep_data_in_callback(byte in end_point, word in buffer_addr, byte in byte_count) is
   pragma inline
   
   debug_crlf(1)
   const byte str[] = "--- EP data in: "
   debug_string(1,str)
   debug_byte_dec(1,byte_count)
   const byte str2[] = " bytes, on endpoint "
   debug_string(1,str2)
   debug_byte_dec(1, end_point )
   debug_crlf(1)
   
   var byte step
   for byte_count using step loop
      debug_byte_hex(1,msd_tx_buffer[step])
      debug_char(1," ")
   end loop
   
;    -- data has been sent, so do we need to send more?
;    if (end_point == 1) then
;        -- it's the data end point
;        usb_hid_can_tx = true
;    end if
   
   
   msd_data_sent = true
end procedure


procedure usb_ep_data_out_callback(byte in end_point, word in buffer_addr, byte in byte_count) is
   pragma inline
   
   var byte step

   if debug_lvl_1 == TRUE then
      print_crlf(serial_data)
      const byte str[] = "--- EP data out: "
      print_string(serial_data,str)
      print_byte_dec(serial_data,byte_count)
      const byte str2[] = " bytes, on endpoint "
      print_string(serial_data,str2)
      print_byte_dec(serial_data, end_point )
   end if
   
   ;-- We have some data on endpoint 1!
   if (end_point == 1) then
      
      var byte src_ptr[2] AT buffer_addr
      FSR1L = src_ptr[0]
      FSR1H = src_ptr[1]
      
      if (usb_msd_state == USB_MSD_DATA_OUT) then
         ;usb_msd_data_received()
      end if
      
      ;var volatile bit own_bit at usb_bd0in_stat : USB_BDSTATUS_UOWN
      ;if (usb_msd_state == USB_MSD_WAIT) & !own_bit then
      
      if (usb_msd_state == USB_MSD_WAIT) then
         ;PrepareCSWData(); -- prepare CSW data
         if msd_cbw_is_valid() then
            if USB_HOST_DIRECTION_SEND then -- host is waiting to send data
               usb_msd_state = USB_MSD_DATA_OUT
            elsif USB_HOST_DIRECTION_RECEIVE then -- host is waiting to get data
               usb_msd_state = USB_MSD_DATA_IN
               -- prepare to get data from host
            end if
            -- execute command from CBW
            usb_msd_command_received()
         end if
      end if
   end if
   
   usb_prime_epx_out( end_point, USB_EP1_OUT_SIZE )
   
end procedure


include usb_drv

procedure msd_send_data(byte in size) is
   pragma inline
   usb_send_data(1, msd_tx_buffer, size , low )
   msd_data_sent = false
   while msd_data_sent == false loop
      usb_handle_isr
   end loop
end procedure

-- constants
const  byte str_welcome[] = "JAL USB MSD demo! Please wait (takes about 10 seconds) before the device is fully configured"

-- variables
var word i = 0
var bit usb_initialized = false

procedure msddatain() is
   if (usb_msd_data_residue >= 64) & (usb_msd_csw_status == USB_MSD_CSW_STATUS_SUCCESS) then
      
      debug_crlf(2)
      var byte command[] = "SENDING 64 BYTES OF DATA, "
      
      -- read data from drive in 64 byte chunks   		
      var byte step
      for 64 using step loop
         msd_tx_buffer[step] = 0xAA
      end loop
      
      -- send some drive data
      ;usb_send_data(1, msd_tx_buffer, 64 , low )
      msd_send_data(64)
      usb_msd_data_residue = usb_msd_data_residue - 64
      
      -- success if all data was read from the data device ok.
      usb_msd_csw_status = USB_MSD_CSW_STATUS_SUCCESS
      
      debug_string(2,command)
      debug_dword_dec(1,usb_msd_data_residue)
      var byte command2[] = " BYTES LEFT!"
      debug_string(2,command2)
      debug_crlf(2)
   else
      if usb_msd_csw_status == USB_MSD_CSW_STATUS_FAIL then
         
         debug_crlf(2)
         var byte command[] = "STATUS FAIL!!"
         debug_string(2,command)
         debug_crlf(2)
         
         -- last command was not supported, or there was some other error
         
         if (usb_msd_data_residue >= 64) then   		
            -- just send a bunch of 0's as the data the drive expects
            var byte step
            for 64 using step loop
               msd_tx_buffer[step] = 0
            end loop
            
            -- send some drive data
            ;usb_send_data(1, msd_tx_buffer, 64 , low )
            msd_send_data(64)
            usb_msd_data_residue = usb_msd_data_residue - 64
            
            usb_msd_cbw_data_transfer_length = 0
         else                                   		
            -- just send a bunch of 0's as the data the drive expects
            var byte step
            for usb_msd_data_residue using step loop
               msd_tx_buffer[step] = 0
            end loop
            
            -- send some drive data
            ;usb_send_data(1, msd_tx_buffer, 64, low ) ;        -- WHY BYTE???   MAY CAUSE AN ISSUE?
            msd_send_data(64)
            usb_msd_data_residue = 0
            usb_msd_cbw_data_transfer_length = 0
            
         end if
         
      elsif usb_msd_csw_status == USB_MSD_CSW_STATUS_SUCCESS then
         -- wait till data has been sent
         
         debug_crlf(2)
         var byte command[] = "SENDING "
         debug_string(2,command)
         debug_byte_dec(1,byte(usb_msd_data_residue))
         var byte command2[] = " BYTES OF DATA!!"
         debug_string(2,command2)
         debug_crlf(2)
         
         -- send data that was expected by host
         ;usb_send_data(1, msd_tx_buffer, byte(usb_msd_data_residue), low )
         msd_send_data(byte(usb_msd_data_residue))
         ;usb_msd_data_residue = 0
         usb_msd_cbw_data_transfer_length = 0
         
      end if
   end if	
end procedure

procedure usb_send_csw() is
   -- send csw (31 bytes)
   msd_tx_buffer[0] = 0x55
   msd_tx_buffer[1] = 0x53
   msd_tx_buffer[2] = 0x42
   msd_tx_buffer[3] = 0x53
   ;msd_tx_buffer[4] = _usb_msd_csw_signature[0]
   ;msd_tx_buffer[5] = _usb_msd_csw_signature[1]
   ;msd_tx_buffer[6] = _usb_msd_csw_signature[2]
   ;msd_tx_buffer[7] = _usb_msd_csw_signature[3]
   msd_tx_buffer[4] = _usb_msd_cbw_signature[0]
   msd_tx_buffer[5] = _usb_msd_cbw_signature[1]
   msd_tx_buffer[6] = _usb_msd_cbw_signature[2]
   msd_tx_buffer[7] = _usb_msd_cbw_signature[3]
   ;msd_tx_buffer[8] = _usb_msd_csw_tag[0]
   ;msd_tx_buffer[9] = _usb_msd_csw_tag[1]
   ;msd_tx_buffer[10] = _usb_msd_csw_tag[2]
   ;msd_tx_buffer[11] = _usb_msd_csw_tag[3]
   msd_tx_buffer[8] = _usb_msd_cbw_tag[0]
   msd_tx_buffer[9] = _usb_msd_cbw_tag[1]
   msd_tx_buffer[10] = _usb_msd_cbw_tag[2]
   msd_tx_buffer[11] = _usb_msd_cbw_tag[3]
   msd_tx_buffer[12] = usb_msd_csw_status
   
   usb_send_data(1, msd_tx_buffer, 13, low )
   ;msd_send_data(13)
   usb_msd_state = USB_MSD_WAIT
end procedure


procedure usb_tasks() is
   -- Servicing Hardware
   -- use polling method
   usb_handle_isr()
   
   if (usb_msd_state == USB_MSD_DATA_IN) then
      if usb_msd_cbw_data_transfer_length == 0 then
         
         debug_crlf(2)
         var byte command[] = "CSW SENT!"
         debug_string(2,command)
         debug_crlf(2)
         
         -- finnished sending the data, now send the status
         usb_send_csw()
      else
         -- send the data, in 64byte chunks of what host
         -- is expecting to receive.
         ;usb_msd_command_received()
         
         msddatain()
         
      end if
      
   end if
   
end procedure

-- interrupts? No thanks
while INTCON_GIE loop
   INTCON_GIE = false
end loop

-- put info on RS-232 serial line
print_crlf(serial_data)
print_string(serial_data, str_welcome )
serial_newline()

-- setup the USB device
usb_setup()

-- enable USB device
usb_enable_module()

;   procedure usb_hid_tx_report( byte in hid_report_in[], byte in cnt ) is
;   	while ( usb_hid_can_tx == false ) loop
;   		usb_tasks()
;   	end loop
;   	usb_hid_can_tx = false
;   	usb_send_data(USB_HID_ENDPOINT, hid_report_in, cnt , low )
;   end procedure

-- main loop
forever loop
   -- poll the usb ISR function on a regular base, in order to 
   -- serve the USB requests
   usb_tasks()
   
   -- check if USB device has been configured by the HOST
   if usb_is_configured()  then
      
      -- note user via serial line that USB has been configured
      if usb_initialized == false then
         usb_initialized = true
         
         if defined( HAS_SERIAL_DEBUG_PORT ) == true then			
            const  byte str[] = "USB device has been configured by the HOST!"
            print_string(serial_data, str )
            serial_newline()
         end if		
         
      end if
      
   end if
   
   
   if defined( HAS_SERIAL_DEBUG_PORT ) == true then    
      if PIR1_RCIF then
      end if
   end if	
   
end loop
