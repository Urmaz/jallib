-- Title: hardware PWM control, generic procedures
-- Author: Stef Mientki, Copyright (C) 2002-2006, all rights reserved. 
-- Adapted-by: Sebastien Lelong
-- Compiler: >=2.4g
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: this lib handles generic operation on PWM, 
-- whatever the channel number, etc...
-- It's aimed to be used with pwm_{register} lib (eg. pwm_ccp1.jal, ...)
--
-- Notes: this is a heavy refactoring of the original pwm_hardware.jal
-- Stef's lib
--
   


-- initializes the PWM for high resolution (10 bits) and starts the PWM 
-- While setting high resolution, prescaler can be used to adjust frequency. 
-- The parameter corresponds to the prescaler value, and can be either:
--   * 1 : high frequency
--   * 4 : medium frequency
--   * 16: low frequency
--
-- Not all frequencies are available, you'll need the datasheet to actually
-- compute the computed frequency according to the clock speed.
-- 
-- FYI, here's a table showing frequency for common clock speed:
-- 
-- ||*prescaler/clock* ||   *4MHz*   ||   *8MHz*   ||  *10MHz*   ||  *20MHz*   ||
-- ||    1             ||    3.90kHz ||    7.81kHz ||   9.77kHz  ||   19.43kHz ||
-- ||    4             ||     976Hz  ||    1.95kHz ||   2.44kHz  ||    4.88kHz ||
-- ||    16            ||     244Hz  ||     488Hz  ||    610Hz   ||    1.22kHz ||
--
procedure pwm_max_resolution(byte in prescaler) is
   -- set timervalue to maximum resolution
   PR2 = 0xFF
   
   -- set TMR2 prescaler and turn TMR2 on
   if prescaler == 1 then
      T2CON = 0b_0000_0100
   elsif prescaler == 4  then
      T2CON = 0b_0000_0101
   elsif prescaler == 16 then
      T2CON = 0b_0000_0111
   else
      ;THIS PRAGMA IS NOT CORRECTLY HANDLED BY JAL $.59 !!
      ;pragma error  ;pwm frequency is not allowed for high resolution
   end if
end procedure


-- Stores computed PR2 value when prescaler value is 1
-- Used to compute accurate frequency
var volatile dword _pr2_1
-- Stores computed PR2 value when prescaler value is 4
-- Used to compute accurate frequency
var volatile dword _pr2_4
-- Stores computed PR2 value when prescaler value is 16
-- Used to compute accurate frequency
var volatile dword _pr2_16

-- Initializes the PWM for accurate frequency and starts the PWM
procedure pwm_set_frequency(dword in freq) is
   -- compute all values
   _pr2_1 = target_clock / ( 1 *  4 * freq )
   _pr2_4   = target_clock / ( 4 *  4 * freq )
   _pr2_16  = target_clock / ( 16 * 4 * freq )
   -- calculate prescaler and divider
   var byte pre_scaler
   if _pr2_1 == 0 then
      -- since now it's a byte, cannot pragma error'ing...
      -- what should we do ?
      ;;pragma error    -- pwm frequency is too high
      -- turn pwm off
      pre_scaler = 0b_0000_0000
   elsif _pr2_1 <= 256 then
      PR2 = byte(_pr2_1) - 1                     -- load timer value (base period)
      pre_scaler = 0b_0000_0100
   elsif _pr2_4 <= 256 then
      PR2 = byte(_pr2_4) - 1
      pre_scaler = 0b_0000_0101 
   elsif _pr2_16 <= 256 then
      PR2 = byte(_pr2_16) - 1
      pre_scaler = 0b_0000_0110 
   else
      -- again, cannot pragma error'ing...
      ;;pragma error  -- pwm frequency is too low to be realized by this routine,
      ;;-- use the post scaler and interrupt
      pre_scaler = 0b_0000_0000
   end if

   -- load tmr2 prescaler, and turn it on
   -- (post-scaler is not used in PWM !!)
   var byte t2con_tmp = T2CON & 0b_1111_1000
   T2CON   = t2con_tmp | pre_scaler   

end procedure


