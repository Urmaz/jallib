-- ------------------------------------------------------
-- Title: Test program for 24lc256 library
--
-- Author: Joep Suijs, Copyright (c) 2008..2012, all rights reserved.
--
-- Adapted-by: 
--
-- Compiler: >=2.4m
-- Revision: $Revision: 3053 $
--
-- This file is part of jallib  (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: interface to 24lc256 i2c eeprom
--
-- --
-- This file defines a test for JALLIB testing, using a test-board
--  defined by a BOARD file .
--
-- Sources:
--
-- Notes: 
--    setup: 
--         an i2c eeprom type 24lc256 connected to the test board i2c pins.
--         a serial connection to a terminal
--
-- ------------------------------------------------------
--
-- This file has been generated by jallib.py from:
--    * board: board_16f723_af.jal
--    * test : test_24lc256_II.jal
--


-- generic setup (see releated examples for more details);@jallib section chipdef

-- device include
include 16f723

-- Internal osc, running at 16 MHz
pragma target clock 16_000_000


-- fuses
pragma target OSC INTOSC_NOCLKOUT
pragma target WDT DISABLED
pragma target PWRTE DISABLED
pragma target MCLR INTERNAL
pragma target CP DISABLED
pragma target BROWNOUT DISABLED
pragma target VOLTAGE V19
pragma target WDTCS STANDARD
pragma target PLLEN F16MHZ
pragma target DEBUG DISABLED
pragma target VCAPEN pin_A0
enable_digital_io()                -- make all pins digital I/O

;@jallib section serial
const serial_hw_baudrate = 115_200

include serial_hardware
serial_hw_init()
include print
include delay
;@jallib section i2c
-- I2C io definition, using hardware I2C
alias i2c_scl            is pin_c3
alias i2c_scl_direction  is pin_c3_direction
alias i2c_sda            is pin_c4
alias i2c_sda_direction  is pin_c4_direction

-- i2c setup
const word _i2c_bus_speed = 1 ; * 100kHz
const bit _i2c_level = true   ; i2c levels (not SMB)

include i2c_software                
;include i2c_hardware
i2c_initialize()

-- 24lc256 setup
;const eeprom_i2c_address = 0xA2  ; use when i2c address is not default 0xA0
const eeprom_buffer_size = 20    ; use to save ram - default is eeprom page size (64 bytes for 24lc256) for optimal performance
include 24lc256            

block
   var byte str1[] = "\r\n\r\n-- Start of test sequence ---------------------------------\r\n"
   print_string(serial_hw_data, str1)      
end block

var bit ack_ok
var byte data         

forever loop                     
   
   -- --------------                
   -- write sequence
   -- --------------                
                   
   ; write a few bytes (bytes are actually cached..)
   ack_ok = true
   ack_ok = ack_ok & ee_24lcxx_write(0, 0x11);   write to location 0
   ack_ok = ack_ok & ee_24lcxx_write(1, 0x22);   write to location 1
   ack_ok = ack_ok & ee_24lcxx_write(2, 0x33);   write to location 2

   ; cached bytes are automaticly written when                                         
   ; - write at non-sequential address 
   ; - buffer is full 
   ; - page boundery is passed
   ; all transparent for you!
   ack_ok = ack_ok & ee_24lcxx_write(5, 0x44);   write to location 5, non-sequential 
   
   ; flush buffer / write any remaining cached bytes   
   ; (it is good practice to call this function when you 
   ;  won't be writing more data within 10ms to 1 sec or so)
   ack_ok = ack_ok & ee_24lcxx_flush()                                                                    
   
   ; check if all went well                                                                    
   if (ack_ok == false) then
      var byte str1[] = "error: write sequence failed\r\n"
      print_string(serial_hw_data, str1)      
   end if
                   
   -- -------------                
   -- read sequence
   -- --------------                

   ; read first byte  
   ack_ok = ee_24lcxx_read(0, data)   
   for 7 loop   
      
      ;----------------------
      ; process previous byte 
      ; (from previous itteration or before entering the loop)
      
      if (ack_ok) then   
         -- on succes, print data
         print_byte_hex(serial_hw_data, data)      
      else                       
         -- on fail, print '**'
         serial_hw_data = "*"
         serial_hw_data = "*"
      end if
      serial_hw_data = " "     
      
      ;--------------
      ; get next byte
      
      ; Use ee_24lcxx_read_next() to efficiently get next bytes.
      ; The address is set by either ee_24lcxx_read or ee_24lcxx_write.
      ; Each ee_24lcxx_read_next() will increment the address by one.
      ack_ok = ee_24lcxx_read_next(data)   

   end loop
   
   print_crlf(serial_hw_data)
   delay_1ms(1000) 
end loop







