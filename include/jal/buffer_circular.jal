-- Title: Library for creating a circular buffer.
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4l
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: This library allows you to create circular buffer(s).
--
-- Sources:
-- http://en.wikipedia.org/wiki/Circular_buffer
--
-- Notes:
-- change BUFFER_1_SIZE to a byte if possible (if small buffer)
-- you may use the large array library to make a bigger buffer
--
-- Example:
-- const byte BUFFER_1_WIDTH = 2            -- choose width of buffer variables
-- const dword BUFFER_1_SIZE = 100          -- choose number of buffer variables
-- var byte*BUFFER_1_WIDTH buffer_1_array[BUFFER_1_SIZE] -- the buffer array
-- include buffer                           -- include buffer library
--

if defined(buffer_1_array) == TRUE then
   if BUFFER_1_SIZE <= 0xFF then
      var byte buffer_1_count = 0             -- holds amount of data in buffer
      var byte _buffer_1_write_location = 0   -- position of array to write to next
      var byte _buffer_1_read_location = 0    -- position of array to read from next
   elsif (BUFFER_1_SIZE > 0xFF) & (BUFFER_1_SIZE <= 0xFFFF) then
      var word buffer_1_count = 0             -- holds amount of data in buffer
      var word _buffer_1_write_location = 0   -- position of array to write to next
      var word _buffer_1_read_location = 0    -- position of array to read from next
   else
      var dword buffer_1_count = 0            -- holds amount of data in buffer
      var dword _buffer_1_write_location = 0  -- position of array to write to next
      var dword _buffer_1_read_location = 0   -- position of array to read from next
   end if

   var bit buffer_1_overflow = FALSE          -- will be set if buffer overflow
   var bit buffer_1_underrun = FALSE          -- will be set if buffer underrun
   var bit buffer_1_empty = TRUE              -- will be set if buffer is empty
   var bit buffer_1_full = FALSE              -- will be set if buffer is full

   procedure buffer_1_data'put(byte*BUFFER_1_WIDTH in data) is
      if buffer_1_count == BUFFER_1_SIZE then -- if buffer is already full
         buffer_1_overflow = TRUE             -- set overflow bit and do nothing
      else                                    -- if buffer is not full
         -- go back to the beginning of the array if at the end
         if _buffer_1_write_location == BUFFER_1_SIZE then
            _buffer_1_write_location = 0
         end if
         
         buffer_1_underrun = FALSE  -- buffer is not underrun

         buffer_1_array[_buffer_1_write_location] = data         -- put data in the buffer at _buffer_1_write_location
         buffer_1_count = buffer_1_count + 1                     -- increment amount of data in buffer
         _buffer_1_write_location = _buffer_1_write_location + 1 -- increment array placement

         -- set buffer ready status
         if buffer_1_count < BUFFER_1_SIZE then       -- if there is room in the buffer
            buffer_1_empty = FALSE
            buffer_1_full = FALSE
            buffer_1_overflow = FALSE
         elsif buffer_1_count == BUFFER_1_SIZE then   -- if the buffer is full
            buffer_1_full = TRUE
            buffer_1_overflow = FALSE
         end if
      end if
   end procedure

   function buffer_1_data'get() return byte*BUFFER_1_WIDTH is
      var byte*BUFFER_1_WIDTH data

      if buffer_1_count == 0 then             -- if buffer is already empty
         buffer_1_underrun = TRUE             -- set underrun bit and do nothing
      else                                    -- if buffer is not empty
         -- go back to the beginning of the array if at the end
         if _buffer_1_read_location == BUFFER_1_SIZE then
            _buffer_1_read_location = 0
         end if
         
         buffer_1_overflow = FALSE  -- buffer is not overflow

         data = buffer_1_array[_buffer_1_read_location]          -- put data in the buffer at _buffer_1_read_location
         buffer_1_count = buffer_1_count - 1                     -- decrement amount of data in buffer
         _buffer_1_read_location = _buffer_1_read_location + 1   -- increment array placement

         -- set buffer ready status
         if buffer_1_count > 0 then       -- if there is something in the buffer
            buffer_1_full = FALSE
            buffer_1_empty = FALSE
            buffer_1_underrun = FALSE
         elsif buffer_1_count == 0 then   -- if the buffer is empty
            buffer_1_empty = TRUE
            buffer_1_underrun = FALSE
         end if
      end if

      return data -- return the data
   end function
end if
