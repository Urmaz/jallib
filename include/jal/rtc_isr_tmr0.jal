-- Title: Real Time Clock running from ISR on TMR0
-- Author: Eur van Andel, Copyright (c) 2003..2008, all rights reserved.
-- Adapted-by: 
-- Compiler: >=2.4h
-- 
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Sources:  http://www.romanblack.com/one_sec.htm, http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm
-- 
-- Description: This Interrupt Service Routine updates the variable seconds about once per second.
-- The precision is 0.2 ppm, the accuracy depends on the Xtal used. 
--
-- Notes: This is the Bresenham Line Algorithm, invented at IBM in 1962, which gets an accurate end result
-- by summing the small errors resulting of taking discrete steps and correcting when the error gets too large.
-- This means that individual second lengths may show some jitter, but that long-term timekeeping is accurate.
-- Original assembler by Roman Black. 
--

-- 20 MHz, so 200ns/clock, so 5 000 000 clocks/second
-- the RTC has three bytes: bres_hi, bres_mid, bres_lo
-- timer 0 runs on internal clock speed and interrupts on overflow
-- every timer 0 interrupt decreases bres_mid by one.
-- the  2 000 000 value is added when bres_hi en bres_mid are zero
-- note that remainder is added to bres_lo, which cab overflow in bres_mid
-- this keeps clock count accurate, although interrupts happen every 256 clock counts
-- the ISR subtracts 1 from the mid byte. It first checks
-- the mid byte for zero and borrows a bit from bres_hi if needed


var volatile byte seconds                 -- updated by ISR

-- RTC ISR constants:
--                      0x4C 0x4B 0x40  5 000 000  20 MZz xtal
--                      0x0F 0x42 0x40  1 000 000   4 MHz int osc  
--                      0x12 0x13 0xD0  1 250 000   20 MHz, prescaler = 4

const hi  = 0x4C  -- 2 000 000 for 20 MHz xtal and prescaler = 4
const mid = 0x4B
const lo  = 0x40  -- ideally modified in timeset too, to adjust clock                                                  

var volatile byte bres_hi  = hi
var volatile byte bres_mid = mid
var volatile byte bres_lo  = lo

procedure RTC() is
   pragma interrupt     
   assembler         -- ISR should be as small as possible, so assembler
      local int_exit       -- labels for jumping
      
      bcf   INTCON_TMR0IF     -- clear the timer 0 interrupt flag
      movf  bres_mid,f        -- mid == 0 ?
      btfsc STATUS_Z          -- not zero?
      decf  bres_hi, f        -- zero, borrow one from high byte
      decfsz bres_mid, f       -- this is the count of the interrupts
      goto  int_exit          -- mid byte is not zero, so exit
      movf  bres_hi, f        -- mid == 0, might hi == 0 too ?
      btfss STATUS_Z
      goto  int_exit          -- high byte not zero, so exit
      -- high byte zero, mid also zero
      -- we need to load the one-second timer
      
      movlw hi                -- add  2 000 000 to hi-mid-lo
      movwf bres_hi           -- hi & mid are both zero
      movlw mid
      movwf bres_mid
      movlw lo                -- lo is not zero, and must be added
      addwf bres_lo, f        -- bres_lo can overflow
      btfsc STATUS_C          -- does it?
      incf  bres_mid, f       -- yes, but mid was 0x4B, so will not overflow
      incf  seconds, f        -- main routine should check seconds
      -- and call calendar when seconds > 59
      -- and take care of minutes, etc.
      int_exit:
   end assembler
end procedure                   -- end of ISR




