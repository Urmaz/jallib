-- Title: Real Time Clock running from ISR on TMR3
-- Author: Eur van Andel, Copyright (c) 2010, all rights reserved.
-- Compiler: 2.4m
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Sources: http://www.romanblack.com/one_sec.htm
--          http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm
--
-- Description: This Interrupt Service Routine updates the variable seconds
-- about once per second. The precision is 0.2 ppm, the accuracy depends
-- on the Xtal used. The main program should check if seconds are > 60 and
-- if so, increase minutes, hours, days, months, etc. calendar.jal does this
--
-- Notes: This is the Bresenham Line Algorithm, invented at IBM in 1962,
-- which gets an accurate end result by summing the small errors resulting of
-- taking discrete steps and correcting when the error gets too large. This
-- means that individual second lengths may show some jitter, but that long-term
-- timekeeping is accurate. Original assembler by Roman Black.
-- --
-- For instance: if xtal=20 MHz, then 5 MHz clock, so 5 000 000 clocks/second
-- TMR3 runs on internal clock speed and interrupts on overflow
-- every TMR3 interrupt decreases _rtc_bresenham by 0x1_00_00, or 2^16
-- if _rts_bresenham < 0x1_00_00 then 5_000_000 is added
-- so the jitter is 2^15/5e6 = 0.6%
-- Total second count is accurate, since the lower 15 bits stay intact and add up

-- This RTC runs on TMR3. You must setup TMR3 yourself in the main program.
-- prescaler = 1, internal clock, TMR3 = on
-- TMR3IE = on, INTCON_GIE = on
-- A typical setup looks for a PIC18F look like this:

-- T3CON_T3CKPS   = 0b00      -- 1:1 prescaler
-- T3CON_TMR3_ON  = on        -- TMR3 on

-- PIE2_TMR3IE    = on        -- TMR3 interrupt enabled
-- IPR_TMR3IP     = on        -- high priority interrupt for TMR3 (default on)
-- RCON_IPEN      = off       -- no interrupt priorities (default off)
-- INTCON_PEIE    = on        -- peripheral interrupt enabled
-- INTCON_GIE     = on        -- global interrupt enabled

var volatile byte seconds               -- global variable updated by ISR
const  _rtc_cycles_per_second = (target_clock / 4)
var volatile dword _rtc_bresenham = _rtc_cycles_per_second

procedure RTC() is
   pragma interrupt
   PIR2_TMR3IF = false              -- clear interrupt flag
   _rtc_bresenham = _rtc_bresenham - 0x1_00_00
   if _rtc_bresenham < 0x1_00_00 then 
      seconds = seconds + 1
      _rtc_bresenham = _rtc_bresenham + _rtc_cycles_per_second
   end if
end procedure




