-- Title: Writes variables to output device
-- Author: Oliver "Kiste" Seitz, Copyright (c) 2011, all rights reserved.
-- Based on the original print.jal library by Joep Suijs and Michael Watterson
-- Compiler: >=2.4o
-- Revision: $Revision$
-- 
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Sources: 
-- 
-- Description: Outputs variables to output device.
-- formats: _decimal and _hex
-- vars:    bit, byte, sbyte, word, sword, dword, sdword
-- --
-- for decimal output, arbitrary var size supported. Define
-- const _print_max_var_size_dec=4            -- default, decrease to save resources, increase as needed
-- before including this library.
-- --  
-- Example:
-- --     
-- var sword bhl = -684
-- --     
-- ; print the signed word to the LCD display
-- print_sword_dec(lcd_char, bhl)
-- --     
-- ; and now print the same signed word to the serial port
-- print_sword_dec(serial_hw_data, bhl)
-- --
-- ; Specials:
-- print_crlf(serial_hw_data)  -- print cr + lf to device
-- ; 
-- const byte str1[] = "JalLibWorld V1.0\n"     
-- print_string(serial_hw_data, str1) -- print string to device
-- ;
-- ; Note - the whole string - that is the length of the array - 
-- ; is printed. When you use a variable array to construct strings,
-- ; you might want to terminate at a termination character, like 0.
-- ; You can set this termination character with:
-- ; const print_string_terminator = 255
-- ; (or use a var if you want to change it runtime.)
-- ;
-- include print      
--
-- Notes: 
--  print_sword_fp_dec has been dropped, for outputting fixed point numbers use format.jal lib.
--

include jascii         
         
; prototypes
procedure print_byte_binary(volatile byte out device, byte in data)

var bit print_prefix = false        

procedure print_crlf(volatile byte out device) is
   device = ASCII_CR -- cariage return
   device = ASCII_LF -- line feed
end procedure

procedure print_string(volatile byte out device, byte in str[]) is
   var word len = count(str)
   var byte i
   
   for len using i loop           
      if (defined(print_string_terminator) == true) then
         if (str[i] == print_string_terminator) then exit loop end if
      end if         
      device = str[i]
   end loop
      
end procedure

procedure print_bit_truefalse(volatile byte out device, bit in data) is
   
   const byte str1[] = "true"   
   const byte str0[] = "false"   

   if (data) then
      print_string(device, str1)
   else
      print_string(device, str0)
   end if
         
end procedure

procedure print_bit_highlow(volatile byte out device, bit in data) is
   
   const byte str1[] = "high"   
   const byte str0[] = "low"   

   if (data) then
      print_string(device, str1)
   else
      print_string(device, str0)
   end if
         
end procedure

procedure print_bit_10(volatile byte out device, bit in data) is
   
   if (data) then
      device = "1"
   else
      device = "0"
   end if

--     device="0"+byte(data)         
end procedure

procedure print_dword_binary(volatile byte out device, dword in data) is
   
   if (print_prefix) then
      device = "0"
      device = "b"
   end if

   var byte a_data[4] at data

   print_byte_binary(device, a_data[3])
   print_byte_binary(device, a_data[2])
   print_byte_binary(device, a_data[1])
   print_byte_binary(device, a_data[0])
   
end procedure

procedure print_word_binary(volatile byte out device, word in data) is

   if (print_prefix) then
      device = "0"
      device = "b"
   end if

   var byte a_data[2] at data
   
   print_byte_binary(device, a_data[1])
   print_byte_binary(device, a_data[0])
   
end procedure


procedure print_byte_binary(volatile byte out device, byte in data) is

   var bit high_bit at data:7
   
   if (print_prefix) then
      device = "0"
      device = "b"
   end if

   for 8 loop    
      if high_bit then
         device = "1"
      else
         device = "0"
      end if
      data = data * 2
   end loop
   
end procedure


procedure print_nibble_binary(volatile byte out device, byte in data) is
   
   var bit high_bit at data:3

   for 4 loop    
      if high_bit then
         device = "1"
      else
         device = "0"
      end if
      data = data << 1
   end loop
   
end procedure

function nibble2hex(bit*4 in nibble) return byte is
pragma inline
   var byte convert

   convert=byte(nibble)
   convert=convert+"0"
   if (convert > "9") then
     convert=convert + ( "A" - "0" -10 )
   end if

   return convert

end function

procedure print_byte_hex(volatile byte out device, byte in data) is             


   if (print_prefix) then
      device = "0"
      device = "x"
   end if


   device = nibble2hex(data>>4)
   device = nibble2hex(data)
   
end procedure



procedure print_dword_hex(volatile byte out device, dword in data) is

   if (print_prefix) then
      device = "0"
      device = "x"
   end if

   var byte a_data[4] at data
  
  print_byte_hex(device,a_data[3])
  print_byte_hex(device,a_data[2])
  print_byte_hex(device,a_data[1])
  print_byte_hex(device,a_data[0])
      
   
end procedure

procedure print_sdword_hex(volatile byte out device, sdword in data) is

   if (print_prefix) then
      device = "0"
      device = "x"
   end if

   var byte a_data[4] at data
  
  print_byte_hex(device,a_data[3])
  print_byte_hex(device,a_data[2])
  print_byte_hex(device,a_data[1])
  print_byte_hex(device,a_data[0])

      
   
end procedure


procedure print_word_hex(volatile byte out device, word in data) is

   if (print_prefix) then
      device = "0"
      device = "x"
   end if

   var byte a_data[2] at data
  
  print_byte_hex(device,a_data[1])
  print_byte_hex(device,a_data[0])



   
   
end procedure


procedure print_sword_hex(volatile byte out device, sword in data) is

   if (print_prefix) then
      device = "0"
      device = "x"
   end if
  
   var byte a_data[2] at data
  
  print_byte_hex(device,a_data[1])
  print_byte_hex(device,a_data[0])


 
   
end procedure






if ! defined(_print_max_var_size_dec) then
  const  _print_max_var_size_dec=4          -- if not defined, keep compatibility with conventional print.jal
end if

var byte*_print_max_var_size_dec _print_dec_divisor  -- sorry for the global variable, but this variable can be huge...


procedure _make_tenfold_divisor() is

--        _print_dec_divisor=(_print_dec_divisor<<1)+(_print_dec_divisor<<3)
--  This is the line that did limit the variable size to 128 bytes. The new approach
--  is also cheaper on code and ram

  var byte*_print_max_var_size_dec temp
  
  _print_dec_divisor=_print_dec_divisor<<1
  temp=_print_dec_divisor
  temp=temp<<2
  _print_dec_divisor=_print_dec_divisor+temp
  
--  could perhaps be replaced by ...*10 on PIC_16 cores from compiler 2.4p on. 

end procedure


procedure print_maxvar_dec(volatile byte out device, byte*_print_max_var_size_dec in data) is


  var word counter
  var byte digit   

     --  max_digits=word((dword(_print_max_var_size_dec)*240824)/100_000)+1 
     --  this result is accurate to up to 12499 byte or 30101 decimal digits
  
  _print_dec_divisor=1
  counter=0


  -- find number of really needed digits
  
  while (_print_dec_divisor<=data) & (counter<((_print_max_var_size_dec*240824)/100_000)+1) loop 
 
    _make_tenfold_divisor()
    counter=counter+1                             

  end loop

  
  if counter==0 then  -- Data is 0, print one digit then
    counter=1
  end if

  repeat
    counter=counter-1

    _print_dec_divisor=1

    for counter loop              -- set divisor to ten to the power of counter
      _make_tenfold_divisor()
    end loop

    digit="0"
    while data>=_print_dec_divisor loop
      data=data-_print_dec_divisor
      digit=digit+1
    end loop

    device=digit

  until counter==0
  


end procedure

procedure print_maxsvar_dec(volatile byte out device, sbyte*_print_max_var_size_dec in data) is

  if data<0 then
    device="-"
    data=-data
  end if

  print_maxvar_dec(device,byte*_print_max_var_size_dec(data))

end procedure

if _print_max_var_size_dec>3 then

  procedure print_dword_dec(volatile byte out device, dword in data) is
  
    print_maxvar_dec(device, byte*_print_max_var_size_dec(data)) 

  end procedure

  procedure print_sdword_dec(volatile byte out device, sdword in data) is
  
    print_maxsvar_dec(device, sbyte*_print_max_var_size_dec(data)) 

  end procedure

end if

if _print_max_var_size_dec>1 then

  procedure print_word_dec(volatile byte out device, word in data) is
  
    print_maxvar_dec(device, byte*_print_max_var_size_dec(data)) 

  end procedure

  procedure print_sword_dec(volatile byte out device, sword in data) is
  
    print_maxsvar_dec(device, sbyte*_print_max_var_size_dec(data)) 

  end procedure

end if

if _print_max_var_size_dec>0 then  -- well.. haha ;-)

  procedure print_byte_dec(volatile byte out device, byte in data) is
  
    print_maxvar_dec(device, byte*_print_max_var_size_dec(data)) 

  end procedure

  procedure print_sbyte_dec(volatile byte out device, sbyte in data) is
  
    print_maxsvar_dec(device, sbyte*_print_max_var_size_dec(data)) 

  end procedure

end if




