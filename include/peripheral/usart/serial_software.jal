-- Title: Software RS232 library
-- Author: Stef Mientki, Copyright (c) 2002..2006, all rights reserved.
-- Adapted-by: Sebastien Lelong, Albert Faber
-- Compiler: >=2.4l
-- 
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: software RS232 library
-- Library supports software RS232 send and receive procedure on any IO-pin.
-- Both the inverted and non-inverted routines are available, 
-- so it should fit any hardware.
-- Baudrate can be set between 110 and 230_400 (for 20 Mhz Xtal),
-- for lower Xtal frequencies the maximum baudrate will be equally lower.
-- Baudrates are optimized, so even the high baudrates shouldn't be a problem
-- (my [Stef] standard = 115_200 Baud, which has never given me any problems).
-- Interrupts are disabled during transmissions.
-- Transmission parameters are 8 databits, 2 stopbits, no parity, no handshake.
-- const serial_sw_stopbits = 1 ; setup for one stopbit.                                                
--
-- TODO: should transmission parameters be configurable ? 
-- (8 databits, 1 stopbits, no parity, no handshake)
--

if (defined(serial_sw_invert) == false) then
   -- default is low active-serial (like serial_hw)
   const bit serial_sw_invert = true
end if

if (defined(serial_sw_stopbits) == false) then
   -- default is 2 stopbits
   const serial_sw_stopbits = 2
end if

procedure serial_sw_init() is
   -- ouput/tx pin active or not according to invert
   if serial_sw_invert then
      serial_sw_tx_pin = high
   else
      serial_sw_tx_pin = low
   end if
end procedure


;; Number of instructions per bit
const _NINSTR = target_clock / (4 * serial_sw_baudrate)
const _NINSTR2 = 5 + ( _NINSTR / 2)
-- -----------------------------------------------------------------------------


;; Transmit parameters
const OL_TX  = ( _NINSTR / ( 3 * 255 )) + 1
const _IL_TX  = ( ( _NINSTR - ( 4 * OL_TX ) ) - 16 ) / ( 3 * OL_TX )

;; because some corrections have to be made, declare InnerLoop counter as var
var byte IL_TX = _IL_TX

;; for small values, the value is truncated in stead of rounded, so add 1
if _IL_TX < 10 then
   IL_TX = _IL_TX + 1
end if

-- -----------------------------------------------------------------------------
-- For Xtal = 20_000_000, the following counter values are calculated (in Hex)
--  Baud      olcnt    ilcnt     Ninstr
--  110       3C       FB
--  300       16       FA
--  600       0B       FA
--  1200      06       E5
--  2400      03       E4
--  4800      02       A9
--  9600      01       A6
--  14_400    01       6D
--  19_200    01       50
--  38_400    01       24
--  57_600    01       16
--  115_200   01       08        43
--  230_400   01       01        22    NOT TESTED
--
-- Test sequence used: all possibilities



;-- receiving is optimized for 20 Mhz, 320_400 Baud
;--   Number of instructions = (3 * olval * Ilval) + (4 * olval) + 15
;-- 320kB  ==>  olval = ilval = 1
;-- next optimization for 20 Mhz, 115_200 Baud  olval = 1
;--   olval = 1   ==>   ilval = 8
;-- all other buadrates downto 1200 shouldnt be a problem now
;-- because of "IF-statement" this constant must be declared as a var
;
;var byte ilval
;var byte olval
;var byte ilval0
;
;if serial_sw_baudrate < 200_000 then
;   const _olval  = ( _NINSTR / ( 3 * 255 )) + 1
;   const _ilval  = ( ( _NINSTR - ( 4 * _olval ) ) - 15 ) / ( 3 * _olval )
;   const _ilval0 = ( ( _NINSTR2 - ( 4 * _olval ) ) - 5 ) / ( 3 * _olval )
;   
;   
;   ilval  = _ilval
;   olval  = _olval
;   ;due to rounding the next value can slightly below 1
;   if _ilval0 > 0 then
;      ilval0 = _ilval0
;   else
;      ilval0 = 1
;   end if
;   ilval0 = _ilval0
;   
;   -- test if baudrate valid for the chosen Xtal frequency
;   if _olval > 255 then
;      pragma error  -- baudrate too low for this Xtal
;   end if
;   if _olval == 0 then
;      pragma error  -- baudrate too high for this Xtal
;   end if
;   
;else
;   const _ilval = 1
;   const _olval = ((target_clock / (4 * serial_sw_baudrate)) - 15 ) / (4 + 3 * _ilval)
;   ilval = _ilval
;   olval = _olval
;
;end if
;
;-- For Xtal = 20_000_000, the following counter values are calculated (in Hex)
;--  Baud      olcnt    ilcnt     ILcnt0      Ninstr
;--  110       3C       FB        7C
;--  300       16       FA        7C
;--  600       0B       FA        7C
;--  1200      06       E5        72
;--  2400      03       E4        72
;--  4800      02       A9        55
;--  9600      01       A7        55
;--  14_400    01       6D        38
;--  19_200    01       50        2A
;--  38_400    01       25        14
;--  57_600    01       16        0D
;--  115_200   01       08        05          43
;--  230_400   ?        ?         ?           22    NOT TESTED
;--
;-- Test sequence used (Hex)
;--    01  02  04  08  10  20  40  80  00 FF  AA  55

-- calculate instruction execution time in 10ns units
const serial_sw_instruction_time = 400_000_000 / target_clock
const serial_sw_bit_time = (1_000_000/serial_sw_baudrate) - ((13 * serial_sw_instruction_time) / 100)

-- Waits untill a character is received.
-- Interrupts will be disabled during this routine, but restored afterwards.
-- Also here the code is doubled (inverting and non-inverting)
-- and selection is done by a compiler-directive.
procedure serial_sw_write(byte in data) is
   var bit old_gie    ;status of interrupt enable on entrance
   ;; jallib(seb): this is a way to act on tx pin
   ;;var bit pp at serial_sw_out_port : serial_sw_out_nr
   
   var bit data_bit at data : 0
   
   -- stop interrupts and be sure they are stopped
   -- save old interrupt status
   old_gie = INTCON_GIE
   while INTCON_GIE loop
      INTCON_GIE = false
   end loop
   
   if serial_sw_invert then
      serial_sw_tx_pin = low
      _usec_delay(serial_sw_bit_time)
      for 8 loop
         -- wait a whole bittime, less some usec for other actions
         serial_sw_tx_pin = data_bit
         data = data >> 1
         _usec_delay(serial_sw_bit_time)
      end loop
      -- add stop bit(s)
      serial_sw_tx_pin = high
      _usec_delay(serial_sw_stopbits * serial_sw_bit_time)
      
   else
      -- invert the data
      data = ! data 
      serial_sw_tx_pin = high
      _usec_delay((1_000_000/serial_sw_baudrate)-2)
      for 8 loop
         -- wait a whole bittime, less some usec for other actions
         serial_sw_tx_pin = data_bit
         data = data >> 1
         _usec_delay(serial_sw_bit_time)
      end loop
      -- add stop bit(s)
      serial_sw_tx_pin = low
      _usec_delay(serial_sw_stopbits * serial_sw_bit_time)
   end if
   
   -- restore old interrupt status
   INTCON_GIE = old_gie

end procedure


-- Waits untill a character is received.
-- Interrupts will be disabled during this routine, but restored afterwards.
-- Also here the code is doubled (inverting and non-inverting)
-- and selection is done by a compiler-directive.
procedure serial_sw_read_wait(byte out data) is
   var bit  ie_old    ;status of interrupt enable on entrance
   var bit ready
   ;; jallib(seb): this is a way to act on rx pin
   ;;var bit pp at serial_sw_in_port : serial_sw_in_nr
   
   -- stop interrupts and be sure they are stopped
   -- save old interrupt status
   ie_old = INTCON_GIE
   while INTCON_GIE loop
      INTCON_GIE = false
   end loop
   
   if serial_sw_invert then
      -- wait for serial line inactive
      while !serial_sw_rx_pin loop end loop 

      ready = false
      while !ready loop
         -- wait for startbit
         while serial_sw_rx_pin loop end loop 
         
         -- wait half a bit time, less 5 usec for other actions
         _usec_delay(serial_sw_bit_time / 2)
         
         -- test if still startbit, otherwise restart
         if !serial_sw_rx_pin then
            -- now fetch 8 bits
            for 8 loop
               -- wait a whole bittime, less 5 usec for other actions
               _usec_delay(serial_sw_bit_time)
               -- shift new bit in
               data = data >> 1
               if serial_sw_rx_pin then
                  data = data | 0x80
               end if 
            end loop
            ready = true
         else
            ready = false
         end if
      end loop
   else  ;NOT inverted
      -- wait for serial line inactive
      while serial_sw_rx_pin loop end loop 
      
      ready = false
      while !ready loop
         -- wait for startbit
         while !serial_sw_rx_pin loop end loop 
         
         -- wait half a bit time, less 5 usec for other actions
         _usec_delay((serial_sw_bit_time / 2)
         
         -- test if still startbit, otherwise restart
         if serial_sw_rx_pin then
            -- now fetch 8 bits
            for 8 loop
               -- wait a whole bittime, less 5 usec for other actions
               _usec_delay((serial_sw_bit_time)
               -- shift new bit in
               data = data >> 1
               if !serial_sw_rx_pin then
                  data = data | 0x80
               end if 
            end loop
            ready = true
         else
            ready = false
         end if
      end loop
   end if
   
   -- restore old interrupt status
   INTCON_GIE = ie_old
   
end procedure


-- -----------------------------------------------------------------------------
-- Here the serial_sw_write procedure is declared as a pseudo variable
-- so you can use it in the following way:
-- {{{
--    serial_sw_write = 0x33
-- }}}
procedure serial_sw_data'put(byte in data) is
   serial_sw_write(data)
end procedure

-- Here the serial_sw_read_wait procedure is declared as a pseudo variable
-- so you can use it in the following way
-- {{{
--    Data = serial_sw_write
-- }}}
function serial_sw_data'get() return byte is
   var byte data
   serial_sw_read_wait( data )
   return data
end function  

-- Waits untill a character is received or time out is reached.
-- Interrupts will be disabled during this routine, but restored afterwards.
-- Also here the code is doubled (inverting and non-inverting)
-- and selection is done by a compiler-directive.
function serial_sw_read(byte out data) return bit is
   var bit ie_old    ;status of interrupt enable on entrance
   ;; jallib(seb): this is a way to act on rx pin
   ;;var bit pp at serial_sw_in_port : serial_sw_in_nr
   
   
   if serial_sw_invert != serial_sw_rx_pin then
      return false
   end if

   -- stop interrupts and be sure they are stopped
   -- save old interrupt status
   ie_old = INTCON_GIE
   while INTCON_GIE loop
      INTCON_GIE = false
   end loop
   
   if serial_sw_invert then
       -- wait for startbit
      while serial_sw_rx_pin loop end loop 
      
      -- wait half a bit time, less 5 usec for other actions
      _usec_delay(serial_sw_bit_time / 2)
      
      -- now fetch 8 bits
      for 8 loop
         -- wait a whole bittime, less 5 usec for other actions
         _usec_delay(serial_sw_bit_time)
         -- shift new bit in
         data = data >> 1
         if serial_sw_rx_pin then
            data = data | 0x80
         end if 
      end loop
   else  ;NOT inverted
      -- wait for startbit
      while !serial_sw_rx_pin loop end loop 
      
      -- wait half a bit time, less 5 usec for other actions
      _usec_delay(serial_sw_bit_time / 2)
      
      -- now fetch 8 bits
      for 8 loop
         -- wait a whole bittime, less 5 usec for other actions
         _usec_delay((serial_sw_bit_time)
         -- shift new bit in
         data = data >> 1
         if !serial_sw_rx_pin then
            data = data | 0x80
         end if 
      end loop
   end if
   
   -- restore old interrupt status
   INTCON_GIE = ie_old
   
   return true

end function


