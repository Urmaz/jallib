-- Title: i2c_hardware
-- Author: Stef Mientki, Copyright (C) 2005 Stef Mientki
-- Adapted-by: Joep Suijs.
-- Compiler: >=2.4g
-- 
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: Hardware implementation of I2C (single) master.
--
-- TODO:
--

-- --------------------------------------------------------------------
-- some constants needed for the baudrate generator
-- --------------------------------------------------------------------
const _i2c_100khz = (target_clock / (4 *  100_000)) - 1
const _i2c_400khz = (target_clock / (4 *  400_000)) - 1
const _i2c_1mhz   = (target_clock / (4 * 1000_000)) - 1
-- --------------------------------------------------------------------

if (
		( target_cpu != PIC_16 ) 
		 
		-- exclude PIC18C452 Family
--		( target_chip == PIC_18C242  ) |
--		( target_chip == PIC_18C252  ) |
--		( target_chip == PIC_18C442  ) |
--		( target_chip == PIC_18C452  ) |

--		-- exclude PIC18C458 Family
--		( target_chip == PIC_18C248  ) |
--		( target_chip == PIC_18C258  ) |
--		( target_chip == PIC_18C448  ) |
--		( target_chip == PIC_18C458  ) |
--
--		-- exclude PIC18C601/801
--		( target_chip == PIC_18C601  ) |
--		( target_chip == PIC_18C801  ) |
--
		-- exclude PIC18F4431 Family
--		( target_chip == PIC_18F2231  ) |
--		( target_chip == PIC_18F2431  ) |
--		( target_chip == PIC_18F4231  ) |
--		( target_chip == PIC_18F4431  ) |
		
--		-- exclude PIC18F8720 Family
--		( target_chip == PIC_18F6520  ) |
--		( target_chip == PIC_18F6620  ) |
--		( target_chip == PIC_18F6720  ) |
--		( target_chip == PIC_18F8520  ) |
--		( target_chip == PIC_18F8620  ) |
--		( target_chip == PIC_18F8720  ) |
--		
--		-- exclude PIC18f1220/PIC18f1230
--		( target_chip == PIC_18F1220 ) |
--		( target_chip == PIC_18F1230 ) 
											) then
		const bit i2c_old_statemachine = 1
else
		var volatile byte SSPCON is SSP1CON
		var volatile byte SSPCON2 is SSP1CON2
		var volatile byte SSPADD is SSP1ADD
		var volatile byte SSPSTAT is SSP1STAT
		var volatile byte SSPBUF is SSP1BUF

		var volatile bit SSPCON2_GCEN is SSP1CON2_GCEN
		var volatile bit SSPCON2_ACKSTAT is SSP1CON2_ACKSTAT
		var volatile bit SSPCON2_ACKDT is SSP1CON2_ACKDT
		var volatile bit SSPCON2_ACKEN is SSP1CON2_ACKEN
		var volatile bit SSPCON2_RCEN is SSP1CON2_RCEN
		var volatile bit SSPCON2_PEN is SSP1CON2_PEN
		var volatile bit SSPCON2_RSEN is SSP1CON2_RSEN
		var volatile bit SSPCON2_SEN is SSP1CON2_SEN

		var volatile bit SSPSTAT_SMP is SSP1STAT_SMP
		var volatile bit SSPSTAT_CKE is SSP1STAT_CKE
		var volatile bit SSPSTAT_D is SSP1STAT_D
		var volatile bit SSPSTAT_NA is SSP1STAT_NA
		var volatile bit SSPSTAT_P is SSP1STAT_P
		var volatile bit SSPSTAT_S is SSP1STAT_S
		var volatile bit SSPSTAT_R is SSP1STAT_R
		var volatile bit SSPSTAT_NW is SSP1STAT_NW
		var volatile bit SSPSTAT_UA is SSP1STAT_UA
		var volatile bit SSPSTAT_BF is SSP1STAT_BF

		var volatile bit SSPCON_WCOL is SSP1CON_WCOL
		var volatile bit SSPCON_SSPOV is SSP1CON_SSPOV
		var volatile bit SSPCON_SSPEN is SSP1CON_SSPEN
		var volatile bit SSPCON_CKP is SSP1CON_CKP
		var volatile bit*4 SSPCON_SSPM is SSP1CON_SSPM		
end if

-- --------------------------------------------------------------------
-- if the device has changed, change the speed if necessary
-- --------------------------------------------------------------------
procedure i2c_initialize() is

   -- One time initialize ---------------------------------------------
   -- i2c requires to set TRIS bits to input
   -- so to be sure ...
   i2c_scl_direction = input
   i2c_sda_direction = input

   sspcon  = 0b0010_1000   -- set up 16f87x as master device
   sspcon2 = 0b0010_0000   -- sets default acknowledge bit value
   -- -----------------------------------------------------------------

   -- set correct speed
   if    _i2c_bus_speed == 10 then sspadd = _i2c_1mhz
   elsif _i2c_bus_speed == 4  then sspadd = _i2c_400khz
   else                            sspadd = _i2c_100khz
   end if

   -- set correct level
   -- SMP-bit7 = 0, slew rate enabled, better for EMC
   if _i2c_level then
      sspstat = 0b_0000_0000   ;i2c bus levels, CKE=0
   else
      sspstat = 0b_0100_0000   ;SMbus levels, CKE=1
   end if
end procedure
-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- i2c_start - Sends Start bit and waits untill finished
-- -----------------------------------------------------------------------------
procedure i2c_start() is
   SSPCON2_SEN = high
   while SSPCON2_SEN == high loop end loop
end procedure
-- -----------------------------------------------------------------------------

-- -----------------------------------------------------------------------------
-- i2c_restart - Sends Restart bit and waits untill finished
-- -----------------------------------------------------------------------------
procedure i2c_restart() is
   SSPCON2_RSEN = high
   while SSPCON2_RSEN == high loop end loop
end procedure
-- -----------------------------------------------------------------------------

-- -----------------------------------------------------------------------------
-- i2c_stop - Sends Stop bit and waits until finished
-- -----------------------------------------------------------------------------
procedure i2c_stop() is
   SSPCON2_PEN = high
   while SSPCON2_PEN == high loop end loop
end procedure
-- -----------------------------------------------------------------------------

-- -----------------------------------------------------------------------------
-- i2c_transmit_byte -
-- -----------------------------------------------------------------------------
-- -----------------------------------------------------------------------------
function i2c_transmit_byte(byte in data) return bit is
   sspbuf = data

   -- wait untill write is finished
   PIR1_SSPIF = false
   ; delay_10us(10)
   while ! PIR1_SSPIF loop end loop

   -- get Acknowledge Status Bit _ACKSTAT
   -- wich indicates that the slave has responded (or not)
   -- if i2c device send an Aknowledge, then ready and OK
   if SSPCON2_ACKSTAT == low  then
      return true -- okay
   else
      return false -- no response
   end if
end function
-- -----------------------------------------------------------------------------

-- -----------------------------------------------------------------------------
-- i2c_receive_byte -
-- -----------------------------------------------------------------------------
-- start receiving of a byte and waits till finished
-- if param ACK is true, the byte is acknowledged and next bytes can be received.
-- if param ACK is false, the byte is nacked and a stop *should be* sent.
-- note: this behavior is inverted from the line level and orignal library, but
--       consistent with the i2c_software library.
-- -----------------------------------------------------------------------------
function i2c_receive_byte(bit in ACK ) return byte is
   var byte data
   -- start receive cyclus and wait till full byte received
   SSPCON2_RCEN = high
   ; delay_10us(10)
   while SSPSTAT_BF == low loop  end loop

   -- send Acknowledge (=low) if STOP=true=high
   -- and wait till finishd
   SSPCON2_ACKDT = ! ACK
   SSPCON2_ACKEN = high
   while SSPCON2_ACKEN == high loop end loop

   -- get read data
   data = sspbuf
   ;serial_hw_write(data)

   ;  if ACK == i2c_NACK then _i2c_stopbit end if
   return data
end function
-- -----------------------------------------------------------------------------





