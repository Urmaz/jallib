-- Title: Stopwatch library
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4l
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: Creates a stopwatch for timing events
--
-- Sources:
--

var bit stopwatch_error = FALSE -- error indicates if time > max stopwatch value

if STOPWATCH_VAR_SIZE > 2 then
   var byte*(STOPWATCH_VAR_SIZE - 2) _stopwatch_high_value
   var byte stopwatch_high_value[(STOPWATCH_VAR_SIZE - 2)] at _stopwatch_high_value
end if

var byte _stopwatch_timer_cycle_time -- min timer time (value/100 = time in usec)

if target_clock > 20_000_000 then
   const DEVIDER = 10
else
   const DEVIDER = 100
end if

--------------------------------------------------------------------------------
-- initialize the stopwatch
--------------------------------------------------------------------------------
procedure stopwatch_init() is
   -- init pic interrupt settings
   intcon_gie  = on    ; enables all unmasked interrupts
   intcon_peie = on    ; enables all unmasked peripheral interrupts

   -- timer3 setup
   t3con_tmr3cs = 0       -- use internal clock
   pie2_tmr3ie  = 1       -- enable the timer3 interrupt bit
   ;t3con_tmr3on = 1       -- enables timer
   pir2_tmr3if  = off     --

   -- set timer3 clock prescaler
   -- each increment slows clock by a multiple of 2
   t3con_t3ckps = 0 -- set prscal of 1:1

   -- calculate min time of one clock cycle (in .00 usec)
   const dword STOPWATCH_CALC_1 = target_clock / 10_000
   const dword STOPWATCH_CALC_2 = STOPWATCH_CALC_1 / 4
   _stopwatch_timer_cycle_time = byte((10_000) / STOPWATCH_CALC_2)

   -- increment the prescaler if < 1us
   while _stopwatch_timer_cycle_time < DEVIDER loop
      t3con_t3ckps = t3con_t3ckps + 1
      _stopwatch_timer_cycle_time = _stopwatch_timer_cycle_time * 2
   end loop
   
   TMR3 = 0
end procedure

--------------------------------------------------------------------------------
-- start the stopwatch at time = 0, reset stopwatch_error to FALSE
--------------------------------------------------------------------------------
procedure stopwatch_start() is
   pragma inline
   TMR3 = 0
   
   if STOPWATCH_VAR_SIZE > 2 then
      _stopwatch_high_value = 0
   end if

   stopwatch_error = FALSE -- clear error
   t3con_tmr3on = ON -- enables timer
end procedure

--------------------------------------------------------------------------------
-- continue running the stopwatch at it's current value
--------------------------------------------------------------------------------
procedure stopwatch_continue() is
   pragma inline
   t3con_tmr3on = ON -- enables timer
end procedure

--------------------------------------------------------------------------------
-- stop the stopwatch
--------------------------------------------------------------------------------
procedure stopwatch_stop() is
   pragma inline
   t3con_tmr3on = OFF -- disable timer
end procedure

--------------------------------------------------------------------------------
-- read the stopwatch. returns approximate
-- time in micro seconds.
--------------------------------------------------------------------------------
function stopwatch_read_time() return byte*STOPWATCH_VAR_SIZE is

   if STOPWATCH_VAR_SIZE == 2 then

      var word timer_time = TMR3
      timer_time = word( (dword(_stopwatch_timer_cycle_time) * timer_time) / 100 )
      return word(timer_time)
   else
      var dword timer_time
      var byte _timer_time[4] at timer_time

      -- get value of timer3
      timer_time = TMR3

      _timer_time[3] = stopwatch_high_value[1]
      _timer_time[2] = stopwatch_high_value[0]
      var byte _TMR3[2] at TMR3
      _timer_time[1] = _TMR3[1]
      _timer_time[0] = _TMR3[0]

      timer_time = (_stopwatch_timer_cycle_time * timer_time) / 100
      
      return dword(timer_time)
   end if
end function

--------------------------------------------------------------------------------
-- read the stopwatch (pseudo variable).
-- returns approximate time in micro seconds.
--------------------------------------------------------------------------------
function stopwatch'get() return byte*STOPWATCH_VAR_SIZE is
   pragma inline
   return stopwatch_read_time()
end function

--------------------------------------------------------------------------------
-- set the stopwatch's value in cycles
--------------------------------------------------------------------------------
;   procedure stopwatch_set_cycles(byte*STOPWATCH_VAR_SIZE in start_value) is
;      pragma inline
;
;      if STOPWATCH_VAR_SIZE <= 2 then
;         TMR3 = start_value
;      else
;         -- not active yet
;      end if
;   end procedure

--------------------------------------------------------------------------------
-- interrupt to increment stopwatch if hardware timer > 65535
--------------------------------------------------------------------------------
procedure stopwatch_isr() is
   pragma interrupt          -- interupt procedure

   if !PIR2_TMR3IF then      -- check if this is a timer3 interupt
      return                 -- exit interupt if it is not
   end if

   if STOPWATCH_VAR_SIZE > 2 then
      _stopwatch_high_value = _stopwatch_high_value + 1
      
      if _stopwatch_high_value == 0 then
         stopwatch_error = TRUE -- set error
      end if
   else
      stopwatch_error = TRUE -- set error
   end if

   PIR2_TMR3IF = off         -- clear overflow to start timer
end procedure

