-- Title: timer0 isr interval
-- Author: Joep Suijs, Copyright (C) 2008 Joep Suijs
-- Adapted-by: Rob Hamerling
-- Compiler: >=2.4j
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: Fixed interval isr with support for non-blocking delays.
--
-- TODO:
--

var word internal_isr_counter

var word isr_countdown[DELAY_SLOTS]
var byte timer0_load

function isr_counter'get() return word is
   var word temp

   INTCON_TMR0IE = off
   temp = internal_isr_counter
   INTCON_TMR0IE = on

   return temp
end function

procedure set_delay(byte in slot, word in ticks) is

   if (slot >= DELAY_SLOTS) then return end if

   INTCON_TMR0IE = off
   isr_countdown[slot] = ticks
   INTCON_TMR0IE = on

end procedure

function check_delay(byte in slot) return bit is

   if (slot >= DELAY_SLOTS) then return true end if

   if (isr_countdown[slot] == 0) then
      if (isr_countdown[slot] == 0) then
         -- note: double checking is done to cope with the isr
         -- decrementing from 0x100 to 0x0ff without disabling the isr.
         return true    -- delay passed
      end if
   end if

   return false -- still waiting

end function

procedure timer0_isr_init() is

   const dword timer0_div = (target_clock / 4 / timer0_isr_rate) - 1

   if (timer0_div > ((256 * 256) - 1)) then
      pragma error  -- requested ISR rate is too low

   elsif (timer0_div > ((128 * 256) - 1)) then
      OPTION_REG_PS = 7 ; prescaler 256
      timer0_load = 255 - timer0_div / 256

   elsif (timer0_div > ((64 * 256) - 1)) then
      OPTION_REG_PS = 6 ; prescaler 128
      timer0_load = 255 - timer0_div / 128

   elsif (timer0_div > ((32 * 256) - 1)) then
      OPTION_REG_PS = 5 ; prescaler 64
      timer0_load = 255 - byte(timer0_div / 64)

   elsif (timer0_div > ((16 * 256) - 1)) then
      OPTION_REG_PS = 4 ; prescaler 32
      timer0_load = 255 - byte(timer0_div / 32)

   elsif (timer0_div > ((8 * 256) - 1)) then
      OPTION_REG_PS = 3 ; prescaler 16
      timer0_load = 255 - byte(timer0_div / 16)

   elsif (timer0_div > ((4 * 256) - 1)) then
      OPTION_REG_PS = 2 ; prescaler 8
      timer0_load = 255 - byte(timer0_div / 8)

   elsif (timer0_div > ((2 * 256) - 1)) then
      OPTION_REG_PS = 1 ; prescaler 4
      timer0_load = 255 - byte(timer0_div / 4)

   else
      OPTION_REG_PS = 0 ; prescaler 2
      timer0_load = 255 - timer0_div / 2
   end if

   OPTION_REG_T0CS = 0  ; internal clock
   OPTION_REG_PSA  = 0  ; assign prescaler to timer0

   INTCON_TMR0IF = off
   INTCON_TMR0IE = on
   INTCON_GIE  = on    ; enable global interrupts
   INTCON_PEIE = on

   var byte i
   for DELAY_SLOTS using i loop
      isr_countdown[i] = 0
   end loop


end procedure

procedure ISR() is
   pragma interrupt

   if INTCON_TMR0IF == true then
      tmr0 = timer0_load

      -- counters
      internal_isr_counter = internal_isr_counter + 1

      var byte index
      for DELAY_SLOTS using index loop
         if (isr_countdown[index] != 0) then
            isr_countdown[index] = isr_countdown[index] - 1
         end if
      end loop

      INTCON_TMR0IF = off

   end if

end procedure
