-- Title: Legacy internal CAN controller
-- Author: William Welch Copyright (c) 2009, all rights reserved.
-- Compiler: 2.4
-- 
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: -- The early 18C/F family had an internal CAN controller that was
-- very similar to the MCP2515.  More recent devices have an ECAN controller which 
-- has many enhanced features, but defaults on power-up to a 'legacy' mode.
--
-- N.B. This library has only been tested so far with the 18F2585 device.

procedure can_reset() is
   ECANCON = 0 -- ECAN will operate in legacy CAN mode
   CANCON = 0x80 -- config mode
end procedure

-- set bit-rate and related can bus configuration.
-- see datasheet for details.
-- N.B. The chip must already be in 'configuration mode'.
procedure can_set_config(byte in p1, byte in p2, byte in p3) is
   BRGCON1 = p1
   BRGCON2 = p2
   BRGCON3 = p3
end procedure

-- set RX acceptance mask for buffer RXB0
-- N.B. calling with 0,0,0,0 will pass all messages
procedure can_set_rxb0_mask(byte in sidh, byte in sidl, byte in eidh, byte in eidl) is
   RXM0SIDH = sidh
   RXM0SIDL = sidl
   RXM0EIDH = eidh
   RXM0EIDL = eidl
end procedure

-- set RXB0 acceptance filter #0
procedure can_set_rxb0_filter0(byte in sidh, byte in sidl, byte in eidh, byte in eidl) is
   RXF0SIDH = sidh
   RXF0SIDL = sidl
   RXF0EIDH = eidh
   RXF0EIDL = eidl
end procedure

-- set RXB0 acceptance filter #1
procedure can_set_rxb0_filter1(byte in sidh, byte in sidl, byte in eidh, byte in eidl) is
   RXF1SIDH = sidh
   RXF1SIDL = sidl
   RXF1EIDH = eidh
   RXF1EIDL = eidl
end procedure

-- set RX acceptance mask for buffer RXB1
-- N.B. calling with 0,0,0,0 will pass all messages
procedure can_set_rxb1_mask(byte in sidh, byte in sidl, byte in eidh, byte in eidl) is
   RXM1SIDH = sidh
   RXM1SIDL = sidl
   RXM1EIDH = eidh
   RXM1EIDL = eidl
end procedure

-- set RXB1 acceptance filter #2
procedure can_set_rxb1_filter2(byte in sidh, byte in sidl, byte in eidh, byte in eidl) is
   RXF2SIDH = sidh
   RXF2SIDL = sidl
   RXF2EIDH = eidh
   RXF2EIDL = eidl
end procedure

-- set RXB1 acceptance filter #3
procedure can_set_rxb1_filter3(byte in sidh, byte in sidl, byte in eidh, byte in eidl) is
   RXF3SIDH = sidh
   RXF3SIDL = sidl
   RXF3EIDH = eidh
   RXF3EIDL = eidl
end procedure

-- set RXB1 acceptance filter #4
procedure can_set_rxb1_filter4(byte in sidh, byte in sidl, byte in eidh, byte in eidl) is
   RXF4SIDH = sidh
   RXF4SIDL = sidl
   RXF4EIDH = eidh
   RXF4EIDL = eidl
end procedure

-- set RXB1 acceptance filter #5
procedure can_set_rxb1_filter5(byte in sidh, byte in sidl, byte in eidh, byte in eidl) is
   RXF5SIDH = sidh
   RXF5SIDL = sidl
   RXF5EIDH = eidh
   RXF5EIDL = eidl
end procedure

-- send standard 11-bit CAN frame
-- Non-blocking -- function returns immediately if buffer is busy (in-use)
-- FIXME. this is ugly code
function can_send(byte in buf_no, word in std_id, byte in buf[8], byte in len) return bit is
   var bit stat
   var byte r_base, i, v
   var word sidh, sidl
   
   if buf_no == 0 then
      r_base = 0x40
   elsif buf_no == 1 then
      r_base = 0x30
   elsif buf_no == 2 then
      r_base = 0x20
   else
      return 0
   end if
   
   FSR1L = r_base
   FSR1H = 0x0F
   
   -- buffer already in-use / busy?
   v = INDF1
   stat = v & 8
   if stat == 1 then
      return 0
   end if
   
   -- FIXME this sets priority and other side-effects
   POSTINC1 = 0
   
   -- N.B. SIDH and SIDL bit-layout are weird (see datasheet)
   sidh = std_id >> 3
   sidl = std_id & 7
   sidl = sidl << 5
   
   POSTINC1 = byte(sidh)
   POSTINC1 = byte(sidl)
   POSTINC1 = 0
   POSTINC1 = 0
   POSTINC1 = len
   for 8 using i loop
      POSTINC1 = buf[i]
   end loop
   
   FSR1L = r_base
   INDF1 = 8  -- request TX now/soonest
   
   return 1
end function

-- receive standard 11-bit CAN frame
-- Non-blocking -- function returns immediately if no message is available.
-- FIXME. N. B. This routine will automatically discard any extended frames!
-- FIXME. this is ugly code
function can_receive(byte in buf_no, word out std_id, byte out buf[8], byte out len) return bit is
   var bit rtr, ide, stat, ex
   var byte r_base, i, v
   var byte sidh, sidl
   
   if buf_no == 0 then
      r_base = 0x60
   elsif buf_no == 1 then
      r_base = 0x50
   else
      return 0 -- illegal value for buf_no
   end if
   
   FSR1L = r_base
   FSR1H = 0x0F
   
   -- message waiting?
   v = POSTINC1
   stat = v & 0x80
   if stat == 0 then
      return 0
   end if
   
   -- N.B. At this point we have a message. We must read it,
   -- even if we decide to discard it later.
   
   rtr = v & 8
   sidh = POSTINC1
   sidl = POSTINC1
   v = POSTINC1  -- skip EIDH
   v = POSTINC1  -- skip EIDL
   len = POSTINC1
   
   for 8 using i loop
      buf[i] = POSTINC1
   end loop
   
   -- FIXME, side-effects to writing all bits of RXBnCON register
   FSR1L = r_base
   INDF1 = 0
   
   -- Remote Request frames do not include any data
   if rtr != 0 then
      len = 0
   end if
   
   -- discard 'extended frames'
   -- FIXME
   ide = sidl & 8
   if ide != 0 then
      return 0
   end if
   
   -- form the 11-bit ID. See datasheet.
   std_id = word(sidh)
   std_id = std_id << 3
   sidl = sidl >> 5
   std_id = std_id | word(sidl)
   
   return 1
end function

