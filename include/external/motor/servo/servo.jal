-- Title: servo control library
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4m
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: This library moves a servo such as a servo used in radio control (RC)
--
-- Sources:
-- http://www.horrorseek.com/home/halloween/wolfstone/Motors/svoint_RCServos.html
--
-- usage notes:
-- 1. Set your SERVO_MIN values to restrict movement.
--    This step must be completed correctly. First use code as follows
--    directly after you call servo_init()
--
--    servo_move(0,1)
--    forever loop
--    end loop
--
--    Now run your circuit and gradually change SERVO_MIN value so the servo
--    is at the correct location on one side. Try to get the servo to be
--    1mm from it's min location.
-- 2. Repeate step 1 with SERVO_MAX but use this:
--
--    servo_move(255,1)
--    forever loop
--    end loop
--
-- other notes:
-- This lib uses timer0
-- Up to 8 servos are supported, more servos = more processing power needed.
--

var byte servo_steps_per_2_5_msec -- holds number of steps within 2.5ms

-- library variables, internal use only
var byte servo_on = 0xFF             -- All servo's on by default
var bit servo_1_on at servo_on : 0
var bit servo_2_on at servo_on : 1
var bit servo_3_on at servo_on : 2
var bit servo_4_on at servo_on : 3
var bit servo_5_on at servo_on : 4
var bit servo_6_on at servo_on : 5
var bit servo_7_on at servo_on : 6
var bit servo_8_on at servo_on : 7

var byte _servo_pulse[8]
var byte _servo_low[8]

-- calculate difference between min & max
const byte _SERVO_CALC_DIFF = SERVO_MAX - SERVO_MIN

var byte _servo_isr_count = 0    -- ISR steps (high level, low level)
var byte _servo_number_count = 0 -- ISR servo control count 0 to 7

--------------------------------------------------------------------------------
-- Sets servo level high or low. Servo numbers 0 to 7
--------------------------------------------------------------------------------
procedure _servo_set_level(byte in servo_num, bit in level) is
   pragma inline
   
   if servo_num == 0 then
      servo_1 = level
   end if

   if defined(servo_2) == TRUE then
      if servo_num == 1 & servo_1_on then
         servo_2 = level
      end if
   end if

   if defined(servo_3) == TRUE then
      if servo_num == 2 & servo_2_on then
         servo_3 = level
      end if
   end if

   if defined(servo_4) == TRUE then
      if servo_num == 3 & servo_3_on then
         servo_4 = level
      end if
   end if

   if defined(servo_5) == TRUE then
      if servo_num == 4 & servo_4_on then
         servo_5 = level
      end if
   end if

   if defined(servo_6) == TRUE then
      if servo_num == 5 & servo_5_on then
         servo_6 = level
      end if
   end if

   if defined(servo_7) == TRUE then
      if servo_num == 6 & servo_6_on then
         servo_7 = level
      end if
   end if

   if defined(servo_8) == TRUE then
      if servo_num == 7 & servo_7_on then
         servo_8 = level
      end if
   end if

end procedure

--------------------------------------------------------------------------------
-- Interupt procedure to pulse servo
--------------------------------------------------------------------------------

procedure _servo_isr() is
   pragma interrupt

   if _servo_isr_count == 0 then                     -- do pulse high width
      INTCON_TMR0IF = off                           -- reset counter
      tmr0 = _servo_pulse[_servo_number_count]       -- set timer to pulse high width
      _servo_set_level (_servo_number_count,HIGH)    -- set level to high
      _servo_isr_count = _servo_isr_count + 1         -- go to next step
   elsif _servo_isr_count == 1 then                  -- finnish pulse low
      INTCON_TMR0IF = off                           -- reset counter
      tmr0 = _servo_low[_servo_number_count]
      _servo_set_level (_servo_number_count,LOW)     -- set level to low
      _servo_isr_count = _servo_isr_count + 1         -- go to next step
      _servo_number_count = _servo_number_count + 1   -- change to next servo
      if _servo_number_count == 8 then               -- change to first servo if needed
         _servo_number_count = 0
      end if
      _servo_isr_count = 0                           -- go to first step
   end if
end procedure

--------------------------------------------------------------------------------
-- Move a servo to any value from 0 to 255
--------------------------------------------------------------------------------
procedure servo_move(word in value, byte in servo_number) is
   var dword calc1, calc2
   var dword final
   var byte final2

   ;calculate the pulse length
   calc1 = (value * _SERVO_CALC_DIFF)
   ;calc2 = calc1 / servo_steps_per_2_5_msec
   calc2 = calc1 / 255
   final = calc2 + servo_min

  -- change final into a byte
  var byte  val[2] at final
  final2 = val[0]
  
  if SERVO_CLOCK_BITS == 8 then
        ;calculate the pulse length
      calc1 = (final2 * servo_steps_per_2_5_msec)
      ;calc2 = calc1 / servo_steps_per_2_5_msec
      final = calc1 / 255

     -- change final into a byte
     var byte  val2[2] at final
     final2 = val2[0]
  else
     pragma error -- 16 bit timers are not supported yet
  end if

  if servo_number == 1 then
     _servo_pulse[0] = (255 - final2) -- move servo 1 by pulse length
     _servo_low[0] = (255 - _servo_pulse[0]) + (255 - servo_steps_per_2_5_msec)
  elsif servo_number == 2 then
     _servo_pulse[1] = (255 - final2) -- move servo 2 by pulse length
     _servo_low[1] = (255 - _servo_pulse[1]) + (255 - servo_steps_per_2_5_msec)
  elsif servo_number == 3 then
     _servo_pulse[2] = (255 - final2) -- move servo 2 by pulse length
     _servo_low[2] = (255 - _servo_pulse[2]) + (255 - servo_steps_per_2_5_msec)
  elsif servo_number == 4 then
     _servo_pulse[3] = (255 - final2) -- move servo 2 by pulse length
     _servo_low[3] = (255 - _servo_pulse[3]) + (255 - servo_steps_per_2_5_msec)
  elsif servo_number == 5 then
     _servo_pulse[4] = (255 - final2) -- move servo 2 by pulse length
     _servo_low[4] = (255 - _servo_pulse[4]) + (255 - servo_steps_per_2_5_msec)
  elsif servo_number == 6 then
     _servo_pulse[5] = (255 - final2) -- move servo 2 by pulse length
     _servo_low[5] = (255 - _servo_pulse[5]) + (255 - servo_steps_per_2_5_msec)
  elsif servo_number == 7 then
     _servo_pulse[6] = (255 - final2) -- move servo 2 by pulse length
     _servo_low[6] = (255 - _servo_pulse[6]) + (255 - servo_steps_per_2_5_msec)
  elsif servo_number == 8 then
     _servo_pulse[7] = (255 - final2) -- move servo 2 by pulse length
     _servo_low[7] = (255 - _servo_pulse[7]) + (255 - servo_steps_per_2_5_msec)
  end if
end procedure

--------------------------------------------------------------------------------
-- Initialize  the servo
--------------------------------------------------------------------------------
procedure servo_init() is
   -- prescaler value - measured timer step widths on 20mhz
   -- 6               - 25.6 us
   -- 5               - 12.8 us
   -- 4               - 6.4 us
   -- 3               - 3.2 us
   -- 2               - 1.6 us
   -- 1               - 0.8 us

   OPTION_REG_T0CS = 0  ; internal clock
   OPTION_REG_PSA  = 0  ; assign prescaler to timer0

   INTCON_TMR0IF = off  ; start the setting
   INTCON_TMR0IE = on
   INTCON_GIE  = on    ; enable global interrupts
   INTCON_PEIE = on

   -- calculate number of steps available within 2.5ms

   -- On 20mhz clock, this is the measured timer step
   -- size (8us), then do 1/8us = 125000
   const dword SERVO_TIMER_DIFF = 125000
   --
   const dword SERVO_CALC_1 = target_clock * 100                   -- lower number
   const dword SERVO_CALC_2 = SERVO_CALC_1 / 20_000_000    -- compaire to 20mhz
   const dword SERVO_CALC_3 = SERVO_CALC_2 * SERVO_TIMER_DIFF
   const dword SERVO_CALC_4 = SERVO_CALC_3 / 100            -- higher number
   const dword SERVO_STEP_US_X_1000 = 1_000_000_000 / SERVO_CALC_4
   --
   var dword servo_steps = 25000000 / SERVO_STEP_US_X_1000

   -- change prescaler if using 8-bit timer
   var byte servo_prescaler = 1
   if SERVO_CLOCK_BITS == 8 then
      forever loop
         if servo_steps > 255 then
            servo_prescaler = servo_prescaler + 1
            servo_steps = servo_steps / 2
         else
            exit loop
         end if
      end loop
   else
      pragma error -- 16 bit timers are not supported yet
   end if

   option_reg_ps = servo_prescaler
   -- servo_steps is now calculated

   if SERVO_CLOCK_BITS == 8 then
      var byte value[1] at servo_steps
      servo_steps_per_2_5_msec = value[0]
   else
      pragma error -- 16 bit timers are not supported yet
   end if
end procedure
