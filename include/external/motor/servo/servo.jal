-- Title: servo control library
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4m
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: This library moves a servo such as a servo used in radio control (RC)
--
-- Sources:
-- http://www.horrorseek.com/home/halloween/wolfstone/Motors/svoint_RCServos.html
--
-- usage notes:
-- 1. Set your movement resolution:
--    pulse/movement resolution in increments of 10us (servo_isr speed)
--    lowest possible value is 10
--    low value requires processing power
-- 2. Set your SERVO_MIN values to restrict movement.
--    This step must be completed correctly. First use code as follows
--    directly after you call servo_init()
--
--    servo_move(0,1)
--    forever loop
--    end loop
--
--    Now run your circuit and gradually change SERVO_MIN value so the servo
--    is at the correct location on one side. Try to get the servo to be
--    1mm from it's min location.
-- 3. Repeate step 2 with SERVO_MAX but use this:
--
--    servo_move(255,1)
--    forever loop
--    end loop
--
-- other notes:
-- This lib uses timer0
-- Up to 8 servos are supported, more servos = more processing power needed.
-- you must change SERVO_MIN/SERVO_MAX values each time you change the number
-- of servo's or pulse resolution.
--
-- here are some examples from my servo:
--
-- SERVO_RESOLUTION = 10
-- SERVO_MIN  - 1 servo 80, 8 servos 190
-- SERVO_MAX  - 1 servo 235, 8 servos 235
--
-- SERVO_RESOLUTION = 20
-- SERVO_MIN  - 1 servo 125
-- SERVO_MAX   - 1 servo 220
--
-- todo:
-- test other clock speeds, prescaler must be changed according to clock speed
--

-- library variables, internal use only
var byte _servo_count_1 = 0
var byte _servo_pulse_1
var byte _servo_count_2 = 0
var byte _servo_pulse_2
var byte _servo_count_3 = 0
var byte _servo_pulse_3
var byte _servo_count_4 = 0
var byte _servo_pulse_4
var byte _servo_count_5 = 0
var byte _servo_pulse_5
var byte _servo_count_6 = 0
var byte _servo_pulse_6
var byte _servo_count_7 = 0
var byte _servo_pulse_7
var byte _servo_count_8 = 0
var byte _servo_pulse_8

-- calculate difference between min & max
const byte _SERVO_CALC_DIFF = SERVO_MAX - SERVO_MIN

--------------------------------------------------------------------------------
-- Interupt procedure to pulse servo
--------------------------------------------------------------------------------
procedure _servo_isr() is
   pragma interrupt


   _servo_count_1 = _servo_count_1 + 1        ;increment pulse count
   if _servo_count_1 <= _servo_pulse_1 then   ;create pulse
      servo_1 = high
   elsif _servo_count_1 > _servo_pulse_1 then ;end pluse
      servo_1 = low
   end if

   if SERVO_AMOUNT >= 2 then
      _servo_count_2 = _servo_count_2 + 1        ;increment pulse count
      if _servo_count_2 <= _servo_pulse_2 then   ;create pulse
         servo_2 = high
      elsif _servo_count_2 > _servo_pulse_2 then ;end pluse
         servo_2 = low
      end if
   end if
   
   if SERVO_AMOUNT >= 3 then
      _servo_count_3 = _servo_count_3 + 1        ;increment pulse count
      if _servo_count_3 <= _servo_pulse_3 then   ;create pulse
         servo_3 = high
      elsif _servo_count_3 > _servo_pulse_3 then ;end pluse
         servo_3 = low
      end if
   end if

   if SERVO_AMOUNT >= 4 then
      _servo_count_4 = _servo_count_4 + 1        ;increment pulse count
      if _servo_count_4 <= _servo_pulse_4 then   ;create pulse
         servo_4 = high
      elsif _servo_count_4 > _servo_pulse_4 then ;end pluse
         servo_4 = low
      end if
   end if

   if SERVO_AMOUNT >= 5 then
      _servo_count_5 = _servo_count_5 + 1        ;increment pulse count
      if _servo_count_5 <= _servo_pulse_5 then   ;create pulse
         servo_5 = high
      elsif _servo_count_5 > _servo_pulse_5 then ;end pluse
         servo_5 = low
      end if
   end if

   if SERVO_AMOUNT >= 6 then
      _servo_count_6 = _servo_count_6 + 1        ;increment pulse count
      if _servo_count_6 <= _servo_pulse_6 then   ;create pulse
         servo_6 = high
      elsif _servo_count_6 > _servo_pulse_6 then ;end pluse
         servo_6 = low
      end if
   end if

   if SERVO_AMOUNT >= 7 then
      _servo_count_7 = _servo_count_7 + 1        ;increment pulse count
      if _servo_count_7 <= _servo_pulse_7 then   ;create pulse
         servo_7 = high
      elsif _servo_count_7 > _servo_pulse_7 then ;end pluse
         servo_7 = low
      end if
   end if

   if SERVO_AMOUNT >= 8 then
      _servo_count_8 = _servo_count_8 + 1        ;increment pulse count
      if _servo_count_8 <= _servo_pulse_8 then   ;create pulse
         servo_8 = high
      elsif _servo_count_8 > _servo_pulse_8 then ;end pluse
         servo_8 = low
      end if
   end if

   if INTCON_TMR0IF == true then
      tmr0 = (255 - (SERVO_RESOLUTION / 10)) + 1           ;set timing
      INTCON_TMR0IF = off  ;reset counter
   end if

end procedure

--------------------------------------------------------------------------------
-- Move a servo to any value from 0 to 255
--------------------------------------------------------------------------------
procedure servo_move(word in value, byte in servo_number) is
   var word calc1, calc2
   var word final
   var byte final2

   ;calculate the pulse length
   calc1 = (value * _SERVO_CALC_DIFF)
   calc2 = calc1 / 255
   final = calc2 + servo_min

  -- change final into a byte
  var byte  val[2] at final
  final2 = val[0]

  if servo_number == 1 then
     _servo_pulse_1 = (255 - final2) -- move servo 1 by pulse length
  elsif servo_number == 2 then
     _servo_pulse_2 = (255 - final2) -- move servo 2 by pulse length
  elsif servo_number == 3 then
     _servo_pulse_3 = (255 - final2) -- move servo 2 by pulse length
  elsif servo_number == 4 then
     _servo_pulse_4 = (255 - final2) -- move servo 2 by pulse length
  elsif servo_number == 5 then
     _servo_pulse_5 = (255 - final2) -- move servo 2 by pulse length
  elsif servo_number == 6 then
     _servo_pulse_6 = (255 - final2) -- move servo 2 by pulse length
  elsif servo_number == 7 then
     _servo_pulse_7 = (255 - final2) -- move servo 2 by pulse length
  elsif servo_number == 8 then
     _servo_pulse_8 = (255 - final2) -- move servo 2 by pulse length
  end if
end procedure

--------------------------------------------------------------------------------
-- Initialize  the servo
--------------------------------------------------------------------------------
procedure servo_init() is
   OPTION_REG_PS = 4 ; prescaler
      
   OPTION_REG_T0CS = 0  ; internal clock
   OPTION_REG_PSA  = 0  ; assign prescaler to timer0

   INTCON_TMR0IF = off
   INTCON_TMR0IE = on
   INTCON_GIE  = on    ; enable global interrupts
   INTCON_PEIE = on
end procedure
