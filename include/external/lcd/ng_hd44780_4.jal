-- -----------------------------------------------------------------------------
-- Title: LCD library for HD44780 compatible LCDs, with 4 bits wide datatransfer
-- Author: Rob Hamerling, Copyright (c) 2008..2009, all rights reserved.
-- Adapted-by: Eur van Andel, Joep Suijs (refactoring)
-- Compiler:  >=2.4g
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Sources:
--
-- Description:
--    Simple interface for HD44780 compatible alphanumeric LCD screens.
--    Screens can range from 2x8  (2 lines, 8 chars) to 4x20.
--    Uses 4 bit wide datapath + 2 handshake lines (total 6 PIC pins).
--    Expects: - 2 pins for handshake: 'lcd_rs' and 'lcd_en'
--             - 1 port nibble for data: 'lcd_dataport'
--    *
--    Directions for use of this library in application programs
--    (in this sequence):
--    1. Declare the following constants:
--          const byte LCD_ROWS     = 2              -- 1, 2 or 4 lines
--          const byte LCD_CHARS    = 16             -- 8, 16 or 20 chars per line
--       and variables (aliases):
--          var   byte lcd_dataport  is  portA_low   -- 4 data pins
--          var   bit  lcd_en        is  pin_A4      -- trigger
--          var   bit  lcd_rs        is  pin_A5      -- cmd/data select
--
--
-- ------------- place this below, in your MAIN file and add to    ---------
-- ------------- the pins which are not used the variable:         ---------
-- ------------- "not_connected" and change the other pins         ---------
-- ------------- according to your hardware.                       ---------
-- ------------- also remove the "--"                              ---------
--
-- var volatile bit lcd_rs is pin_e0   -- data/command select
-- var volatile bit lcd_rw is pin_e1   -- read/write select
-- var volatile bit lcd_en is pin_e2   -- clock the data
--
-- var volatile bit lcd_d4 is pin_d4
-- var volatile bit lcd_d5 is pin_d5
-- var volatile bit lcd_d6 is pin_d6
-- var volatile bit lcd_d7 is pin_d7
--
--
-- include lcd_hd44780_rz
--
-- --------------------------------------------------------------------------
-- --------------------------------------------------------------------------
--
--
--    2. Include this library.
--    and somewhere before actually using the lcd:
--    3. Set the chosen LCD dataport and handshake pins to output:
--          portA_low_direction = all_output
--          pin_A4_direction    = output
--          pin_A5_direction    = output
--    4. Call lcd_init() to initialize the lcd controller.
--    Above is an example for a 2x16 LCD:
--      Bits 0..3 of portA are used for data, pins 4 and 5 of portA are
--      used for handshake. Any other available nibble and handshake pins
--      could be used (provided these are configurable for output).
--    *
--
-- ;; ;; JS: check where we put this info - actually, this file is only the
-- ;; ;; driver and 
-- ;;   Available functions for application programs:
-- ;;     lcd_init()                             initialize the LCD controller
-- ;;     lcd_clearscreen()                      clear screen, cursor home
-- ;;     lcd_setcursor(<row>,<column>)          where to write next character
-- ;;     lcd_writechar(<byte>)                  write single character
-- ;;                                            at cursor position and
-- ;;                                            shift cursor position 1 right
-- ;;   *
-- ;;   A pseudo byte variable 'lcd' is declared as alternative for lcd_writechar(<byte>)
-- ;;   So in stead of: lcd_writechar(<byte>)
-- ;;   you may use:    lcd = <byte>
-- ;;   And you may also use 'lcd' as destination in functions of other
-- ;;   libraries, like print().
--
--
-- Dependencies: delay.jal
--
-- -----------------------------------------------------------------------------
--

include delay

-- ----------------------------------------------------------------------------
-- sends low nibble from value to the LCD
-- can be used for both commands and data
-- (requires no wait cycli inbetween upper and lower nibble)
-- (this routine is only used inside this file)
-- ----------------------------------------------------------------------------
procedure __lcd_write_nibble( byte in value ) is       
   ;pragma inline
      
   if (defined(lcd_dataport) == true) then
      -- write nibble at once
         lcd_dataport = value                   -- replace low nibble
   else   
      -- write nibble bit by bit
     var bit bit0 at value : 0
     var bit bit1 at value : 1
     var bit bit2 at value : 2
     var bit bit3 at value : 3
   
     -- setup databits
     lcd_d4 = bit0
     lcd_d5 = bit1
     lcd_d6 = bit2
     lcd_d7 = bit3
   end if

   -- generate clockpuls
   lcd_en = HIGH                                -- trigger on
   asm nop                                      -- delay (> 400 ns)
   lcd_en = LOW                                 -- trigger off
   
end procedure
-- ----------------------------------------------------------------------------


-- ----------------------------------------------------------------------------
-- sends byte from value to register of the LCD
-- (this procedure is only used inside this file)
--
-- ----------------------------------------------------------------------------
procedure __lcd_write( byte in value ) is
   __lcd_write_nibble(value >> 4)               -- write high nibble
   __lcd_write_nibble(value)                    -- write low nibble
   delay_10us(4)                                -- > 37 us
end procedure
-- ----------------------------------------------------------------------------


-- ----------------------------------------------------------------------------
-- sends data byte in value to LCD
-- for slow commands an extra delay should be added
--
-- ----------------------------------------------------------------------------
procedure _lcd_write_data(byte in value) is
   lcd_rs = high                                -- select instruction
   __lcd_write( value )                         -- output byte
end procedure
-- ----------------------------------------------------------------------------


-- ----------------------------------------------------------------------------
-- sends command byte in value to LCD
-- for slow commands an extra delay should be added
--
-- ----------------------------------------------------------------------------
procedure _lcd_write_command(byte in value) is
;   pragma inline
   lcd_rs = low                              -- select instruction
   __lcd_write( value )                      -- output byte
end procedure
-- ----------------------------------------------------------------------------


-- now we defined the interface, add the API
include lcd_hd44780_common

-- ----------------------------------------------------------------------------
-- ----------------------------------------------------------------------------
-- ----------------------------------------------------------------------------
procedure lcd_init() is            
   
   -- first, init the interface
   lcd_rs = LOW                                 -- set to control char mode
   delay_1ms(25)                                -- power-up delay (> 15 ms)
   __lcd_write_nibble(0b0000_0011)                -- function set
   delay_1ms(5)                                 -- > 4.1 milliseconds
   __lcd_write_nibble(0b0000_0011)                -- function set
   delay_10us(10)                               -- > 100 æs
   __lcd_write_nibble(0b0000_0011)                -- function set
   delay_10us(4)                                -- > 37 æs
   __lcd_write_nibble(0b0000_0010)                -- to 4-bit mode
   delay_10us(4)                                -- > 37 æs            

    -- init the API
    _hd44780_init()
end procedure