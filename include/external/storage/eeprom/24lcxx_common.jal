-- ------------------------------------------------------
-- Title: Eeprom 24lc* common code
--
-- Author: Joep Suijs, Copyright (c) 2008..2012, all rights reserved.
--
-- Adapted-by: 
--
-- Compiler: >=2.4m
-- Revision: $Revision$
--
-- This file is part of jallib  (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: 24lc* enhanced library common code
--     
-- Features:
-- * read & write of multiple i2c eeprom types
-- * functions report succes/fail back to user
-- * writes are cached when possible to enhance performance.
-- * cache is flushed when required:
--   - write at non-sequential address 
--   - buffer is full 
--   - page boundery is passed
-- * manual cache-flush funtion ee_24lcxx_flush()
-- * write cycle of eeprom is handled automaticly without unnecessary delay
-- * ee_24lcxx_read_next funtion for efficient sequential dataread.
--   note: limited to current datablock (relevant for 24lc16 & 24lc1025 only)
--
-- Sources: Microchip datasheet for supported devices:
--
--    24lc16       size 2kx8
--                 page size 16 bytes
--                 adressing 3 bit + 1 byte
--    
--    24lc32/64    size 4kx8/8kx8
--                 page size 32 bytes
--                 adressing 0 bit + 2 byte
--    
--    24lc256      size 32kx8
--                 page size 64 bytes
--                 adressing 0 bit + 2 byte
--    
--    24lc512      size 64kx8
--                 page size 128 bytes
--                 adressing 0 bit + 2 byte
--    
--    24lc1025     size 128kx8
--                 page size 128 bytes
--                 adressing 1 bit + 2 byte
--    
-- Notes: 
--
-- -------------------------------------------------------- ----------------------------------------------------------------------------
include delay
var byte _last_chip_address -- cache address for read_next

-- default
if (defined(eeprom_i2c_address) == false) then                
   const eeprom_i2c_address = 0xA0
end if


var bit _24lc_flush = false  
var sdword  eeprom_address_pointer = -1
var byte    eeprom_buffer_index

var byte eeprom_buffer[eeprom_buffer_size]

; compile-time validation of eeprom type
if (defined(eeprom_no_type_check)==false) then      
   case (eeprom_24lc_type) of
      16    : block end block
      32    : block end block
      64    : block end block
      256   : block end block
      512   : block end block
      1025  : block end block   
      otherwise block         
         _error"unsupported type of i2c eeprom (eeprom_24lc)"
      end block
   end case
end if

-- ----------------------------------------------------------------------------
-- _ee_24lcxx_chip_address - calculate chip-address of eeprom
-- ----------------------------------------------------------------------------
-- return: calculated address
-- ----------------------------------------------------------------------------
function _get_24lcxx_chip_address(dword in mem_address) return byte is
   var bit ack_ok
   var byte i2c_addr_byte

   ;------------------------
   ; device address handling
      i2c_addr_byte = eeprom_i2c_address & 0xFE

   ; adjust address byte to address appropriate block   
   case (eeprom_24lc_type) of
     
      16 : block     ; 24lc16 addressing
         ; upper 3 bits of data_address are part of device addressing
         i2c_addr_byte = (i2c_addr_byte & 0xF0) + byte(0x07 & (mem_address / 256)) 
      end block

      32 : block end block     ; (no associated code generated by empty case/of)

      64 : block end block

      256 : block end block

      512 : block end block

      1025 : block   ; 24lc1025 addressing
         ; one bit of data_address is part of device addressing 
         i2c_addr_byte = i2c_addr_byte & 0xF6 
         if (mem_address > 0xFFFF) then
            i2c_addr_byte = i2c_addr_byte | 0x08
         end if
      end block   

      otherwise block 
      end block
      
   end case

   _last_chip_address = i2c_addr_byte
   return i2c_addr_byte
end function

-- ----------------------------------------------------------------------------
-- _ee_24lcxx_mem_address - send mem-address to eeprom
-- ---------------------------------------------------------------------------- 
-- return: true if succes.
-- ----------------------------------------------------------------------------
function _ee_24lcxx_mem_address(dword in mem_address) return bit is
   var bit ack_ok = true

   ; ----------------------------------------   
   ; data address handling (one or two bytes)
   if (eeprom_24lc_type > 16) then
      ack_ok = ack_ok & i2c_transmit_byte(byte(mem_address / 256))    -- send high address byte if relevant
   end if
   
   ack_ok = ack_ok & i2c_transmit_byte(byte(mem_address))       -- send low address byte
   
   return ack_ok
end function

-- ----------------------------------------------------------------------------
-- ee_24lcxx_write - write a byte to the eeprom
-- ----------------------------------------------------------------------------    
-- return: true if succes.                                                       
-- ----------------------------------------------------------------------------
function ee_24lcxx_write(dword in mem_address, byte in data) return bit is
   var bit data_stored =  false
   var bit ack_ok = true
   var byte temp, i
                                   
   -- ------------------------------                                
   -- add byte to buffer if possible
   if (_24lc_flush == false) then
      ; add data to the buffer
      if (eeprom_address_pointer == -1) then
         ; buffer empty, so place in buffer
         eeprom_address_pointer = sdword(mem_address)
         eeprom_buffer[0] = data
         eeprom_buffer_index = 1
         data_stored = true
         
      elsif (mem_address == (eeprom_address_pointer + eeprom_buffer_index)) then
         
         ; next byte, so place in buffer
         eeprom_buffer[eeprom_buffer_index] = data                          
         eeprom_buffer_index = eeprom_buffer_index + 1      
         data_stored = true
         
      end if
   end if

   -- ------------------------------------------                                             
   -- write current buffer to eeprom if required
   if ((data_stored == false) |  ; this test implicit includes _24lc_flush=true and _24lc_flush=true implies data is present
       (eeprom_buffer_index >= eeprom_buffer_size) |  
       (((eeprom_address_pointer + eeprom_buffer_index) & eeprom_24lc_page_mask) != (eeprom_address_pointer & eeprom_24lc_page_mask))) then
         
      ; write data    
      var byte chip_addr = _get_24lcxx_chip_address(word(eeprom_address_pointer))
      for 80 loop
         i2c_start()                              -- send start bit       
         ack_ok = i2c_transmit_byte(chip_addr)
         if (ack_ok) then exit loop end if
         
         -- eeprom is probably busy, so wait a bit and
         -- try again, up to 8 ms (80 * 100us).   
         i2c_stop
         delay_10us(10)
;         serial_hw_data = "."
      end loop   

;      if (ack_ok == false) then serial_hw_data = "^" return false end if

      ack_ok = ack_ok & _ee_24lcxx_mem_address(word(eeprom_address_pointer))
;      if (ack_ok == false) then serial_hw_data = "$" return false end if
      
      for eeprom_buffer_index using i loop                  
         ack_ok = ack_ok & i2c_transmit_byte(eeprom_buffer[i])  -- transmit data & wait for ack
;         if (ack_ok == false) then serial_hw_data = "^" return false end if
      end loop
      i2c_stop()                                               -- send stop bit
                   
      ; write done, update administration                                   
      eeprom_address_pointer = -1 ; buffer empty      
   end if
                                            
   -- --------------------------------------                                            
   -- store byte if it was not stored before
   if ((data_stored == false) & (_24lc_flush == false)) then ; (dont store flush mode)
      ; here, the buffer is always clear, so it is safe to assume we have to store at beginning
      eeprom_address_pointer = sdword(mem_address)
      eeprom_buffer[0] = data
      eeprom_buffer_index = 1
   end if

   return ack_ok   
end function


-- ----------------------------------------------------------------------------
-- ee_24lcxx_flush - flush any data stored in buffer
-- ----------------------------------------------------------------------------
-- Data is stored in a buffer to allow more efficient write (page write).
-- This function forces all buffered data to be written to the target, in 
-- other words: it executes all delayed writes.
-- ----------------------------------------------------------------------------
function ee_24lcxx_flush() return bit is
   var bit ack_ok;   
   
   if(eeprom_address_pointer == -1) then return true end if ; nothing to flush
   
   _24lc_flush = true ; signal flush (do not add dummy byte to buffer)

   ack_ok = ee_24lcxx_write(0, 0)      

   _24lc_flush = false ; disable flush for future calls to ee_24lcxx_write().

   return ack_ok;   
end function    


-- ---------------------------------------------------------------------------
-- ee_24lcxx_read - Read data from eeprom at input address
-- ---------------------------------------------------------------------------- 
-- return: true if succes.
-- ----------------------------------------------------------------------------
function ee_24lcxx_read(dword in mem_address, byte out data) return bit is
   var bit ack_ok

   ; flush buffer to prevent readback of old data
   ack_ok = ee_24lcxx_flush()

   var byte chip_addr = _get_24lcxx_chip_address(word(mem_address))

   if (ack_ok) then
      
      for 80 loop
         i2c_start()                              -- send start bit       
         ack_ok = i2c_transmit_byte(chip_addr)
         if (ack_ok) then exit loop end if
            
         -- eeprom is probably busy, so wait a bit and
         -- try again, up to 8 ms (80 * 100us).   
         i2c_stop
         delay_10us(10)  
;         serial_hw_data = "."
      end loop   
   end if
      
   ack_ok = ack_ok & _ee_24lcxx_mem_address(mem_address)
   
   i2c_restart()                                    -- send start bit
   ack_ok = ack_ok & i2c_transmit_byte(chip_addr | 1) -- read mode 
   data = i2c_receive_byte(0)                     -- nack (no ack)
   i2c_stop()                                     -- send stop bit
   
   return ack_ok
end function


-- ----------------------------------------------------------------------------
-- ee_24lcxx_read_next- Read data from eeprom at next address
-- ----------------------------------------------------------------------------
-- return: true if succes.   
--         'data' contains received byte 
--
-- Note: this read is limited to a 'block'     
-- - address wrap at 64k for 24lc1025            
-- - address wrap at 256bytes for 24lc15
-- - no limitation for 24lc32, 64, 256, 512.
-- See Microchip datasheet for details.
-- 
-- ----------------------------------------------------------------------------
function ee_24lcxx_read_next(byte out data) return bit is
   var bit ack_ok

   ; flush buffer to set address as expected
   ack_ok = ee_24lcxx_flush()

   if (ack_ok) then
      
      for 80 loop
         i2c_start()                               -- send start bit       
         ack_ok = i2c_transmit_byte(_last_chip_address | 1) -- read mode
         if (ack_ok) then exit loop end if

         -- eeprom is probably busy, so wait a bit and
         -- try again, up to 8 ms (80 * 100us).               
         i2c_stop
         delay_10us(10)  
;         serial_hw_data = "."
      end loop   
   end if
      
   data = i2c_receive_byte(0)                     -- nack (no ack)
   i2c_stop()                                     -- send stop bit
   
   return ack_ok
end function

