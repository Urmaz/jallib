-- ------------------------------------------------------
-- Title: Eeprom 24lc* common code
--
-- Author: Joep Suijs, Copyright (c) 2008..2012, all rights reserved.
--
-- Adapted-by: 
--
-- Compiler: >=2.4m
-- Revision: $Revision: 2902 $
--
-- This file is part of jallib  (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: 24lc* enhanced library common code
--
-- Sources: Microchip datasheet for supported devices:
--
--    24lc16       size 2kx8
--                 page size 16 bytes
--                 adressing 3 bit + 1 byte
--    
--    24lc32/64    size 4kx8/8kx8
--                 page size 32 bytes
--                 adressing 0 bit + 2 byte
--    
--    24lc256      size 32kx8
--                 page size 64 bytes
--                 adressing 0 bit + 2 byte
--    
--    24lc512      size 64kx8
--                 page size 128 bytes
--                 adressing 0 bit + 2 byte
--    
--    24lc1025     size 128kx8
--                 page size 128 bytes
--                 adressing 1 bit + 2 byte
--    
-- Notes: 
--
-- -------------------------------------------------------- ----------------------------------------------------------------------------
include delay

-- default
if (defined(eeprom_i2c_address) == false) then                
   const eeprom_i2c_address = 0xA0
end if


var bit _24lc_flush = false  
var sdword  eeprom_address_pointer = -1
var byte    eeprom_buffer_index

var byte eeprom_buffer[eeprom_buffer_size]

; compile-time validation of eeprom type
if (defined(eeprom_no_type_check)==false) then      
   case (eeprom_24lc_type) of
      16    : block end block
      32    : block end block
      64    : block end block
      256   : block end block
      512   : block end block
      1025  : block end block   
      otherwise block         
         _error"unsupported type of i2c eeprom (eeprom_24lc)"
      end block
   end case
end if

-- ----------------------------------------------------------------------------
-- _ee_24lcxx_chip_address - send chip-address to eeprom
-- ----------------------------------------------------------------------------
-- ----------------------------------------------------------------------------
function _get_24lcxx_chip_address(dword in mem_address) return byte is
   var bit ack_ok
   var byte i2c_addr_byte

   ;------------------------
   ; device address handling
;   if (read_mode) then
;      i2c_addr_byte = eeprom_i2c_address | 0x01
;   else
      i2c_addr_byte = eeprom_i2c_address & 0xFE
;   end if
;      serial_hw_data = "@"

   ; adjust address byte to address appropriate block   
   case (eeprom_24lc_type) of
     
      16 : block     ; 24lc16 addressing
         ; upper 3 bits of data_address are part of device addressing
         i2c_addr_byte = (i2c_addr_byte & 0xF0) + byte(0x07 & (mem_address / 256)) 
      end block

      32 : block end block

      64 : block end block

      256 : block end block

      512 : block end block

      1025 : block   ; 24lc1025 addressing
         ; one bit of data_address is part of device addressing 
         i2c_addr_byte = i2c_addr_byte & 0xF6 
         if (mem_address > 0xFFFF) then
            i2c_addr_byte = i2c_addr_byte | 0x08
         end if
      end block   

      otherwise block 
      end block
      
   end case
;      serial_hw_data = "!"

   ; retry up to 8 ms to cope with write-time
 ;  for 80 loop 
;      serial_hw_data = "."
;      ack_ok = i2c_transmit_byte(i2c_addr_byte)          -- transmit device/chip address

;      if (ack_ok) then exit loop end if
;      delay_10us(10)
;   end loop

   return i2c_addr_byte
end function

-- ----------------------------------------------------------------------------
-- _ee_24lcxx_mem_address - send mem-address to eeprom
-- ----------------------------------------------------------------------------
-- ----------------------------------------------------------------------------
function _ee_24lcxx_mem_address(dword in mem_address) return bit is
   var bit ack_ok = true

   ; ----------------------------------------   
   ; data address handling (one or two bytes)
   if (eeprom_24lc_type > 16) then
      ack_ok = ack_ok & i2c_transmit_byte(byte(mem_address / 256))    -- send high address byte if relevant
   end if
   
   ack_ok = ack_ok & i2c_transmit_byte(byte(mem_address))       -- send low address byte
   
   return ack_ok
end function

-- ----------------------------------------------------------------------------
-- ee_24lcxx_write - write a byte to the eeprom
-- ----------------------------------------------------------------------------
-- ----------------------------------------------------------------------------
function ee_24lcxx_write(dword in mem_address, byte in data) return bit is
   var bit data_stored =  false
   var bit ack_ok = true
   var byte temp, i

;   serial_hw_data = "w"
   check(1000)


   if (_24lc_flush == false) then
      ; add data to the buffer
      if (eeprom_address_pointer == -1) then
   check(1101)
         ; buffer empty, so place in buffer
         eeprom_address_pointer = sdword(mem_address)
   check(1102)
         eeprom_buffer[0] = data
   check(1103)
         eeprom_buffer_index = 1
   check(1104)
         data_stored = true
   check(1105)
         
      elsif (mem_address == (eeprom_address_pointer + eeprom_buffer_index)) then
   check(1106)
         
         ; next byte, so place in buffer
         eeprom_buffer[eeprom_buffer_index] = data        
         
         
   check(1107)
   print_byte_dec(serial_hw_data, eeprom_buffer_index)
   serial_hw_data = "_"
         eeprom_buffer_index = eeprom_buffer_index + 1      
   check(1108)
         data_stored = true
   check(1109)
         
      end if
   end if
   check(1001)
                                             
   ; write current buffer to eeprom
   if ((data_stored == false) |  ; this test implicit includes _24lc_flush=true and _24lc_flush=true implies data is present
       (eeprom_buffer_index >= eeprom_buffer_size) |      ; bug?!? if this check is '>' instead of '>=', index at line 178
                                                          ; gets out of range and overwrites next byte in memory (test_index)
                                                          ; thought the compiler would prevent this...
       (((eeprom_address_pointer + eeprom_buffer_index) & eeprom_24lc_page_mask) != (eeprom_address_pointer & eeprom_24lc_page_mask))) then
         
      ; write data    
;      serial_hw_data = "W"

      var byte chip_addr = _get_24lcxx_chip_address(word(eeprom_address_pointer))
   check(1002)
      
      for 80 loop
         i2c_start()                              -- send start bit       
         ack_ok = i2c_transmit_byte(chip_addr)
         if (ack_ok) then exit loop end if
            
         i2c_stop
         delay_10us(10)
         serial_hw_data = "."
      end loop   
   check(1003)


;      ack_ok =          _ee_24lcxx_chip_address(word(eeprom_address_pointer), false) ; write mode       
      if (ack_ok == false) then serial_hw_data = "^" return false end if
;      serial_hw_data = "w"
   check(1004)

      ack_ok = ack_ok & _ee_24lcxx_mem_address(word(eeprom_address_pointer))
      if (ack_ok == false) then serial_hw_data = "$" return false end if
;      serial_hw_data = "x"
   check(1005)
      
      for eeprom_buffer_index using i loop                  
         ack_ok = ack_ok & i2c_transmit_byte(eeprom_buffer[i])  -- transmit data & wait for ack
            if (ack_ok == false) then serial_hw_data = "^" return false end if
;               serial_hw_data = "y"
   check(1006)

      end loop
      i2c_stop()                                               -- send stop bit
;      delay_1ms(10); tijdelijk
   check(1007)
                   
      ; write done, update administration                                   
      eeprom_address_pointer = -1 ; buffer empty
   check(1008)
      
   end if

   if ((data_stored == false) & (_24lc_flush == false))then
      ; store databyte if not stored previous and not in flush mode
      ; here, the buffer is always clear, so it is safe to assume we have to store at beginning
      eeprom_address_pointer = sdword(mem_address)
      eeprom_buffer[0] = data
      eeprom_buffer_index = 1
   end if

;               serial_hw_data = "z"

   return ack_ok   
end function


-- ----------------------------------------------------------------------------
-- ee_24lcxx_flush - flush any data stored in buffer
-- ----------------------------------------------------------------------------
-- Data is stored in a buffer to allow more efficient write (page write).
-- This function forces all buffered data to be written to the target, in 
-- other words: it executes all delayed writes.
-- ----------------------------------------------------------------------------
function ee_24lcxx_flush() return bit is
   var bit ack_ok;   
   
   if(eeprom_address_pointer == -1) then return true end if ; nothing to flush
   
   _24lc_flush = true ; flush (do not add dummy byte to buffer)

   ack_ok = ee_24lcxx_write(0, 0)      

   _24lc_flush = false ; disable flush for future calls.

   return ack_ok;   
end function    

--------------------------------------------------------------------------------
-- Read data from 24LC256 at input address
--------------------------------------------------------------------------------
function ee_24lcxx_read(dword in mem_address, byte out data) return bit is
   var bit ack_ok

;   serial_hw_data = "r"

   ; flush buffer to prevent readback of old data
   ack_ok = ee_24lcxx_flush()

   var byte chip_addr = _get_24lcxx_chip_address(word(mem_address))

   if (ack_ok) then
      
      for 80 loop
         i2c_start()                              -- send start bit       
         ack_ok = i2c_transmit_byte(chip_addr)
         if (ack_ok) then exit loop end if
            
         i2c_stop
         delay_10us(10)  
         serial_hw_data = "."
      end loop   
   end if
      
   ack_ok = ack_ok & _ee_24lcxx_mem_address(mem_address)
   
   i2c_restart()                                    -- send start bit
   ack_ok = ack_ok & i2c_transmit_byte(chip_addr | 1) -- read mode 
   data = i2c_receive_byte(0)                     -- nack (no ack)
   i2c_stop()                                     -- send stop bit
   
   return ack_ok
end function

