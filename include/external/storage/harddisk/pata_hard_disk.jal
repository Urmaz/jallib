-- Title: Hard disk library for communicating with parallel ata hard drives
--        with a 40 pin ide connector.
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4k
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: this library provides functions for pata/ide hard disk drives.
--
-- Sources:
-- "connecting ide drives by tilmann reh" - http://www.gaby.de/gide/IDE-TCJ.txt
-- IDE hardware reference & information document by alex t. ivopol
-- ATA Attachement with Packet Interface 6 - d1410r3-ATA-ATAPI-6.pdf
--
-- Notes: - If you are not using Alternate Status, Digital Output or Drive Address registers
--          pins cs1 & cs0 can be saved by connecting these ide pins to cs0-high, cs1-low
--          at ide connector. normal operation does not require these pins. Set
--          "CONST BYTE PATA_HD_USE_CS0_CS1_PINS = TRUE" if you will be using
--          these registers
--        - You MUST write full sectors of 512 bytes.
--        - this lib does not do error checking
--
-- Functions descriptions:
-- pata_hd_init                - initialize startup settings, recalibrates drive.
-- pata_hd_start_read          - Get drive ready for reading at specified sector
-- pata_hd_read_data           - Read two bytes from disk.
-- pata_hd_stop_read           - Tell drive you are done reading.
-- pata_hd_start_write         - Get drive ready for writing at specified sector
-- pata_hd_write_data          - Write two bytes to disk
--                             - Data will not be written unless 256 writes are sent.
--                             - There are 512 bytes in a sector
-- pata_hd_write_to_sector_end - Finnish writing the current sector with input byte.
-- pata_hd_stop_write          - Tell drive you are done writing.
-- pata_hd_write_pulse         - Send a number of write pulses to data register,
--                               sending 0's as data.
--                             - Used to get to a certain location in a sector while
--                               writing 0's as data
-- pata_hd_read_pulse          - Send a number of read pulses to data register
--                               without getting any data.
--                             - Used to get to a certain location in a sector.
--
-- Pin-outs - PATA IDE 40 pin connector
-- Power connector - black ground, red +5v, yellow +12v
--                 - 2.5" laptop drives do not need 12v
-- 2,19,22,24,26,30,40 - connect direct to ground
-- 1 - /reset, connect to switch (high 5v for normal operation, low resets drive)
-- 28 - ALE, connect to -> 1k resistor -> 5v
-- 39 - ACT, connect to -> LED -> 1k resistor -> 5v
-- 21,27,20,29,31,32,34, leave not connected
-- 3,5,7,9,11,13,15,17 - D0-D7, connect direct to pata_hd_data_low pins
-- 18,16,14,12,10,8,6,4 - D8-D15, connect direct to pata_hd_data_high pins
-- 23 - /IOW, connect direct to iowr         -- see constant PATA_HD_NO_INVERTER
-- 25 - /IOR, connect direct to pata_hd_iord -- see constant PATA_HD_NO_INVERTER
-- 38 - /cs0, connect direct to pata_hd_cs0 (or 5v) -- see constant PATA_HD_NO_INVERTER & PATA_HD_USE_CS0_CS1_PINS
-- 37 - /cs1, connect direct to pata_hd_cs1 (or gnd) -- see constant PATA_HD_NO_INVERTER & PATA_HD_USE_CS0_CS1_PINS
-- 36 - A2, connect direct to pata_hd_a2
-- 33 - A1, connect direct to pata_hd_a1
-- 35 - A0, connect direct to pata_hd_a0
-- Watch for open drain pins on your pic, use pull-up resistors.
--

-- variables
var byte pata_hd_word_count = 0    -- counts words read from current sector, must be a byte
var byte pata_hd_sector_count = 0  -- counds sectors read, must be a byte.

-- readable/writeable registers
const PATA_HD_DATA_REG = 8        -- data register
const PATA_HD_SEC_COUNT_REG = 10  -- sector count
const PATA_HD_SEC_NUM_REG = 11    -- sector number
const PATA_HD_CYL_LOW_REG = 12    -- cylinder low
const PATA_HD_CYL_HIGH_REG = 13   -- cylinder high
const PATA_HD_SDH_REG = 14        -- sector/drive/head register

-- readable registers
const PATA_HD_ERROR_REG = 9       -- error register
const PATA_HD_STATUS_REG = 15     -- status register  (creates interupt)
const PATA_HD_ALT_STATUS_REG = 16 -- alternate status (no interupt)
const PATA_HD_ADDRESS_REG = 17    -- drive address

-- writeable registers
const PATA_HD_PRECOMP_REG = 9     -- write precomp reg
const PATA_HD_COMMAND_REG = 15    -- command register
const PATA_HD_DODC_REG = 16       -- digital output / device control

-- common commands for command register:
const PATA_HD_RECALIBRATE = 0x10     -- sends drive heads to cyl 0, SC, SN, and SDH are not changed
const PATA_HD_READ_SECTORS = 0x20     -- reads data from sector(s)
const PATA_HD_WRITE_SECTORS = 0x30    -- write data to sector(s)
const PATA_HD_IDENTIFY_DRIVE = 0xEC  -- read drive info such as make/modem/sn/drive size
const PATA_HD_SPIN_DOWN = 0xE0       -- turn off the drive's motor
const PATA_HD_SPIN_UP = 0xE1         -- turn on the drive's motor

-- other constants
-- used for pata_hd_data_request()
const BIT PATA_HD_WAIT_READ = 0  -- wait for sector buffer to fill it's contents with data from disk platters
const BIT PATA_HD_WAIT_WRITE = 1 -- wait for sector buffer to empty it's contents to disk platters

const PATA_HARD_DISK = 0            -- data media constants for fat32 lib
const SD_CARD = 1
const DATA_MEDIA = PATA_HARD_DISK

-- other vars
var dword pata_hd_sector_select = 0
var bit pata_hd_48_bit_lba_support = false  -- currently this lib does not support drives > 137,438,952,960 bytes (28 bit addressing)
                                            -- "IDENTIFY DEVICE bit 10 word 83 indicates support for 48-bit addressing" - in ata8 pdf

-- from "connecting ide drives by tilmann reh" - http://www.gaby.de/gide/ide-tcj.txt
-- List of commands and required parameters:
-- -----------------------------------------------------------------------------
-- command             type  7 6 5 4 3 2 1 0    hex       parameters required
-- -----------------------------------------------------------------------------
-- recalibrate          *    0 0 0 1  (rate)    10-1F     d
-- read sector          *    0 0 1 0 0 m l t    20-27     sc,sn,c,d,h
-- write sector         *    0 0 1 1 0 m l t    30-37     sc,sn,c,d,h
-- scan id / verify     *    0 1 0 0 0 0 0 t    40,41     d,(sc,sn,c,h)
-- write format         *    0 1 0 1 0 0 0 0    50        c,d,h,(sc,sn)
-- seek                 *    0 1 1 1  (rate)    70-7F     c,d,(h)
-- exec diagnostics          1 0 0 1 0 0 0 0    90        d
-- set drive parameters      1 0 0 1 0 0 0 1    91        sc,(c),d,h
-- read multiple        +    1 1 0 0 0 1 0 0    C4        sc,sn,c,d,h
-- write multiple       +    1 1 0 0 0 1 0 1    C5        sc,sn,c,d,h
-- set multiple         +    1 1 0 0 0 1 1 0    C6        sc,d
-- power commands       +    1 1 1 0 0 x x x    E0-E6     sc,d
-- read sector buffer        1 1 1 0 0 1 0 0    E4        d
-- write sector buffer       1 1 1 0 1 0 0 0    E8        d
-- identify drive            1 1 1 0 1 1 0 0    EC        d
-- cache on/off         +    1 1 1 0 1 1 1 1    EF        d,wp
-- power save           +    1 1 1 1 1 x x x    F8-FD     ?

-- ------------------------------------------------
-- register                           abbr.
-- ------------------------------------------------
-- data register                      d
-- error reg. / write precomp. reg.   e / wp
-- sector count                       sc
-- sector number                      sn
-- cylinder low                       c
-- cylinder high                      c
-- sdh (sector size, drive, head)     d,h
-- status reg. / command reg.

-- ----------------------------------------------------------------------------
-- Set register select pins to selected register, for internal use only.
-- ----------------------------------------------------------------------------
procedure pata_hd_select_register(byte in register) is	
  -- set register select pins one at a time
  var bit bit0 at register : 0
  var bit bit1 at register : 1
  var bit bit2 at register : 2
  var bit bit3 at register : 3
  var bit bit4 at register : 4

  -- setup data bits
  pata_hd_a0 = bit0
  pata_hd_a1 = bit1
  pata_hd_a2 = bit2
  if PATA_HD_USE_CS0_CS1_PINS == TRUE then
    pata_hd_cs1 = bit3 ^ PATA_HD_NO_INVERTER
    pata_hd_cs0 = bit4 ^ PATA_HD_NO_INVERTER
  end if
end procedure

-- ----------------------------------------------------------------------------
-- Wait for drive to be ready for a data transfer.
-- Sets data pins as inputs or outputs for next read or write.
-- ----------------------------------------------------------------------------
procedure pata_hd_data_request(bit in read_write) is begin
  var bit s
  var bit drq at pata_hd_data_low : 3           -- set drq pin to check
  s = 0
	
  -- set data pins as inputs
  pata_hd_data_low_direction = all_input
  pata_hd_data_high_direction = all_input

  pata_hd_select_register (PATA_HD_STATUS_REG)  -- select status register	

  -- wait for drq in status register to be high.
  -- may get stuck in loop if drq never goes high
  -- you can modify to check for errors or have a time-out
  while s == 0 loop
    pata_hd_iord = high ^ PATA_HD_NO_INVERTER   -- start read pulse
    if drq == high then
      s = 1                                     -- exit loop
    end if
    pata_hd_iord = low ^ PATA_HD_NO_INVERTER    -- end read pulse
  end loop

  -- after drive is ready for data transfer, go to the data register
  pata_hd_select_register (PATA_HD_DATA_REG)

  if read_write == PATA_HD_WAIT_READ then      -- if we are waiting to read data in
    -- do nothing since data pins are already inputs
  else                                         -- if we are waiting to write data out
    -- set data ports to outputs
    pata_hd_data_low_direction = all_output
    pata_hd_data_high_direction = all_output
  end if
end procedure

-- ----------------------------------------------------------------------------
-- Registers may not be accessed unless bsy bit is
-- low due to internal operations.
-- ----------------------------------------------------------------------------
procedure pata_hd_busy() is begin
  var bit s
  s = 1
  var bit bsy at pata_hd_data_low : 7           -- set bsy pin to check
	
  -- set data pins as inputs
  pata_hd_data_low_direction = all_input
  pata_hd_data_high_direction = all_input

  pata_hd_select_register (PATA_HD_STATUS_REG)  -- select status register
	
  -- wait for bsy in status register to be high
  -- may get stuck in loop if bsy never goes low
  -- you can modify to check for errors or have a time-out
  while s == 1 loop
    pata_hd_iord = high ^ PATA_HD_NO_INVERTER   -- start read pulse
    if bsy == low then
      s = 0                                     -- end loop
    end if
    pata_hd_iord = low ^ PATA_HD_NO_INVERTER    -- end read pulse
  end loop
end procedure

-- ----------------------------------------------------------------------------
-- Wait for drive to be up to speed and ready for a command.
-- ----------------------------------------------------------------------------
procedure pata_hd_drive_ready() is begin
  var bit s
  s = 1
  var bit rdy at pata_hd_data_low : 6           -- set rdy pin to check
	
  -- set data pins as inputs
  pata_hd_data_low_direction = all_input
  pata_hd_data_high_direction = all_input
	
  pata_hd_select_register (PATA_HD_STATUS_REG)  -- select status register	
	
  -- wait for rdy in status register to be high
  -- may get stuck in loop if rdy never goes high
  -- you can modify to check for errors or have a time-out
  while s == 1 loop
    pata_hd_iord = high ^ PATA_HD_NO_INVERTER   -- start read pulse
    if rdy == high then
      s = 0                                     -- end loop
    end if
    pata_hd_iord = low ^ PATA_HD_NO_INVERTER    -- end read pulse
  end loop
end procedure

-- ----------------------------------------------------------------------------
-- Select a register and give it a command or data.
-- ----------------------------------------------------------------------------
procedure pata_hd_register_write(byte in register, byte in low_byte) is begin
  var byte high_byte = 0

  -- registers may not be accessed unless drive is not busy
  pata_hd_busy()

  if register == PATA_HD_COMMAND_REG then
    -- make sure the drive is up to speed and ready for a command
    pata_hd_drive_ready()
  end if

  pata_hd_select_register (register)     -- select register

  -- set data ports to outputs
  pata_hd_data_low_direction = all_output
  pata_hd_data_high_direction = all_output	
	
  -- send the data trough the ide interface
  pata_hd_data_low = low_byte                 -- set low data byte
  pata_hd_data_high = high_byte               -- set high data byte
  pata_hd_iowr = high ^ PATA_HD_NO_INVERTER   -- send write pulse
  pata_hd_iowr = low ^ PATA_HD_NO_INVERTER				
end procedure

-- ----------------------------------------------------------------------------
-- Select a register and get data from it.
-- ----------------------------------------------------------------------------
procedure pata_hd_register_read(byte in register, byte out low_byte) is begin
  var byte high_byte

  -- registers may not be accessed unless drive is not busy
  pata_hd_busy()

  pata_hd_select_register (register)     -- select register

  -- set data ports to inputs
  pata_hd_data_low_direction = all_input
  pata_hd_data_high_direction = all_input

  -- get the data trough the ide interface
  pata_hd_iord = high ^ PATA_HD_NO_INVERTER      -- start read pulse
  low_byte = pata_hd_data_low                    -- get low data byte
  high_byte  = pata_hd_data_high                 -- get high data byte
  pata_hd_iord = low ^ PATA_HD_NO_INVERTER       -- end read pulse
end procedure

-- ----------------------------------------------------------------------------
-- Go to a specific sector, select lba/chs mode and master/slave drive
-- Max sector number is 0x0F_FF_FF_FF or the number of sectors the drive has.
-- Max drive size is 0x0F_FF_FF_FF * 512 = 137.439 GB
-- Sector count selects number of sectors that will be read
-- Sector count value of 0 means 256 sectors will be read
-- ----------------------------------------------------------------------------
procedure pata_hd_set_address(byte in pata_hd_head_addr, byte in cyl_high_addr, byte in cyl_low_addr, byte in sec_num_addr, byte in sec_count) is
  -- select lba or chs mode
  var volatile byte  pata_hd_sdh_val    =     0b_1110_0000
  var volatile bit   pata_hd_lba              at pata_hd_sdh_val : 6
  var volatile bit   pata_hd_slave            at pata_hd_sdh_val : 4

  -- select drive options
  pata_hd_lba = true                             -- 1 = lba mode, 0 = chs mode (not tested)
  pata_hd_slave = false                          -- 0 = master,   1 = slave    (not tested)
	
  pata_hd_register_write (PATA_HD_SEC_COUNT_REG,sec_count)     -- set sec count register, sectors to read/write	
  pata_hd_register_write (PATA_HD_SEC_NUM_REG,sec_num_addr)    -- set sec number register address	
  pata_hd_register_write (PATA_HD_CYL_LOW_REG,cyl_low_addr)    -- set cyl low register address	
  pata_hd_register_write (PATA_HD_CYL_HIGH_REG,cyl_high_addr)  -- set cyl high register address		
  -- set sector/drive/head register, head number
  -- pata_hd_head_val address can be 0 to 15
  pata_hd_register_write (PATA_HD_SDH_REG,pata_hd_sdh_val + pata_hd_head_addr)					
end procedure

-- ----------------------------------------------------------------------------
-- Go to a specific sector number (lba mode only)
-- Max sector number is 268435455 or the number of sectors the drive has.
-- Max drive size is 268435455 * 512 = 137.439 GB
-- Sector count selects number of sectors that will be read
-- Sector count value of 0 means 256 sectors will be read
-- ----------------------------------------------------------------------------
procedure pata_hd_go_to_sector(dword in sector, byte in sec_count) is
  var byte sec_num_addr,cyl_low_addr,cyl_high_addr,pata_hd_head_addr

  -- change sector number into bytes
  var byte  dval[4] at sector
  sec_num_addr = dval[0]
  cyl_low_addr = dval[1]
  cyl_high_addr = dval[2]
  pata_hd_head_addr = dval[3]

  -- go to the address
  pata_hd_set_address (pata_hd_head_addr,cyl_high_addr,cyl_low_addr,sec_num_addr,sec_count)
end procedure

-- ----------------------------------------------------------------------------
-- Get drive ready for reading at specified address
-- ----------------------------------------------------------------------------
procedure pata_hd_start_read(dword in address) is
  pata_hd_sector_select = address   -- set the users selected sector
  pata_hd_word_count = 0            -- reset number of words read from sector
  pata_hd_sector_count = 0          -- reset number of sectors read
end procedure

-- ----------------------------------------------------------------------------
-- Read two bytes from disk.
-- ----------------------------------------------------------------------------
procedure pata_hd_read_data(byte out low_byte, byte out high_byte) is
  if (pata_hd_word_count == 0) & (pata_hd_sector_count) == 0 then        -- if we are at beginning of read
    pata_hd_go_to_sector(pata_hd_sector_select,0)                        -- go to the selected sector
    pata_hd_register_write(PATA_HD_COMMAND_REG,PATA_HD_READ_SECTORS)      -- send the read command to the command register	
    pata_hd_data_request(PATA_HD_WAIT_READ)                              -- wait till the drive has data for you
  elsif pata_hd_word_count == 0 then                                     -- if we are at beginning of a sector
    pata_hd_data_request(PATA_HD_WAIT_READ)                              -- wait for data to be ready for read
  end if
  	
  if pata_hd_word_count == 255 then                                      -- if we are at end of current sector
    pata_hd_sector_select = pata_hd_sector_select + 1                    -- increment the selected sector
    pata_hd_sector_count = pata_hd_sector_count + 1                      -- increase sector count
  end if
  	
  pata_hd_word_count = pata_hd_word_count + 1   -- increment words read from current sector
	
  -- get the data trough the ide interface
  pata_hd_iord = high ^ PATA_HD_NO_INVERTER  -- start read pulse
  low_byte = pata_hd_data_low                -- get low data byte
  high_byte  = pata_hd_data_high             -- get high data byte
  pata_hd_iord = low ^ PATA_HD_NO_INVERTER   -- end read pulse 	
end procedure

-- ----------------------------------------------------------------------------
-- Send a number of read pulses to data register without getting any data.
-- Used to get to the end of a sector or to get to a certain
-- location in a sector.
-- Increment pata_hd_word_count
-- ----------------------------------------------------------------------------
procedure pata_hd_read_pulse(dword in z) is
  var byte x,y
  for z loop
    pata_hd_read_data (x,y)                         		
  end loop
end procedure

-- ----------------------------------------------------------------------------
-- Tell drive you are done reading
-- ----------------------------------------------------------------------------
procedure pata_hd_stop_read() is
  pata_hd_register_write(PATA_HD_COMMAND_REG, 0xE1) -- set media idle
end procedure

-- ----------------------------------------------------------------------------
-- Get drive ready for writing at specified address
-- ----------------------------------------------------------------------------
procedure pata_hd_start_write(dword in address) is
  pata_hd_sector_select = address
  pata_hd_word_count = 0              -- reset number of words written to sector
  pata_hd_sector_count = 0            -- reset number of sectors written
end procedure

-- ----------------------------------------------------------------------------
-- Write two bytes to disk
-- Data will not be written unless 256 writes are sent.
-- ----------------------------------------------------------------------------
procedure pata_hd_write_data(byte in low_byte, byte in high_byte) is
  if pata_hd_word_count == 0 then                                     -- if we are at beginning of write
    pata_hd_go_to_sector (pata_hd_sector_select,1)                    -- go to the correct sector, set to write 1 sector
    pata_hd_register_write (PATA_HD_COMMAND_REG,PATA_HD_WRITE_SECTORS) -- send the write command to the command register
    pata_hd_data_request(PATA_HD_WAIT_WRITE)                          -- wait till data is ready to be read
  end if
  	
  if pata_hd_word_count == 255 then                                   -- if we are at the end of a sector
     pata_hd_sector_count = pata_hd_sector_count + 1                  -- increment sectors written
     pata_hd_sector_select = pata_hd_sector_select + 1                -- increment the selected sector
  end if
  
  pata_hd_word_count = pata_hd_word_count + 1    -- increment words written to disk
	
  -- send the data trough the ide interface
  pata_hd_data_low = low_byte                    -- set low data byte
  pata_hd_data_high = high_byte                  -- set high data byte
  pata_hd_iowr = high ^ PATA_HD_NO_INVERTER      -- send write pulse
  pata_hd_iowr = low ^ PATA_HD_NO_INVERTER 	  	
end procedure

-- ----------------------------------------------------------------------------
-- Send a number of write pulses to data register sending 0's as data.
-- Used to get to the end of a sector or to get to a certain
-- location in a sector.
-- Increment pata_hd_word_count
-- ----------------------------------------------------------------------------
procedure pata_hd_write_pulse( byte in z ) is begin
  for z loop -- send write pulse z number of times
    pata_hd_write_data (0,0)
  end loop
end procedure

-- ----------------------------------------------------------------------------
-- Tell drive you are done writing
-- ----------------------------------------------------------------------------
ALIAS pata_hd_stop_write is pata_hd_stop_read -- same procedure as stop read

-- ----------------------------------------------------------------------------
-- Finnish writing the current sector with input byte.
-- ----------------------------------------------------------------------------
procedure pata_hd_write_to_sector_end(byte in input_byte) is
  var byte x
  x = 0 - pata_hd_word_count -- calculate how many words are left to write to current sector
  for x loop                 -- loop till end of sector
    pata_hd_write_data(input_byte, input_byte) -- write 2 bytes
  end loop
end procedure

-- ----------------------------------------------------------------------------
-- initialize startup settings
-- ----------------------------------------------------------------------------
procedure pata_hd_init() is begin
  -- set startup setting for read/read pins
	pata_hd_iowr = low ^ PATA_HD_NO_INVERTER   -- start write pulse pin low
  pata_hd_iord = low ^ PATA_HD_NO_INVERTER   -- start read pulse pin low
  pata_hd_register_write (PATA_HD_COMMAND_REG,PATA_HD_RECALIBRATE) -- recalibrate the drive
end procedure

--------------------------------------------------------------------------------
-- read one entire sector
--------------------------------------------------------------------------------
const dword LARGE_ARRAY_3_SIZE = 512           -- choose number of array variables
const dword LARGE_ARRAY_3_VARIABLE_SIZE = 1    -- choose size of variables
include large_array_3                          -- include the array library
alias pata_hd_sector_buffer is large_array_3   -- rename/alias the array to pata_hd_sector_buffer
procedure pata_hd_read_sector() is
  var word count1
  pata_hd_word_count = 0

  if pata_hd_sector_count == 0 then                                      -- if we are at beginning of read
    pata_hd_go_to_sector(pata_hd_sector_select,0)                        -- go to the selected sector
    pata_hd_register_write(PATA_HD_COMMAND_REG,PATA_HD_READ_SECTORS)     -- send the read command to the command register	
  end if
  
  pata_hd_data_request(PATA_HD_WAIT_READ) -- wait for data to be ready for read before each sector
	
	count1 = 0
   for 256 loop	
     -- get the data trough the ide interface
     pata_hd_iord = high ^ PATA_HD_NO_INVERTER  -- start read pulse
     pata_hd_sector_buffer[count1 + 1] = pata_hd_data_high -- get high data byte
     pata_hd_sector_buffer[count1]     = pata_hd_data_low  -- get low data byte
     pata_hd_iord = low ^ PATA_HD_NO_INVERTER   -- end read pulse
     count1 = count1 + 2
	end loop	

  pata_hd_sector_select = pata_hd_sector_select + 1  -- increment the selected sector
  pata_hd_sector_count = pata_hd_sector_count + 1    -- increase sector count
end procedure

