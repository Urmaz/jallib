-- ------------------------------------------------------
-- Title: 1 wire library for DS18b20
--
-- Author: Jean Marchaudon, Copyright (c) 2010..2010, all rights reserved.
--
-- Adapted-by: And-Tech.pl, Bert van Dam, Jean Marchaudon, Olivier Seit, Vasile Surducan, Joep Suijs
--
-- Compiler: >=2.4m
--
-- This file is part of jallib  (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: 1 wire routines for the DS18b20 temperature probe
--    Read sensor temperature DS18b20 from a specific device using the
--    drive's ID
--
-- Sources:
--
-- Notes: requires 1_wire.jal
--
-- ------------------------------------------------------

var word temperature
var byte rom_id[8]
var byte scratchpad[9]
var byte good_crc


-- ROM Commands
-- for selecting only one device at a time
procedure ds18b20_match_rom() is
   d1w_reset()
   d1w_write_byte( 0x55 )
end procedure

procedure ds18b20_skip_rom() is
   d1w_reset()
   d1w_write_byte( 0xCC )
end procedure

procedure ds18b20_convert() is
   ds18b20_skip_rom()
   d1w_write_byte(0x44)
   delay_1ms(4)
end procedure

procedure ds18b20_send_id() is
   d1w_write_byte(rom_id[0])
   d1w_write_byte(rom_id[1])
   d1w_write_byte(rom_id[2])
   d1w_write_byte(rom_id[3])
   d1w_write_byte(rom_id[4])
   d1w_write_byte(rom_id[5])
   d1w_write_byte(rom_id[6])
   d1w_write_byte(rom_id[7])
end procedure

-- resolution can be 9, 10, 11, 12
-- TL = minimum -55
-- TH = maximum 124
-- procedure ds18b20_setup(sbyte in th, sbyte in tl, byte in resolution) is
  --
--  var byte i
--  var byte reg[3]
-- if (resolution == 9) then
--    reg[2] = 0x1F
-- elsif (resolution == 10) then
--    reg[2] = 0x3F
-- elsif (resolution == 11) then
--    reg[2] = 0x5F
-- else
--    reg[2] = 0x7F
-- end if
   
-- if th == 0 then
--   reg[0] = 0x80 | (th & 0x7F)
-- else
--   reg[0] = th & 0x7F
-- end if
   
-- if tl == 0 then
--   reg[1] = 0x80 | (tl & 0x7F)
-- else
--   reg[1] = tl & 0x7F
-- end if
   
-- d1w_write_byte(0x4e)
-- d1w_write_byte(reg[0])
-- d1w_write_byte(reg[1])
-- d1w_write_byte(reg[2])
   --
-- end procedure


-- nbre_byte = 8 when you read rom ID
-- nbre_byte = 9 when you read the scratchpad
procedure ds18b20_read_with_crc( byte in nbre_byte ) is
   -- read a number of bytes and calculate the CRC value of
   -- the complete group
   var byte bb = 0, n = 0 , crcbyte = 0, i
   var bit  bb_bit0 at bb : 0
   var bit  crcbyte_bit0 at crcbyte : 0
   var bit  crcbyte_bit2 at crcbyte : 2
   var bit  crcbyte_bit3 at crcbyte : 3
   var bit  crcbyte_bit7 at crcbyte : 7
   var bit  crcbit

   for nbre_byte using i loop -- 8 bytes for readrom ID, 9 bytes for read temp
      d1w_read_byte( bb )
      if nbre_byte == 9 then
         scratchpad[i]= bb
      elsif nbre_byte == 8 then
         rom_id[i] = bb
      end if

      -- calculate the CRC value, if this value is zero than
      -- the CRC is correct
      for 8 loop
         crcbit = crcbyte_bit0 ^ bb_bit0
         crcbyte = (crcbyte >> 1)
         crcbyte_bit7 = crcbit
         crcbyte_bit2 = crcbyte_bit2 ^ crcbit
         crcbyte_bit3 = crcbyte_bit3 ^ crcbit
         bb = (bb >> 1)
      end loop
   end loop

   if nbre_byte == 9 then
     if scratchpad[4]==0x_FF & scratchpad[5]==0x_FF & scratchpad[6]==0x_FF &
        scratchpad[7]==0x_FF & scratchpad[8]==0x_FF  then
       -- probe is not present, all read to 1 == 0x_FF
       -- set the CRC value to false, and reset temp with error scale 99°c
       crcbyte = 1
       scratchpad[0]=198
     end if
   end if
   good_crc=crcbyte
end procedure

-- for reading the ROM when you have only one device on wire
procedure ds18b20_s_read_rom() is
  d1w_reset()
  d1w_write_byte( 0x33 )        -- read ID command
  ds18b20_read_with_crc( 8 )   -- just 8 bytes for ID
end procedure

procedure ds18b20_raw_temp(byte out h, byte out l ) is

  ds18b20_match_rom()
  ds18b20_send_id()
  d1w_write_byte(0xBE)
  d1w_read_byte(l)
  d1w_read_byte(h)
  d1w_reset()
end procedure

-- for reading the temperature when you have only one device on wire
procedure ds18b20_s_raw_temp(byte out h, byte out l ) is

  ds18b20_skip_rom()
  d1w_write_byte(0xBE)
  d1w_read_byte(l)
  d1w_read_byte(h)
  d1w_reset()
end procedure

procedure ds18b20_s_temp(byte out inches, byte out fraction, bit out signed) is
  var byte tmp[2] at temperature
  var volatile bit tmp_1_7 shared at tmp[1] : 7

  signed = 0
  ds18b20_s_raw_temp(tmp[1], tmp[0])
  if (tmp_1_7 == 1) then
    signed = 1
  end if
  inches = tmp[1]<<4 | tmp[0]>>4
  fraction = byte((tmp[0] & 0x0F)* word(625)/1000)
end procedure

procedure ds18b20_temp(byte out inches, byte out fraction, bit out signed) is
  --
  var byte tmp[2] at temperature
  var volatile bit tmp_1_7 shared at tmp[1] : 7
  signed = 0
  ds18b20_raw_temp(tmp[1], tmp[0])
  if (tmp_1_7 == 1) then
    signed = 1
  end if
  inches = tmp[1]<<4 | tmp[0]>>4
  fraction = byte((tmp[0] & 0x0F)* word(625)/1000)
end procedure

procedure ds18b20_s_temp_crc(byte out inches, byte out fraction, bit out signed, byte in max_crc_errors) is
  --
  var byte tmp[2] at temperature
  var volatile bit tmp_1_7 shared at tmp[1] : 7
  var byte i = 0

  repeat
    ds18b20_skip_rom()
    d1w_write_byte(0xBE)
    ds18b20_read_with_crc(9)
    i = i + 1
  until (good_crc == 0) | (i == max_crc_errors)
  tmp[0] = scratchpad[0]
  tmp[1] = scratchpad[1]
  -- if (tmp_1_7 == 1) then
  --   signed = 1
  -- end if
  signed = tmp_1_7
  inches = tmp[1]<<4 | tmp[0]>>4
  fraction = byte((tmp[0] & 0x0F)* word(625)/1000)
end procedure

procedure ds18b20_temp_crc(byte out inches, byte out fraction, bit out signed, byte in max_crc_errors) is
   var byte tmp[2] at temperature
   var volatile bit tmp_1_7 shared at tmp[1] : 7
   var byte i = 0

   repeat
      ds18b20_match_rom()
      ds18b20_send_id
      d1w_write_byte(0xBE)
      ds18b20_read_with_crc(9)
      i = i + 1
   until (good_crc == 0) | (i == max_crc_errors)
   tmp[0] = scratchpad[0]
   tmp[1] = scratchpad[1]
   -- if (tmp_1_7 == 1) then
   --   signed = 1
   -- end if
   signed = tmp_1_7
   inches = tmp[1]<<4 | tmp[0]>>4
   fraction = byte((tmp[0] & 0x0F)* word(625)/1000)
end procedure

-- Fahrenheit = (celsius * 1.8) + 32;
--
