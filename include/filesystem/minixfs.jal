-- Title: Minix v2 filesystem implementation
-- Author: Sebastien Lelong, Copyright (c) 2011, all rights reserved.
-- Adapted-by:
-- Compiler: 2.4o
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: Minix v2 implementation
-- Partitions aren't supported, so you have to create a filesystem on the whole
-- available memory. Typically, instead of "mkfs.minix -v /dev/sdX1", you'll
-- have to "mkfs.minix -v /dev/sdX" (and remove sdX1 partition with fdisk)
-- Some useful commands:
--  - fsck.minix -f -v -s /dev/sdX
--       will print Super-Block and some other information about files, dirs, state
--  - hexdump -C /dev/sdX
--       will dump Minix FS content (only changing lines)
--  - hexdump -v -C /dev/sdX
--       will do the same, but dump all lines, even if identical
-- .
-- In order to test your setup, you can untar minix_data.tar.bz2 available at:
-- ... 
-- This archive contains directories and files of different size, used to test
-- data zone and helping to understand how Minix filesystem is designed.
--    1. prepare your device, no partition (replace /dev/sdX with appropriate device):
--          mkfs.minix -v /dev/sdX
--          mount /dev/sdX /mnt/tmp
--    2. untar test data:
--          cd /mnt/tmp && tar xjfv path/to/minix_data.tar.bz2
--          cd && umount /mnt/tmp
--    3. check content:
--          fsck.minix -f -v -s /dev/sdX
--       should report something like (1GB SD-card used here):
-- .
-- Forcing filesystem check on /dev/sdX.
-- 65535 inodes
-- 992000 blocks
-- Firstdatazone=4227 (4227)
-- Zonesize=1024
-- Maxsize=2147483647
-- Filesystem state=1
-- namelen=30
-- .
--     20 inodes used (0%)
--  70858 zones used (7%)
-- .
--     16 regu
--     16 regular files
--      2 directories
--      0 character device files
--      0 block device files
--      1 links
--      2 symbolic links
--      ------
--      21 files
--
--
-- Notes:
--
-- TODO:
--



-- Magic numbers used to idenfity filesystem version
const word MINIX_SUPER_MAGIC   = 0x137F      -- original minix fs
const word MINIX_SUPER_MAGIC2  = 0x138F      -- minix fs, 30 char names
const word MINIX2_SUPER_MAGIC  = 0x2468      -- minix V2 fs
const word MINIX2_SUPER_MAGIC2 = 0x2478      -- minix V2 fs, 30 char names
const word MINIX3_SUPER_MAGIC  = 0x4D5A      -- minix V3 fs

const word MINIX_BYTES_PER_BLOCK = 0x400     -- 1KB per block
const word MINIX_BYTES_PER_INODE = 0x40      -- 64B per inode
const word MINIX_STORAGE_BLOCK_PER_BLOCK = 2 -- how many underlying block per block
                                             -- Ex: SD-cards have 512B block, so there's is
                                             -- 2 underlying block for one minix block
-- Super Block is one block after boot block
const word MINIX_BOOT_BLOCK_ADDRESS = 0x00
const word MINIX_SUPER_BLOCK_ADDRESS = MINIX_BOOT_BLOCK_ADDRESS + MINIX_BYTES_PER_BLOCK
-- max filename size according to minix v2
const byte MINIX_MAX_FILENANE_LEN = 30
const byte MINIX_MAX_DIRECT_ZONE_IDX        = 6
const word MINIX_MAX_INDIRECT_ZONE_IDX      = 0x03FC  -- 0x400 - 4 == one block - one location
const word MINIX_MAX_DOUBLE_DIRECT_ZONE_IDX = 0x03FC  -- 0x400 - 4 == one block - one location
const byte MINIX_NUM_DIRECT_ZONES           = 7
const word MINIX_NUM_INDIRECT_ZONES         = 256
const word MINIX_NUM_DOUBLE_INDIRECT_ZONES  = 65536
const byte MINIX_ZONE_NONE             = 0b_0000
const byte MINIX_ZONE_DIRECT           = 0b_0001
const byte MINIX_ZONE_INDIRECT         = 0b_0010
const byte MINIX_ZONE_DOUBLE_INDIRECT  = 0b_0100
const byte MINIX_ZONE_TRIPLE_INDIRECT  = 0b_1000

-- File descriptor constants
const byte MINIX_FD_READ_ONLY   = 0b_01
const byte MINIX_FD_WRITE_ONLY  = 0b_10
const byte MINIX_FD_READ_WRITE  = 0b_11

-- Error constants. Following "mkfs" convention, errors are added, so
-- minix_last_error can embed several errors
const byte MINIX_ERR_NONE = 0b_0000_0000
const byte MINIX_ERR_BAD_MAGIC_NUMBER     = 0b_0000_0001 -- magic number unsupported
const byte MINIX_ERR_BAD_ZONE_LOCATION    = 0b_0000_0010 -- something is wrong about declared and computed data location
const byte MINIX_ERR_NOT_DIRECTORY        = 0b_0000_0100 -- try to act on a directory, but inode isn't a directory
const byte MINIX_ERR_END_OF_ZONE          = 0b_0000_1000 -- reached end of available data zone

-- Auto-resetting variable: errors are added, and when read, reset to 0
var byte _minix_last_error = MINIX_ERR_NONE
procedure minix_last_error'put(byte in val) is
   _minix_last_error = _minix_last_error + val
end procedure
function minix_last_error'get() return byte is
   var byte tmp = _minix_last_error
   _minix_last_error = 0
   return tmp
end function

-- -----------------
-- DATA STRUCTURE -- 
-- -----------------

-- Super Block parameters --
record minix_superblock is
   word num_inodes
   word num_zones_v1
   word num_inode_bitmap_blocks
   word num_zone_bitmap_blocks
   word first_data_zone
   ;word log2 -- ignored because #blocks == #zones
   dword max_file_size
   word magic_number -- used to identify Minix version
   ;word padding -- ignored
   dword num_zones_v2
   -- following are custom variables implied by super-block
   dword first_inode_bitmap_block
   dword first_zone_bitmap_block
   dword first_inode_block
end record

-- Inode --
const word MINIX_INODE_ROOT_ID = 1

record minix_inode_mode is
   byte filetype
   bit isdir
   bit isfile
   bit issymlink
   bit iswhat  -- dunno...
   byte user
   byte group
   byte other
   byte all
   -- there are other bits, but I give up on them...
end record

record minix_inode is
   -- INTERNAL
   word id
   -- SPECS
   minix_inode_mode mode
   word num_links
   -- user/group owner
   word uid
   word gid
   dword filesize
   -- access/modification/change times
   dword atime
   dword mtime
   dword ctime
   -- where actual data lies
   dword zone[MINIX_MAX_DIRECT_ZONE_IDX + 1]
   dword indirect_zone
   dword double_indirect_zone
   dword triple_indirect_zone -- unimplemented (minix v3)
   -- STATE
   -- track type of zone being accessed (direct, indirect, double indirect)
   byte zone_type   
   -- track current direct zone in use or, if indirect, the address
   -- of data location within indirect zone
   word zone_idx
   word zone_dbl_idx
   -- track current index within current zone (0<x<block_size)
   word zone_content_idx
end record

-- Directory entry (dir listing)
record minix_dir_entry is
   word inode_num
   byte filename[MINIX_MAX_FILENANE_LEN]
end record

-- File descriptor
record minix_fd is
   byte mode      -- read/write/...
   dword read     
   minix_inode inode
end record

-- ----------
-- Globals --
-- ----------

var dword minix_curzone
var byte minix_curzonetab[4] at minix_curzone

-- super-block
var minix_superblock minix_sb
-- store current inode lib is working on
-- (used to avoid passing inode in proc signature
-- which costs a lot...).
-- Note: this starts to look like a file descriptor
;;var minix_inode minix_curinode
var minix_fd minix_curfd

-- move to block number and open read access on underlying storage
procedure minix_open_block(dword in num) is
   -- TODO: check if block number is within memory storage bound !
   var dword addr = MINIX_STORAGE_BLOCK_PER_BLOCK * num
   minix_goto_address(addr)
end procedure

-- move to block number, then to byte number within the block
procedure minix_open_block_byte(dword in blocknum, word in bytenum) is
   minix_open_block(blocknum)
   var byte _trash
   for bytenum loop
      _trash = minix_data_byte
   end loop
end procedure

-- Read Super-Block and fill record
procedure minix_read_super_block(bit in check_data_zone) is
   pragma inline

   minix_open_block(1)

   var dword data
   var byte datatab[4] at data
   -- read number of inodes
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   minix_sb.num_inodes = word(data)
   -- read number of zones (Minix v1)
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   minix_sb.num_zones_v1 = word(data)
   -- read number of inode bitmap blocks
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   minix_sb.num_inode_bitmap_blocks = word(data)
   -- read number of zone bitmap blocks
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   minix_sb.num_zone_bitmap_blocks = word(data)
   -- read first data zone (it's a block number)
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   minix_sb.first_data_zone = word(data)
   -- log2 field is ignored
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   -- read maximum file size
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   minix_sb.max_file_size = data
   -- read magic number (only one Minix currently supported)
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   minix_sb.magic_number = word(data)
   if minix_sb.magic_number != MINIX2_SUPER_MAGIC2 then
      minix_last_error = MINIX_ERR_BAD_MAGIC_NUMBER
   end if
   -- padding field is ignored
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   -- read number of zones (Minix v2)
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   minix_sb.num_zones_v2 = data

   -- compute location of first inode
   -- Inode bitmap blocks are located just after super-block
   minix_sb.first_inode_bitmap_block = 2
   -- Zone bitmap  blocks are located just after inode bitmap blocks
   minix_sb.first_zone_bitmap_block = minix_sb.first_inode_bitmap_block + minix_sb.num_inode_bitmap_blocks
   -- Then inode themselves...
   minix_sb.first_inode_block = minix_sb.first_zone_bitmap_block + minix_sb.num_zone_bitmap_blocks

   if check_data_zone == true then
      -- Then actual zone block (where data lies). Stored in super-block, just
      -- perform a sanity check
      var dword computed_data_zone = minix_sb.first_inode_block + (((dword(minix_sb.num_inodes) + 1) * MINIX_BYTES_PER_INODE)  / MINIX_BYTES_PER_BLOCK)
      if minix_sb.first_data_zone != computed_data_zone then
         minix_last_error = MINIX_ERR_BAD_ZONE_LOCATION
      end if
   end if

   minix_close_block()
   
end procedure

function minix_get_inode(word in inode_num) return minix_inode is
   -- inodes are 64-bytes long, so there can be multiple inodes on one block
   -- /!\ inode n°0 doesn't exist (and it's a special value)
   var dword byteaddr = (minix_sb.first_inode_block * MINIX_BYTES_PER_BLOCK) + ((inode_num - 1) * MINIX_BYTES_PER_INODE)
   var dword blockaddr = byteaddr / MINIX_BYTES_PER_BLOCK
   var word remaining = word(byteaddr - (blockaddr * MINIX_BYTES_PER_BLOCK))

   minix_open_block_byte(blockaddr,remaining)

   var minix_inode inode
   -- internal
   inode.id = inode_num

   var dword data
   var byte datatab[4] at data
   -- read number of inodes
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   
   -- read file/dir/symlink bit
   -- init values (if given inode record has already been used
   -- it may be polluted by previous data)
   inode.mode.isfile = false
   inode.mode.isdir = false
   inode.mode.issymlink = false
   inode.mode.iswhat = false

   inode.mode.filetype = (datatab[1] & 0b_1111_0000) >> 4
   if inode.mode.filetype == 0b_1000 then
       inode.mode.isfile = true
   elsif inode.mode.filetype == 0b_0100 then
       inode.mode.isdir = true
   elsif inode.mode.filetype == 0b_1010 then
       inode.mode.issymlink = true
   else
       inode.mode.iswhat = true
   end if

   -- read augo rwx bits
   inode.mode.all = (datatab[1] & 0b_0000_1110) >> 1
   inode.mode.user = byte((word(data) & 0b_0000_0001_1100_0000) >> 6)
   inode.mode.group = (datatab[0] & 0b_0011_1000) >> 3
   inode.mode.other = datatab[0] & 0b_0000_0111

   -- read number of links
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   inode.num_links = word(data)
   
   -- read UID/GID
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   inode.uid = word(data)
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   inode.gid= word(data)
   
   -- File size
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   inode.filesize = data

   -- atime
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   inode.atime = data

   -- mtime
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   inode.mtime = data

   -- ctime
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   inode.ctime = data

   -- zone0
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   inode.zone[0] = data

   -- zone1
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   inode.zone[1] = data

   -- zone2
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   inode.zone[2] = data

   -- zone3
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   inode.zone[3] = data

   -- zone4
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   inode.zone[4] = data

   -- zone5
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   inode.zone[5] = data

   -- zone6
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   inode.zone[6] = data

   -- indirect zone
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   inode.indirect_zone = data

   -- double indirect zone
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   inode.double_indirect_zone = data

   -- triple indirect zone
   -- TODO: not used for now, will be with v3
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   inode.triple_indirect_zone = data

   minix_close_block()

   -- init state
   inode.zone_type = MINIX_ZONE_DIRECT
   -- Zone indexes serve different purpose, depending on data is
   -- accessed with direct data zones, indirect data zones, or double
   -- indirect data zones. To save memory, some indexes are used to track
   -- states on zones not related to their name !

   -- track direct and indirect zone locations.
   -- Init this way so it will rollover to 0 when direct zone is accessed. 
   -- Increment one by one when in direct zone, then 4 by 4 when in indirect
   inode.zone_idx = 0xFFFF         
   -- track double indirect locations.
   -- Init this way so rollover to 0 when first accessed. Increment
   -- 4 by 4 as always used in indirect zones
   inode.zone_dbl_idx = 0xFFFC
   -- track content location within a zone.
   -- Init this way so it will trigger a move to next zone 
   -- ie. first data zone (save one "if" test)
   inode.zone_content_idx = 0x0400

   return inode

end function

procedure minix_close() is
   -- TODO: write new inode state
   minix_close_block()
end procedure

-- move to next data zone, being direct, indirect ou double
-- indirect
procedure minix_next_zone() is

   -- reset zone content
   minix_curfd.inode.zone_content_idx = 0

   -- do we need to switch to indirect zone ?
   if minix_curfd.inode.zone_type == MINIX_ZONE_DIRECT then
      if minix_curfd.inode.zone_idx == MINIX_MAX_DIRECT_ZONE_IDX then
         minix_curfd.inode.zone_type = MINIX_ZONE_INDIRECT
         -- now will track address location within 
         -- indirect zone and will rollover to 0
         minix_curfd.inode.zone_idx = 0xFFFC
      end if
   end if

   -- do we need to switch to double indirect zone ?
   if minix_curfd.inode.zone_type == MINIX_ZONE_INDIRECT then
      if minix_curfd.inode.zone_idx == MINIX_MAX_INDIRECT_ZONE_IDX then
         minix_curfd.inode.zone_type = MINIX_ZONE_DOUBLE_INDIRECT
         -- now will track address location within 
         -- indirect zone and will rollover to 0
         minix_curfd.inode.zone_idx = 0x03FC
      end if
   end if

   -- triple/double/single indirect zones
   -- Single indirect zone logic is comprised with double indirect zone logic
   -- (and same for triple indirect zones) that's why tests are ">="
   if minix_curfd.inode.zone_type >= MINIX_ZONE_DOUBLE_INDIRECT then
      -- do we need to switch to the next single indirect zone ?
      if minix_curfd.inode.zone_idx == MINIX_MAX_INDIRECT_ZONE_IDX then
         -- increment by size of dword, since data locations are 32-bits long
         minix_curfd.inode.zone_dbl_idx = minix_curfd.inode.zone_dbl_idx + 4
         minix_curfd.inode.zone_idx = 0xFFFC -- rollover to 0 when accessing single indirect
         minix_close_block()
         minix_open_block_byte(minix_curfd.inode.double_indirect_zone,minix_curfd.inode.zone_dbl_idx)
         -- read indirect zone address
         minix_curzonetab[0] = minix_data_byte
         minix_curzonetab[1] = minix_data_byte
         minix_curzonetab[2] = minix_data_byte
         minix_curzonetab[3] = minix_data_byte
         -- and replace previous indirect location
         minix_curfd.inode.indirect_zone = minix_curzone
      end if

   end if

   if minix_curfd.inode.zone_type >= MINIX_ZONE_INDIRECT then
      -- increment by size of dword, since data locations are 32-bits long
      minix_curfd.inode.zone_idx = minix_curfd.inode.zone_idx + 4
      minix_close_block()
      minix_open_block_byte(minix_curfd.inode.indirect_zone,minix_curfd.inode.zone_idx)
      -- read indirect zone address
      minix_curzonetab[0] = minix_data_byte
      minix_curzonetab[1] = minix_data_byte
      minix_curzonetab[2] = minix_data_byte
      minix_curzonetab[3] = minix_data_byte
      -- and move to this location
      minix_close_block()
      minix_open_block(minix_curzone)
   end if

   if minix_curfd.inode.zone_type == MINIX_ZONE_DIRECT then
      minix_curfd.inode.zone_idx = minix_curfd.inode.zone_idx + 1
      minix_curzone = minix_curfd.inode.zone[minix_curfd.inode.zone_idx]
      minix_close_block()
      minix_open_block(minix_curzone)
   end if
end procedure

-- walk over memory zones given, returning content
-- byte by byte. firt walk over direct zones, then 
-- swith indirect then double indirect zones. Keep
-- track of progress within inode
function minix_read() return byte is

   if minix_curfd.read == minix_curfd.inode.filesize then
      return 0
   end if

   -- need to move to next data zone ?
   -- Note: we pre-increment zone_content_idx, this means content idx grows 
   -- from to 1024. This avoids to save read byte in a variable, increment,
   -- then return read byte.
   if minix_curfd.inode.zone_content_idx == MINIX_BYTES_PER_BLOCK then
       minix_next_zone() -- on first call will rollover to zone[0]
   end if

   -- adjust current content index within the zone to next byte
   minix_curfd.inode.zone_content_idx = minix_curfd.inode.zone_content_idx + 1
   minix_curfd.read = minix_curfd.read + 1

   return minix_data_byte

end function

procedure minix_open(word in inode_num) is
   pragma inline
   minix_curfd.inode = minix_get_inode(inode_num)
   minix_curfd.read = 0
end procedure
-- for the beauty of the geste
alias minix_cdi is minix_open

-- move to byte bytenum within a file
-- Notes: assuming file was just opened, no data read
procedure minix_seek(dword in bytenum) is
   -- bytenum is the byte number *from* which data will be accessed, 
   -- so we need to move just before
   bytenum = bytenum - 1
   var dword blocknum = bytenum / MINIX_BYTES_PER_BLOCK
   var word remaining = byte(bytenum - (blocknum * MINIX_BYTES_PER_BLOCK))

   -- TODO: optimize this crap ! this currently just walk over *all*
   -- zones until the correct one...
   -- Notes: first block has index 0
   for blocknum  + 1 loop
      minix_next_zone()
   end loop

   -- move within block
   var byte _trash
   for remaining loop
      _trash = minix_data_byte
   end loop

   minix_curfd.read = bytenum

end procedure

-- list current working directory (cwd), returning a 
-- directory entry each time it's called, until no more
-- entry found.
function minix_next_entry'get() return minix_dir_entry is

   var minix_dir_entry entry
   entry.inode_num = 0
   entry.filename[0] = 0

   -- now read directory entry
   var byte counter
   var word data
   var byte datatab[2] at data
   -- read number of inodes
   datatab[0] = minix_read()
   datatab[1] = minix_read()
   -- is there an entry ? (inode #0 is impossible by specs)
   if data == 0 then
      minix_close()
   else
      entry.inode_num = data
      for MINIX_MAX_FILENANE_LEN using counter loop
         entry.filename[counter] = minix_read()
      end loop
   end if

   return entry

end function

procedure minix_init(bit in check) is
   pragma inline
   minix_read_super_block(check)
   -- ...
end procedure


-- -----------------
-- DEBUG/DEV CODE --
-- -----------------

if defined(minix_print_carrier) then

include print

-- Messages
procedure minix_dev_print_super_block() is

   const byte STR_READ_SUPER_BLOCK[] = "Super Block"
   const byte STR_NUMBER_OF_NODES[] = "# nodes: "
   const byte STR_NUMBER_OF_ZONES_V1[] = "# zones (v1): "
   const byte STR_NUMBER_OF_INODE_BITMAP_BLOCKS[] = "# inode bitmap blocks: "
   const byte STR_NUMBER_OF_ZONE_BITMAP_BLOCKS[] = "# zone bitmap blocks: "
   const byte STR_1ST_DATA_ZONE [] = "@ 1st data zone: "
   const byte STR_MAX_FILE_SIZE [] = "Max file size: "
   const byte STR_MAGIC_NUMBER[] = "Magic #: "
   const byte STR_NUMBER_OF_ZONES_V2[] = "# zones (v2): "
   const byte STR_1ST_INODE_BP_BLOCK[] = "@ 1st inode bitmap block: "
   const byte STR_1ST_ZONE_BP_BLOCK[] = "@ 1st zone bitmap block: "
   const byte STR_1ST_INODE_BLOCK[] = "@ 1st inode block: "
   ;;const byte STR_1ST_DATA_ZONE_COMPUTED[] = "@ 1st data zone (computed): "

   print_string(minix_print_carrier,STR_READ_SUPER_BLOCK)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_NUMBER_OF_NODES)
   print_word_hex(minix_print_carrier,minix_sb.num_inodes)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_NUMBER_OF_ZONES_V1)
   print_word_hex(minix_print_carrier,minix_sb.num_zones_v1)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_NUMBER_OF_INODE_BITMAP_BLOCKS)
   print_word_hex(minix_print_carrier,minix_sb.num_inode_bitmap_blocks)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_NUMBER_OF_ZONE_BITMAP_BLOCKS)
   print_word_hex(minix_print_carrier,minix_sb.num_zone_bitmap_blocks)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_1ST_DATA_ZONE)
   print_word_hex(minix_print_carrier,minix_sb.first_data_zone)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_MAX_FILE_SIZE)
   print_dword_hex(minix_print_carrier,minix_sb.max_file_size)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_MAGIC_NUMBER)
   print_word_hex(minix_print_carrier,minix_sb.magic_number)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_NUMBER_OF_ZONES_V2)
   print_dword_hex(minix_print_carrier,minix_sb.num_zones_v2)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_1ST_INODE_BP_BLOCK)
   print_dword_hex(minix_print_carrier,minix_sb.first_inode_bitmap_block)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_1ST_ZONE_BP_BLOCK)
   print_dword_hex(minix_print_carrier,minix_sb.first_zone_bitmap_block)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_1ST_INODE_BLOCK)
   print_dword_hex(minix_print_carrier,minix_sb.first_inode_block)
   print_crlf(minix_print_carrier)

end procedure

procedure minix_dev_print_error() is
   const byte STR_ERROR[] = "Error # "
   print_string(minix_print_carrier,STR_ERROR)
   print_byte_binary(minix_print_carrier,minix_last_error)
   print_crlf(minix_print_carrier)
end procedure

procedure minix_dev_print_inode(minix_inode in inode) is
   const byte STR_INODE[] = "Inode #"
   const byte STR_MODE_FILETYPES[] = "Filetype: "
   const byte STR_MODE_FILE[] = "file"
   const byte STR_MODE_DIR[] = "dir"
   const byte STR_MODE_SYMLINK[] = "symlink"
   const byte STR_MODE_WHAT[] = "dunno"
   const byte STR_MODE_PERMS[] = "Permissions: "
   const byte STR_MODE_PERM_ALL[] = " - all: "
   const byte STR_MODE_PERM_USER[] = " - user: "
   const byte STR_MODE_PERM_GROUP[] = " - group: "
   const byte STR_MODE_PERM_OTHER[] = " - other: "
   const byte STR_NUM_LINKS[] = "# links: "
   const byte STR_UID[] = "UID: "
   const byte STR_GID[] = "GID: "
   const byte STR_FILESIZE[] = "File size: "
   const byte STR_ATIME[] = "Acess time: "
   const byte STR_MTIME[] = "Modification time: "
   const byte STR_CTIME[] = "Status change time: "
   const byte STR_ZONE0[] = "Zone 0: "
   const byte STR_ZONE1[] = "Zone 1: "
   const byte STR_ZONE2[] = "Zone 2: "
   const byte STR_ZONE3[] = "Zone 3: "
   const byte STR_ZONE4[] = "Zone 4: "
   const byte STR_ZONE5[] = "Zone 5: "
   const byte STR_ZONE6[] = "Zone 6: "
   const byte STR_IND_ZONE[] = "Indirect Zone: "
   const byte STR_DBL_IND_ZONE[] = "Double indirect Zone: "
   ;;const byte STR_TRPL_IND_ZONE[] = "Triple indirect Zone: "
   
   print_string(minix_print_carrier,STR_INODE)
   print_word_dec(minix_print_carrier,inode.id)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_MODE_FILETYPES)
   if inode.mode.isfile then
      print_string(minix_print_carrier,STR_MODE_FILE)
   elsif inode.mode.isdir then
      print_string(minix_print_carrier,STR_MODE_DIR)
   elsif inode.mode.issymlink then
      print_string(minix_print_carrier,STR_MODE_SYMLINK)
   else
      print_string(minix_print_carrier,STR_MODE_WHAT)
   end if
   minix_print_carrier = " "
   minix_print_carrier = "("
   print_word_dec(minix_print_carrier,inode.mode.filetype)
   minix_print_carrier = ")"
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_MODE_PERMS)
   print_crlf(minix_print_carrier)
   print_string(minix_print_carrier,STR_MODE_PERM_ALL)
   print_byte_dec(minix_print_carrier,inode.mode.all)
   print_crlf(minix_print_carrier)
   print_string(minix_print_carrier,STR_MODE_PERM_USER)
   print_byte_dec(minix_print_carrier,inode.mode.user)
   print_crlf(minix_print_carrier)
   print_string(minix_print_carrier,STR_MODE_PERM_GROUP)
   print_byte_dec(minix_print_carrier,inode.mode.group)
   print_crlf(minix_print_carrier)
   print_string(minix_print_carrier,STR_MODE_PERM_OTHER)
   print_byte_dec(minix_print_carrier,inode.mode.other)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_NUM_LINKS)
   print_word_dec(minix_print_carrier,inode.num_links)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_UID)
   print_word_dec(minix_print_carrier,inode.uid)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_GID)
   print_word_dec(minix_print_carrier,inode.gid)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_FILESIZE)
   print_dword_dec(minix_print_carrier,inode.filesize)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_ATIME)
   print_dword_dec(minix_print_carrier,inode.atime)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_MTIME)
   print_dword_dec(minix_print_carrier,inode.mtime)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_CTIME)
   print_dword_dec(minix_print_carrier,inode.ctime)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_ZONE0)
   print_dword_hex(minix_print_carrier,inode.zone[0])
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_ZONE1)
   print_dword_hex(minix_print_carrier,inode.zone[1])
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_ZONE2)
   print_dword_hex(minix_print_carrier,inode.zone[2])
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_ZONE3)
   print_dword_hex(minix_print_carrier,inode.zone[3])
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_ZONE4)
   print_dword_hex(minix_print_carrier,inode.zone[4])
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_ZONE5)
   print_dword_hex(minix_print_carrier,inode.zone[5])
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_ZONE6)
   print_dword_hex(minix_print_carrier,inode.zone[6])
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_IND_ZONE)
   print_dword_hex(minix_print_carrier,inode.indirect_zone)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_DBL_IND_ZONE)
   print_dword_hex(minix_print_carrier,inode.double_indirect_zone)
   print_crlf(minix_print_carrier)

end procedure

procedure minix_dev_print_dir_entry(minix_dir_entry in entry) is
   const byte STR_ENTRY[] = "Inode #"
   
   print_string(minix_print_carrier,STR_ENTRY)
   print_word_dec(minix_print_carrier,entry.inode_num)
   minix_print_carrier = " "

   -- assuming at least one char in filename...
   var byte counter
   var byte char
   for MINIX_MAX_FILENANE_LEN using counter loop
      char = entry.filename[counter]
      if char != 0x00 then
         minix_print_carrier = char
      else
         exit loop
      end if
   end loop
   
end procedure

procedure minix_cati(word in inode_num) is
   minix_open(inode_num)
   while minix_curfd.read != minix_curfd.inode.filesize loop
      minix_print_carrier = minix_read()
   end loop
   minix_close()
end procedure

-- parially print content. When content is changing, display 
-- zone_type|zone_idx|zone_dbl_idx|zone_content_idx|address|indirect|dbl_indirect|read/filesize
-- and then one content char
procedure minix_dev_cati(word in inode_num) is
   var byte char = 0
   var byte charprev = 0
   minix_open(inode_num)
   while minix_curfd.read != minix_curfd.inode.filesize loop
      char = minix_read()
      if char != charprev then
         charprev = char
         print_byte_binary(minix_print_carrier,minix_curfd.inode.zone_type)
         minix_print_carrier = "|"
         print_word_hex(minix_print_carrier,minix_curfd.inode.zone_idx)
         minix_print_carrier = "|"
         print_word_hex(minix_print_carrier,minix_curfd.inode.zone_dbl_idx)
         minix_print_carrier = "|"
         print_word_hex(minix_print_carrier,minix_curfd.inode.zone_content_idx)
         minix_print_carrier = "|"
         print_dword_hex(minix_print_carrier,minix_curzone)
         minix_print_carrier = "|"
         print_dword_hex(minix_print_carrier,minix_curfd.inode.indirect_zone)
         minix_print_carrier = "|"
         print_dword_hex(minix_print_carrier,minix_curfd.inode.double_indirect_zone)
         minix_print_carrier = "|"
         print_dword_dec(minix_print_carrier,minix_curfd.read)
         minix_print_carrier = "/"
         print_dword_dec(minix_print_carrier,minix_curfd.inode.filesize)
         minix_print_carrier = " "
         minix_print_carrier = char
         print_crlf(minix_print_carrier)
      end if
   end loop
   minix_close()
end procedure

procedure minix_lsi(word in inode_num) is
   var minix_dir_entry entry
   minix_cdi(inode_num)
   entry = minix_next_entry
   while entry.inode_num != 0 loop
      minix_dev_print_dir_entry(entry)
      print_crlf(serial_hw_data)
      entry = minix_next_entry 
   end loop
end procedure 

end if
