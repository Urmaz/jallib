-- Title: Minix v2 filesystem implementation
-- Author: Sebastien Lelong, Copyright (c) 2011, all rights reserved.
-- Adapted-by:
-- Compiler: 2.4o
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: Minix v2 implementation
-- Partitions aren't supported, so you have to create a filesystem on the whole
-- available memory. Typically, instead of "mkfs.minix -v /dev/sdc1", you'll
-- have to "mkfs.minix -v /dev/sdc" (and remove sdc1 partition with fdisk)
-- Some useful commands:
--  - fsck.minix -f -v -s /dev/sdc
--       will print Super-Block and some other information about files, dirs, state
--  - hexdump -C /dev/sdc
--       will dump Minix FS content (only changing lines)
--  - hexdump -v -C /dev/sdc
--       will do the same, but dump all lines, even if identical
--
-- Notes:
--



-- Magic numbers used to idenfity filesystem version
const word MINIX_SUPER_MAGIC   = 0x137F   -- original minix fs
const word MINIX_SUPER_MAGIC2  = 0x138F   -- minix fs, 30 char names
const word MINIX2_SUPER_MAGIC  = 0x2468   -- minix V2 fs
const word MINIX2_SUPER_MAGIC2 = 0x2478   -- minix V2 fs, 30 char names
const word MINIX3_SUPER_MAGIC  = 0x4D5A   -- minix V3 fs

const word MINIX_BYTES_PER_BLOCK = 0x400  -- 1KB per block
const word MINIX_BYTES_PER_INODE = 0x40   -- 64B per inode
-- Super Block is one block after boot block
const word MINIX_BOOT_BLOCK_ADDRESS = 0x00
const word MINIX_SUPER_BLOCK_ADDRESS = MINIX_BOOT_BLOCK_ADDRESS + MINIX_BYTES_PER_BLOCK

-- Error constants. Following "mkfs" convention, errors are added, so
-- minix_last_error can embed several errors
const byte MINIX_ERR_NONE = 0b_0000_0000
const byte MINIX_ERR_BAD_MAGIC_NUMBER     = 0b_0000_0001 -- magic number unsupported
const byte MINIX_ERR_BAD_ZONE_LOCATION    = 0b_0000_0010 -- something is wrong about declared and computed data location

-- Auto-resetting variable: errors are added, and when read, reset to 0
var byte _minix_last_error = MINIX_ERR_NONE
procedure minix_last_error'put(byte in val) is
   _minix_last_error = _minix_last_error + val
end procedure
function minix_last_error'get() return byte is
   var byte tmp = _minix_last_error
   _minix_last_error = 0
   return tmp
end function

-- -------------------------
-- Super Block parameters --
-- -------------------------
record minix_superblock is
   word num_inodes
   word num_zones_v1
   word num_inode_bitmap_blocks
   word num_zone_bitmap_blocks
   word first_data_zone
   ;word log2 -- ignored because #blocks == #zones
   dword max_file_size
   word magic_number -- used to identify Minix version
   ;word padding -- ignored
   dword num_zones_v2
   -- following are custom variable implied by super-block
   dword first_inode_bitmap_block
   dword first_zone_bitmap_block
   dword first_inode_block
end record

-- --------
-- Inode --
-- --------
const word MINIX_INODE_ROOT_ID = 1

record minix_inode_mode is
   bit isdir
   bit isfile
   bit issymlink
   bit iswhat  -- dunno...
   byte user
   byte group
   byte other
   byte all
   -- there are other bits, but I give up on them...
end record

record minix_inode is
   minix_inode_mode mode
end record

-- Globals
var minix_superblock minix_sb
const dword _current_address = 0


procedure minix_goto_block(dword in num) is
   -- sd_card lib assumes 512-bytes / sector
   var dword addr = 2 * num
   minix_set_address(addr)
end procedure

-- Read Super-Block and fill record
procedure minix_read_super_block(bit in check_data_zone) is

   minix_goto_block(1)

   var dword data
   var byte datatab[4] at data
   -- read number of inodes
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   minix_sb.num_inodes = word(data)
   -- read number of zones (Minix v1)
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   minix_sb.num_zones_v1 = word(data)
   -- read number of inode bitmap blocks
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   minix_sb.num_inode_bitmap_blocks = word(data)
   -- read number of zone bitmap blocks
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   minix_sb.num_zone_bitmap_blocks = word(data)
   -- read first data zone (it's a block number)
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   minix_sb.first_data_zone = word(data)
   -- log2 field is ignored
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   -- read maximum file size
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   minix_sb.max_file_size = data
   -- read magic number (only one Minix currently supported)
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   minix_sb.magic_number = word(data)
   if minix_sb.magic_number != MINIX2_SUPER_MAGIC2 then
      minix_last_error = MINIX_ERR_BAD_MAGIC_NUMBER
   end if
   -- padding field is ignored
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   -- read number of zones (Minix v2)
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   datatab[2] = minix_data_byte
   datatab[3] = minix_data_byte
   minix_sb.num_zones_v2 = data

   -- compute location of first inode
   -- Inode bitmap blocks are located just after super-block
   minix_sb.first_inode_bitmap_block = 2
   -- Zone bitmap  blocks are located just after inode bitmap blocks
   minix_sb.first_zone_bitmap_block = minix_sb.first_inode_bitmap_block + minix_sb.num_inode_bitmap_blocks
   -- Then inode themselves...
   minix_sb.first_inode_block = minix_sb.first_zone_bitmap_block + minix_sb.num_zone_bitmap_blocks

   if check_data_zone == true then
      -- Then actual zone block (where data lies). Stored in super-block, just
      -- perform a sanity check
      var dword computed_data_zone = minix_sb.first_inode_block + (((dword(minix_sb.num_inodes) + 1) * MINIX_BYTES_PER_INODE)  / MINIX_BYTES_PER_BLOCK)
      if minix_sb.first_data_zone != computed_data_zone then
         minix_last_error = MINIX_ERR_BAD_ZONE_LOCATION
      end if
   end if

   minix_stop_read()
   
end procedure

function minix_get_inode(word in inode_num) return minix_inode is
   -- inodes are 64-bytes long, so there can be multiple inodes on one block
   -- /!\ inode nÂ°0 doesn't exist (and it's a special value)
   var dword byteaddr = (minix_sb.first_inode_block * MINIX_BYTES_PER_BLOCK) + ((inode_num - 1) * MINIX_BYTES_PER_INODE)
   var dword blockaddr = byteaddr / MINIX_BYTES_PER_BLOCK
   minix_goto_block(blockaddr)
   -- dummy read bytes until we reach inode address
   var dword remaining = byteaddr - (blockaddr * MINIX_BYTES_PER_BLOCK)
   minix_print_carrier = "!"
   print_dword_hex(minix_print_carrier,remaining)
   var byte _trash
   for remaining loop
      _trash = minix_data_byte
   end loop

   var minix_inode inode

   var dword data
   var byte datatab[4] at data
   -- read number of inodes
   datatab[0] = minix_data_byte
   datatab[1] = minix_data_byte
   print_word_binary(minix_print_carrier,word(data))
   print_crlf(minix_print_carrier)
   
   -- read file/dir/symlink bit
   if (datatab[1] & 0b_10000000) == 0b_1000_0000 then
       inode.mode.isfile = true
   end if
   if (datatab[1] & 0b_01000000) == 0b_0100_0000 then
       inode.mode.isdir = true
   end if
   if (datatab[1] & 0b_00100000) == 0b_0010_0000  then
       inode.mode.issymlink = true
   end if
   if (datatab[1] & 0b_00010000) == 0b_0001_0000 then
       inode.mode.iswhat = true
   end if

   -- read augo rwx bits
   inode.mode.all = (datatab[1] & 0b_0000_1110) >> 1
   inode.mode.user = byte((word(data) & 0b_0000_0001_1100_0000) >> 6)
   inode.mode.group = (datatab[0] & 0b_0011_1000) >> 3
   inode.mode.other = datatab[0] & 0b_0000_0111

   minix_stop_read()

   return inode

end function


-- -----------------
-- DEBUG/DEV CODE --
-- -----------------

if defined(minix_print_carrier) then

-- Messages
procedure minix_print_super_block() is

   const byte STR_READ_SUPER_BLOCK[] = "Super Block"
   const byte STR_NUMBER_OF_NODES[] = "# nodes: "
   const byte STR_NUMBER_OF_ZONES_V1[] = "# zones (v1): "
   const byte STR_NUMBER_OF_INODE_BITMAP_BLOCKS[] = "# inode bitmap blocks: "
   const byte STR_NUMBER_OF_ZONE_BITMAP_BLOCKS[] = "# zone bitmap blocks: "
   const byte STR_1ST_DATA_ZONE [] = "@ 1st data zone: "
   const byte STR_MAX_FILE_SIZE [] = "Max file size: "
   const byte STR_MAGIC_NUMBER[] = "Magic #: "
   const byte STR_NUMBER_OF_ZONES_V2[] = "# zones (v2): "
   const byte STR_1ST_INODE_BP_BLOCK[] = "@ 1st inode bitmap block: "
   const byte STR_1ST_ZONE_BP_BLOCK[] = "@ 1st zone bitmap block: "
   const byte STR_1ST_INODE_BLOCK[] = "@ 1st inode block: "
   ;;const byte STR_1ST_DATA_ZONE_COMPUTED[] = "@ 1st data zone (computed): "

   print_string(minix_print_carrier,STR_READ_SUPER_BLOCK)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_NUMBER_OF_NODES)
   print_word_hex(minix_print_carrier,minix_sb.num_inodes)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_NUMBER_OF_ZONES_V1)
   print_word_hex(minix_print_carrier,minix_sb.num_zones_v1)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_NUMBER_OF_INODE_BITMAP_BLOCKS)
   print_word_hex(minix_print_carrier,minix_sb.num_inode_bitmap_blocks)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_NUMBER_OF_ZONE_BITMAP_BLOCKS)
   print_word_hex(minix_print_carrier,minix_sb.num_zone_bitmap_blocks)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_1ST_DATA_ZONE)
   print_word_hex(minix_print_carrier,minix_sb.first_data_zone)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_MAX_FILE_SIZE)
   print_dword_hex(minix_print_carrier,minix_sb.max_file_size)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_MAGIC_NUMBER)
   print_word_hex(minix_print_carrier,minix_sb.magic_number)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_NUMBER_OF_ZONES_V2)
   print_dword_hex(minix_print_carrier,minix_sb.num_zones_v2)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_1ST_INODE_BP_BLOCK)
   print_dword_hex(minix_print_carrier,minix_sb.first_inode_bitmap_block)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_1ST_ZONE_BP_BLOCK)
   print_dword_hex(minix_print_carrier,minix_sb.first_zone_bitmap_block)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_1ST_INODE_BLOCK)
   print_dword_hex(minix_print_carrier,minix_sb.first_inode_block)
   print_crlf(minix_print_carrier)

end procedure

procedure minix_print_error() is
   const byte STR_ERROR[] = "Error # "
   print_string(minix_print_carrier,STR_ERROR)
   print_byte_binary(minix_print_carrier,minix_last_error)
   print_crlf(minix_print_carrier)
end procedure

procedure minix_print_inode(minix_inode in inode) is
   const byte STR_INODE[] = "Inode"
   const byte STR_MODE_FILETYPES[] = "Filetype: "
   const byte STR_MODE_PERMS[] = "Permissions: "
   const byte STR_MODE_PERM_ALL[] = " - all: "
   const byte STR_MODE_PERM_USER[] = " - user: "
   const byte STR_MODE_PERM_GROUP[] = " - group: "
   const byte STR_MODE_PERM_OTHER[] = " - other: "
   const byte STR_MODE_FILE[] = "file"
   const byte STR_MODE_DIR[] = "dir"
   const byte STR_MODE_SYMLINK[] = "symlink"
   const byte STR_MODE_WHAT[] = "dunno"

   print_string(minix_print_carrier,STR_INODE)
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_MODE_FILETYPES)
   if inode.mode.isfile then
      print_string(minix_print_carrier,STR_MODE_FILE)
   elsif inode.mode.isdir then
      print_string(minix_print_carrier,STR_MODE_DIR)
   elsif inode.mode.issymlink then
      print_string(minix_print_carrier,STR_MODE_SYMLINK)
   else
      print_string(minix_print_carrier,STR_MODE_WHAT)
   end if
   print_crlf(minix_print_carrier)

   print_string(minix_print_carrier,STR_MODE_PERMS)
   print_crlf(minix_print_carrier)
   print_string(minix_print_carrier,STR_MODE_PERM_ALL)
   print_byte_dec(minix_print_carrier,inode.mode.all)
   print_crlf(minix_print_carrier)
   print_string(minix_print_carrier,STR_MODE_PERM_USER)
   print_byte_dec(minix_print_carrier,inode.mode.user)
   print_crlf(minix_print_carrier)
   print_string(minix_print_carrier,STR_MODE_PERM_GROUP)
   print_byte_dec(minix_print_carrier,inode.mode.group)
   print_crlf(minix_print_carrier)
   print_string(minix_print_carrier,STR_MODE_PERM_OTHER)
   print_byte_dec(minix_print_carrier,inode.mode.other)
   print_crlf(minix_print_carrier)


end procedure

end if
