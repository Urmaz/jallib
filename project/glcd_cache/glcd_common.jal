-- Title: glcd_common - generic routines for graphic lcd
-- Author: Stef Mientki, Serkan Ayyýldýz Copyright (c) 2006..2009, all rights reserved.
-- Adapted-by: Joep Suijs, Matthew Schinkel
-- Compiler: >=2.2
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Sources:
--
-- Description: Generic routines for graphic lcd
-- glcd_box
-- glcd_line
-- --
-- Defines a common API, a common interface, where several parameters and procedures remains
-- device specific and should be implemented in device library. Once interface is implemented,
-- many features come for "free". This common API is defined in glcd_common.jal and glcd_font.jal
-- --
-- In order to honor this common interface, and benefit its features, the following must be implemented
-- in device specific library:
--   * GLCD_X_PIXELS: (const) specifies display's width, in pixels
--   * GLCD_Y_SIZE: (const) specifies display's height, in pixels
--   * GLCD_COLOR_BITS: (const) specifies the number of supported colors (1 for black & white)
--   * glcd_pen_color: (var|const) specifies color of the pen
--   * glcd_background_color: (var|const) specifies the background color
--   * glcd_write_char(x,y,char): (proc) draw "char" at position (x,y). Required by glcd_font.jal.
--     this is the main procedure used to display characters. If not implemented, char-related features
--     won't be available (mainly font usage)
--   * glcd_write_pixel(x,y): (proc) assuming pen and background color previously set, draw
--     a pixel at position (x,y) using defined colors. This is the main procedure used by pixel-related
--     features, like drawing a line, circle, etc... In some cases, where glcd_write_char() can't be used
--     glcd_write_pixel() can also be used to draw chars. If not implemented, pixel-related features won't
--     be available.
--                                  
--
-- Notes:
--

-- set width of pixel x,y variables
if !defined(GLCD_X_PIXELS) then
   const GLCD_X_SIZE = 1
else
   if GLCD_X_PIXELS < 256 then
      const GLCD_X_SIZE = 1
   else
      const GLCD_X_SIZE = 2
   end if
end if
--
if !defined(GLCD_Y_PIXELS) then
   const GLCD_Y_SIZE = 1
else
   if GLCD_Y_PIXELS < 256 then
      const GLCD_Y_SIZE = 1
   else
      const GLCD_Y_SIZE = 2
   end if
end if

if !defined(GLCD_USE_BLOCK_WRITE) then
   const GLCD_USE_BLOCK_WRITE = FALSE
end if

-- set width of color variables
if !defined(GLCD_COLOR_BITS) then  -- 1 bit
   const GLCD_COLOR_SIZE = 1
else
   if GLCD_COLOR_BITS == 1 then    -- 1 bit
      const GLCD_COLOR_SIZE = 1
   elsif GLCD_COLOR_BITS == 16 then   -- 16 bit
      const GLCD_COLOR_SIZE = 2
   else
      pragma error "GLCD_COLOR_BITS VALUE NOT SUPPORTED"
   end if
end if

-- define foreground and background colors, if not defined already
if !defined(glcd_background_color) then
   const byte GLCD_BACKGROUND_COLOR = 0
end if
if !defined(GLCD_PEN_COLOR) then
   const GLCD_PEN_COLOR = 1
end if

-- variables for text positioning
var byte*GLCD_X_SIZE glcd_char_x_pos = 0;
var byte*GLCD_Y_SIZE glcd_char_y_pos = 0;

include glcd_font

--------------------------------------------------------------------------------
-- draw one character pixel by pixel. slowest method.
--
-- Requires this procedure to be defined within your glcd library
--    glcd_write_pixel - draw one pixel to glcd
--------------------------------------------------------------------------------
procedure glcd_write_char_pbp(byte*GLCD_X_SIZE in x,byte*GLCD_Y_SIZE in y,byte in value) is
   var byte*GLCD_COLOR_SIZE color = glcd_pen_color -- save pen color
   
   if _glcd_font_current_bit_direction == FONT_TOP_LEFT_HORIZONTAL then

      -- generic font printing (bit by bit)
      -- this will work for any glcd that has a lcd_write_pixel procedure
      -- currently only tested for with width of 8 or less, any height
      var word i,j,k
      var word step = 0
      
      ;for _glcd_font_current_byte_per_char using k loop -- wrong!
      for _glcd_font_current_height using k loop         -- right!
         -- get each byte from character
         var byte char_byte = glcd_font_lookup( (word(value - 32) * _glcd_font_current_byte_per_char) + k )
         var byte bit_y_address = 128 -- y bit mask
         
         -- get each bit from each character byte and print it to glcd
         for _glcd_font_current_width using j loop
            if( ( char_byte & bit_y_address) > 0 ) then
               glcd_pen_color = color
            else
               glcd_pen_color = glcd_background_color
            end if
            glcd_write_pixel(byte*GLCD_X_SIZE(x+j),byte*GLCD_Y_SIZE(y+k))
            bit_y_address = bit_y_address >> 1
         end loop
      end loop
      
   elsif _glcd_font_current_bit_direction == FONT_BOTTOM_LEFT_VERTICAL then
      -- generic font printing (bit by bit)
      -- this will work for any glcd that has a glcd_write_pixel procedure
      -- currently only works for with width of 8 or less, any height
      -- currently only tested for fonts 8x8 or smaller.
      var word i,j,k
      var word step = 0
      
      ;for _glcd_font_current_byte_per_char using k loop -- wrong!
      for _glcd_font_current_width using k loop          -- right!
         -- get each byte from character
         var byte char_byte = glcd_font_lookup( (word(value - 32) * _glcd_font_current_byte_per_char) + k )
         
         -- get each bit from each character byte and print it to glcd
         var byte bit_y_address = 1 -- y bit mask
         for _glcd_font_current_height using j loop
            if( ( char_byte & bit_y_address) > 0 ) then
               glcd_pen_color = color
            else
               glcd_pen_color = glcd_background_color
            end if
            glcd_write_pixel(byte*GLCD_X_SIZE(x+k),byte*GLCD_Y_SIZE(y+j))
            bit_y_address = bit_y_address << 1
         end loop
      end loop
   else
      -- not supported yet!
   end if
   glcd_pen_color = color -- restore pen color
end procedure

--------------------------------------------------------------------------------
-- draw one character with block write. Efficient font printing.
--
-- Only FONT_TOP_LEFT_HORIZONTAL is supported so far.
--
-- here's a list of procedures reqired in your glcd device library:
--    glcd_block_address - set start x,y and end x,y address
--    glcd_block_write_color - write data to each pixel in order
-- also must define this constant in your glcd device library and
-- set your most efficient font type.
--    const GLCD_BLOCK_WRITE_TYPE = FONT_TOP_LEFT_HORIZONTAL
--------------------------------------------------------------------------------
if GLCD_USE_BLOCK_WRITE == TRUE then
   procedure glcd_write_char_block(byte*GLCD_X_SIZE in x,byte*GLCD_Y_SIZE in y,byte in value) is
      if GLCD_BLOCK_WRITE_TYPE == FONT_TOP_LEFT_HORIZONTAL then
         -- this is the most eficient bit direction for this GLCD
         -- currently only works for fonts with width of 8 or less, any height
         var word i,j
         var word step = 0

         ;glcd_block_address(x,y,x+(_glcd_font_current_width-1),y+(_glcd_font_current_height - 1))
         glcd_block_set_address(x,y,x+(_glcd_font_current_width-1),y+(_glcd_font_current_height - 1))
         
         step = step + word(value-32)*_glcd_font_current_height;

         for _glcd_font_current_height using j loop
            for _glcd_font_current_width using i loop
               if( ( glcd_font_lookup(step) & (1<<((_glcd_font_current_width-1)-i)) ) != 0 ) then
                  ;glcd_block_write_color(glcd_pen_color)
                  glcd_block_write_color(glcd_pen_color)
               else
                  ;glcd_block_write_color(glcd_background_color)
                  glcd_block_write_color(glcd_background_color)
               end if
            end loop
            step = step + 1
         end loop
      else
         _error "GLCD_BLOCK_WRITE_TYPE NOT SUPPORTED"
      end if
   end procedure
end if

--------------------------------------------------------------------------------
-- Pseudo variable 'lcd' for writing characters.
--------------------------------------------------------------------------------
procedure glcd'put(byte in char) is
   if defined(FONT_AUTO_WRAP) then
      if FONT_AUTO_WRAP == TRUE then
         if glcd_char_x_pos > (GLCD_X_PIXELS - _glcd_font_current_width) then
            glcd_char_y_pos = glcd_char_y_pos + _glcd_font_current_height
            glcd_char_x_pos = 0
         end if
      end if
   end if
   
   -- custom font procedure defined in glcd device library
   if defined(glcd_write_char) then
      glcd_write_char(glcd_char_x_pos, glcd_char_y_pos, char)
   else
   
      -- a common efficient way to draw fonts.
      -- here's a list of procedures reqired in your glcd device library.
      --    glcd_block_address - set start x,y and end x,y address
      --    glcd_block_write_color - write data to each pixel in order
      if GLCD_USE_BLOCK_WRITE == TRUE then
         glcd_write_char_block(glcd_char_x_pos, glcd_char_y_pos, char)

      -- a common, but slow way to draw fonts.
      -- here's a list of procedures reqired in your glcd device library.
      --    glcd_write_pixel - draw one pixel to glcd
      else
         glcd_write_char_pbp(glcd_char_x_pos, glcd_char_y_pos, char)
      end if
   end if
   -- move the cursor
   glcd_char_x_pos = glcd_char_x_pos + _glcd_font_current_width
end procedure

--------------------------------------------------------------------------------
-- Clear screen and character position to the upper left corner: row 0, column 0)
-- If block writes are not supported by your glcd, it is highly recommended
-- that you define a custom define a glcd_clear_screen()
-- procedure within your glcd's library otherwise this procedure will clear
-- the screen pixel by pixel which is very slow.
--
-- here's a list of procedures reqired in your glcd device library:
--    glcd_block_address - set start x,y and end x,y address
--    glcd_block_write_color - write data to each pixel in order
-- also must define this constant in your glcd device library and
-- set your most efficient font type.
--    const GLCD_BLOCK_WRITE_TYPE = FONT_TOP_LEFT_HORIZONTAL
--------------------------------------------------------------------------------
if !defined(glcd_clear_screen) then
   procedure glcd_clear_screen() is
      -- fill using glcd's block write procedures
      if GLCD_USE_BLOCK_WRITE == TRUE then
         if GLCD_BLOCK_WRITE_TYPE == FONT_TOP_LEFT_HORIZONTAL then
            glcd_block_set_address(0,0,GLCD_X_PIXELS - 1,GLCD_Y_PIXELS - 1)
            for GLCD_Y_PIXELS loop
               for GLCD_X_PIXELS loop
                   glcd_block_write_color(glcd_background_color)
               end loop
            end loop
         else
            _error "GLCD_BLOCK_WRITE_TYPE NOT SUPPORTED"
         end if
      else
         var byte*GLCD_COLOR_SIZE color = glcd_pen_color
         var byte*GLCD_X_SIZE x
         var byte*GLCD_Y_SIZE y
         for GLCD_Y_PIXELS using y loop
            for GLCD_X_PIXELS using x loop
                glcd_pen_color = glcd_background_color
                glcd_write_pixel(x,y)
            end loop
         end loop
         glcd_pen_color = color
      end if
      
      glcd_char_x_pos = 0;
      glcd_char_y_pos = 0;
   end procedure
end if

--------------------------------------------------------------------------------
-- Set location of next character to write
--------------------------------------------------------------------------------
procedure glcd_char_goto(byte in x, byte in y) is
   glcd_char_x_pos = x
   glcd_char_y_pos = y
end procedure

--------------------------------------------------------------------------------
-- name        : glcd_ellipse( cx, cy, xradius, yradius, mode )
-- description : Bresenham ellipse plot
-- argument(s) : cx, cy -> 	center of the ellipse
--				       xradius, yradius -> x & y radius of the ellipse
--               mode -> off(erase), on or xor
-- return value: none
-- notes       : Would be nice to draw filled ellipses to.. :-)
-- Author      : Paul D'haene
--------------------------------------------------------------------------------
procedure glcd_ellipse(byte*GLCD_X_SIZE in cx,byte*GLCD_Y_SIZE in cy, byte in xradius,byte in yradius) is
   var sword xr = sword(xradius), yr = sword(yradius)
   var sword x = xr, y = 0
   var sword two_a_square = 2 * xr * xr
   var sword two_b_square = 2 * yr * yr
   var sword x_change = yr * yr * (1 - 2 * xr)
   var sword y_change = xr * xr
   var sword ellipse_error = 0
   var sword stopping_x = two_b_square * xr
   var sword stopping_y = 0
   
   while stopping_x >= stopping_y loop -- 1st set of points, Y' > -1
      glcd_write_pixel(byte(cx + x), byte(cy + y))
      glcd_write_pixel(byte(cx - x), byte(cy + y))
      glcd_write_pixel(byte(cx - x), byte(cy - y))
      glcd_write_pixel(byte(cx + x), byte(cy - y))
      
      y = y + 1
      stopping_y = stopping_y + two_a_square
      ellipse_error = ellipse_error + y_change
      y_change = y_change + two_a_square
      
      if (ellipse_error + ellipse_error + x_change) > 0 then
         x = x - 1
         stopping_x = stopping_x - two_b_square
         ellipse_error = ellipse_error + x_change
         x_change = x_change + two_b_square
      end if
   end loop
   -- 1st set done. start 2nd set of points
   x = 0
   y = yr
   x_change = yr * yr
   y_change = xr * xr * (1 - 2 * yr)
   ellipse_error = 0
   stopping_x = 0
   stopping_y = two_a_square * yr
   
   while stopping_x <= stopping_y loop -- 2st set of points, Y' < -1
      glcd_write_pixel(byte(cx + x), byte(cy + y))
      glcd_write_pixel(byte(cx - x), byte(cy + y))
      glcd_write_pixel(byte(cx - x), byte(cy - y))
      glcd_write_pixel(byte(cx + x), byte(cy - y))
      
      x = x + 1
      stopping_x = stopping_x + two_b_square
      ellipse_error = ellipse_error + x_change
      x_change = x_change + two_b_square
      
      if (ellipse_error + ellipse_error + y_change) > 0 then
         y = y - 1
         stopping_y = stopping_y - two_a_square
         ellipse_error = ellipse_error + y_change
         y_change = y_change + two_a_square
      end if
   end loop
end procedure

--------------------------------------------------------------------------------
-- name        : lcd_circle( cx, cy, radius, lcd_pen_color )
-- description : Bresenham circle draw
-- argument(s) : cx, cy -> 	center of the circle
--				       radius -> radius of the circle
--               lcd_pen_color -> off(erase), on or xor
-- return value: none
-- notes       : the circle code does not give a round circle on
--               the lcd.
-- Author      : Paul D'haene
--------------------------------------------------------------------------------
procedure glcd_circle(byte*GLCD_X_SIZE in cx, byte*GLCD_Y_SIZE in cy, byte in radius) is
   glcd_ellipse(cx, cy, radius, radius) -- approx scaled y radius
end procedure

--------------------------------------------------------------------------------
-- name        : glcd_line( x0, y0, x1, y1, lcd_pen_color )
-- description : fast integer only line draw
-- argument(s) : x0 -> start x  0 >= x < 84
--               y0 -> start y  0 >= y < 48
--               x1 -> end x
--               y1 -> end y
--               lcd_pen_color -> draw, erase or xor
-- Author      : Paul D'haene
--------------------------------------------------------------------------------
procedure  glcd_line(byte*GLCD_X_SIZE in x0,byte*GLCD_Y_SIZE in y0, byte*GLCD_X_SIZE in x1, byte*GLCD_Y_SIZE in y1) is
   var sword dx = sword(x1) - sword(x0)
   var sword dy = sword(y1) - sword(y0)
   var sword two_ds = dx + dx
   var sword two_dy = dy + dy
   var sword currentx = sword(x0), currenty = sword(y0)
   var sword xinc = 1, yinc = 1
   var sword two_ds_accumulated_error, two_dy_accumulated_error
   
   if dx < 0 then
      xinc = -1
      dx = -dx
      two_ds = -two_ds
   end if
   if dy < 0 then
      yinc = -1
      dy = -dy
      two_dy = -two_dy
   end if
   glcd_write_pixel(x0,y0) -- first point is special case
   
   if (dx != 0) | (dy != 0) then -- are there other points on the line?
      if dy <= dx then -- is the slope <= 1 ?
         two_ds_accumulated_error = 0 -- initialize error
         while currentx != x1 loop
            currentx = currentx + xinc -- consider x's from x0 to x1
            two_ds_accumulated_error = two_ds_accumulated_error + two_dy
            if two_ds_accumulated_error > dx then
               currenty = currenty + yinc
               two_ds_accumulated_error = two_ds_accumulated_error - two_ds
            end if
            glcd_write_pixel(byte(currentx), byte(currenty))
         end loop
      else -- the slope is large: reverse roles of X & Y
         two_dy_accumulated_error = 0 -- initialize error
         while currenty != y1 loop
            currenty = currenty + yinc -- consider y's from y0 to y1
            two_dy_accumulated_error = two_dy_accumulated_error + two_ds
            if two_dy_accumulated_error > dy then
               currentx = currentx + xinc
               two_dy_accumulated_error = two_dy_accumulated_error - two_dy
            end if
            glcd_write_pixel(byte(currentx), byte(currenty))
         end loop
      end if
   end if
end procedure

--------------------------------------------------------------------------------
-- Draw a box (x0,y0,x1,y1).
--------------------------------------------------------------------------------
procedure glcd_box(byte*GLCD_X_SIZE in x0, byte*GLCD_Y_SIZE in y0, byte*GLCD_X_SIZE in x1, byte*GLCD_Y_SIZE in y1) is
   pragma inline

   glcd_line ( x0,y0, x1,y0 )
   glcd_line ( x1,y0, x1,y1 )
   glcd_line ( x1,y1, x0,y1 )
   glcd_line ( x0,y1, x0,y0 )
end procedure

--------------------------------------------------------------------------------
-- Draw a filled box (x0,y0,x1,y1).
--------------------------------------------------------------------------------
procedure glcd_box_fill(byte*GLCD_X_SIZE in x0, byte*GLCD_Y_SIZE in y0, byte*GLCD_X_SIZE in x1, byte*GLCD_Y_SIZE in y1) is
   pragma inline

   while y0 != (y1 + 1) loop
      glcd_line ( x0,y0, x1,y0 )
      y0 = y0 + 1
   end loop
   
   -- todo: add block write capability.

end procedure

--------------------------------------------------------------------------------
-- Draw an image from a byte array. Same requirements as lcd_clear_screen(),
-- You can currently only draw an image that contains the same number of colors
-- as your glcd supports.
--------------------------------------------------------------------------------
if !defined(glcd_draw_image) then
   procedure glcd_draw_image(byte in image[], byte*GLCD_X_SIZE in x, byte*GLCD_Y_SIZE in y, byte*GLCD_X_SIZE in width, byte*GLCD_Y_SIZE in height) is

      -- fill using glcd's block write procedures
      if GLCD_USE_BLOCK_WRITE == TRUE then
         if GLCD_BLOCK_WRITE_TYPE == FONT_TOP_LEFT_HORIZONTAL then
            if GLCD_COLOR_BITS == 16 then
               glcd_block_set_address(x,y,x + width - 1,y + height - 1)
               
               var word i
               for (count(image)/2) using i loop

                  var word location1 = i*2+1
                  var word location2 = i*2

                  var word color
                  var byte _color[2] at color
                  _color[1] = image[location1]
                  _color[0] = image[location2]

                  glcd_block_write_color(color)
               end loop
            elsif GLCD_COLOR_BITS == 1 then
               -- not supported yet
            end if
         else
            _error "GLCD_BLOCK_WRITE_TYPE NOT SUPPORTED"
         end if
      end if
   end procedure
end if

