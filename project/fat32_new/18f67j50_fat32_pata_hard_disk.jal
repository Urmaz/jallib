-- Title: FAT32 library for reading fat32 filesystem
-- Author: Matthew Schinkel, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4k
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: this example reads files & folders from a fat32 formatted sd card
--              using the fat32 library.
--
-- Sources:
-- http://www.microsoft.com/whdc/system/platform/firmware/fatgen.mspx
-- http://www.pjrc.com/tech/8051/ide/fat32.html
-- http://en.wikipedia.org/wiki/File_Allocation_Table
--

include 18f67j50                    -- target PICmicro
-- include chip
pragma target clock 24_000_000     -- oscillator frequency
-- configuration memory settings (fuses)
pragma target WDT  disabled        -- no watchdog
pragma target PLLDIV        P2     -- divide by 5 - 20MHZ_INPUT
pragma target CPUDIV        P2     -- no cpu system clock divide
pragma target OSC  INTOSC_NOCLKOUT_PLL           -- HS crystal or resonator
pragma target IESO  DISABLED
pragma target FCMEN DISABLED
OSCTUNE_PLLEN = 1                  -- set 96mhz pll
OSCCON_SCS = 0b00
_usec_delay(1_000)                 -- wait for OSC PLL to settle

enable_digital_io() -- disable all analog pins if any
_usec_delay (100_000) -- wait for power to stablilize

-- setup uart for communication
const serial_hw_baudrate  = 115200   -- set the baudrate
include serial_hardware
serial_hw_init()

include print

-- setup hard disk library
CONST BYTE PATA_HD_USE_CS0_CS1_PINS = TRUE -- set true if you will use Alternate Status, Digital Output or Drive Address registers
const bit PATA_HD_NO_INVERTER = TRUE -- if true, an external inverter chip is not needed on /iowr, /iord, /cs0, /cs1 pins
-- pin assignments
alias     pata_hd_data_low              is porta   -- data port (low bits)
alias     pata_hd_data_low_direction    is porta_direction
alias     pata_hd_data_high             is portd   -- data port (high bits)
alias     pata_hd_data_high_direction   is portd_direction
alias     pata_hd_a0                    is pin_g2
alias     pata_hd_a0_direction          is pin_g2_direction
alias     pata_hd_a1                    is pin_g3
alias     pata_hd_a1_direction          is pin_g3_direction
alias     pata_hd_a2                    is pin_g4
alias     pata_hd_a2_direction          is pin_g4_direction
alias     pata_hd_iowr                  is pin_g0
alias     pata_hd_iowr_direction        is pin_g0_direction
alias     pata_hd_iord                  is pin_g1
alias     pata_hd_iord_direction        is pin_g1_direction
alias     pata_hd_cs1                   is pin_c1
alias     pata_hd_cs1_direction         is pin_c1_direction
alias     pata_hd_cs0                   is pin_c0
alias     pata_hd_cs0_direction         is pin_c0_direction
--
pata_hd_a0_direction = output    -- register select pin
pata_hd_a1_direction = output    -- register select pin
pata_hd_a2_direction = output    -- register select pin
pata_hd_iowr_direction = output  -- used for write pulse
pata_hd_iord_direction = output  -- used for read pulse
pata_hd_cs1_direction = output   -- register select pin
pata_hd_cs0_direction = output   -- register select pin
--

include pata_hard_disk           -- include the parallel ata ide hard disk library
pata_hd_init()                   -- initialize startup settings

-- setup fat32 --
-- include the required files
;include pic_data_eeprom
include format  -- include format library (required by some fat32 procedures)
-- change these vaues to save memory
const word FAT32_FILES_MAX = 50            -- the max number of files allowed in a directory
const byte FAT32_FILENAME_SIZE = 100        -- choose max filename size. if a filename is longer the this, beginning chars will be cut. short filenames are 12 bytes.
const FAT32_DIR_FRAGMENTS_TO_ALLOW = 10     -- (0 = you must have a defragmented media), usually directories are fragmented.
--                                          -- uses 6 bytes memory per fragment allowed
--                                          -- windows defrag does not defragment directories.
const FAT32_FILE_FRAGMENTS_TO_ALLOW = 10    -- (0 = you must have a defragmented media)
--                                          -- uses 8 bytes memory per fragment allowed
--
-- experts may change the following values
;const byte FAT32_ENTRIES_MAX = 1           -- highest file entry address can be 256
const byte FAT32_ENTRIES_MAX = 2            -- highest file entry address can be 65535
--
-- choose a memory source for the file list
const bit FAT32_USE_INTERNAL_MEMORY = TRUE -- Use internal memory for file location list
IF FAT32_USE_INTERNAL_MEMORY == TRUE THEN
   -- Setup a large array for storing sector data, This is where filename locations are stored
   const dword LARGE_ARRAY_2_SIZE = FAT32_FILES_MAX               -- choose number of array variables
   const dword LARGE_ARRAY_2_VARIABLE_SIZE = FAT32_ENTRIES_MAX    -- choose bytes size of variables
   include large_array_2                    -- include the array library
   ALIAS fat32_entry_location is large_array_2
elsif FAT32_USE_INTERNAL_MEMORY == FALSE THEN
   -- put your own code here if you wish to allow massive amounts of files per directory

   -- example usage of 23k256 for external memory

   -- if we are using an sd card, we already initilized the SPI bus, so skip this.
   if defined(sd_init) == false then  -- if we are using an sd card, we already did this step
      include spi_master_hw        -- includes the spi library
      -- define spi inputs/outputs
      pin_sdi_direction = input    -- spi input
      pin_sdo_direction = output   -- spi output
      pin_sck_direction = output   -- spi clock
      --
      spi_init(SPI_MODE_11,SPI_RATE_FOSC_4) -- init spi, choose mode and speed
   end if

   -- setup 23k256 for external memory
   -- setup chip select pin
   ALIAS sram_23k256_chip_select             is pin_c2
   ALIAS sram_23k256_chip_select_direction   is pin_c2_direction
   -- initial settings
   sram_23k256_chip_select_direction = output    -- chip select/slave select pin
   sram_23k256_chip_select = high                -- start chip slect high (chip disabled)
   -- initalize 23k256 in byte mode
   const byte SRAM_23K256_ALWAYS_SET_SPI_MODE = TRUE
   include sram_23k256 -- setup Microchip 23k256 sram
   sram_23k256_init(SRAM_23K256_SEQUENTIAL_MODE, SRAM_23K256_HOLD_DISABLE)  -- init 23k256 in sequential mode

  -- alias the 23k256 device word array
  ;alias entry_location is sram_23k256_byte  -- highest file entry address can be 256
   alias fat32_entry_location is sram_23k256_word   -- highest file entry address can be 65535
END IF
--
include fat32-2   -- include fat32 library -- include fat32

-- CHOOSE FILE ATTRIBUTES TO FILTER OUT
fat32_filter_is_read_only  = FALSE
fat32_filter_is_hidden     = FALSE
fat32_filter_is_system     = FALSE
fat32_filter_is_volume_id  = FALSE
fat32_filter_is_directory  = FALSE
fat32_filter_is_archive    = FALSE

-- user procedures

-- procedure for sending 80 "-----------------" via serial port
procedure next() is
   serial_hw_write (13)-- send (carriage return, line feed) characters to serial port
   serial_hw_write (10)
   for 80 loop
      serial_hw_write ("-")
   end loop
   serial_hw_write (13)-- send (carriage return, line feed) characters to serial port
   serial_hw_write (10)
end procedure

-- start of main program
var byte data -- vars for storing data read

fat32_init(1)       -- initialize fat32, go to 1st primary partition's root dir "\"

if fat32_init_ok == TRUE then
   const byte str1[] = "FAT32 FOUND"
   print_string(serial_hw_data, str1)
else
   const byte str2[] = "FAT32 PARTITION NOT FOUND"
   print_string(serial_hw_data, str2)
end if
print_crlf(serial_hw_data)
print_crlf(serial_hw_data)

include print

------------------------------------------------------------
-- list a directory, send it via serial port
------------------------------------------------------------

-- we are now in the root dir of the 1st partition

fat32_list_dir() -- see the procedure, sends dir listing via serial port



------------------------------------------------------------
-- example user interaction,
-- send file/dir number via serial port to go into it
--
-- if volume id selected, list the current dir (root dir)
-- if directory selected go into it and list it
-- if file selected go into file and read it
------------------------------------------------------------

-- NEEDS WORK. DOESN'T GET ALL FILE DATA(MISSING LAST SECTOR), ONLY READS SECTOR BY SECTOR.
--
-- MAYBE fat32_file_data_available SHOULD BE RENAMED TO fat32_file_sectors_available
--
-- NOTE THAT YOU DON'T NEED TO CALL START READ/STOP READ
--
-- READING SECTORS SHOULD BE FASTER NOW, SEE pata_hd_read_sector2,
-- THERE IS NO NEED TO TELL THE DRIVE TO MOVE TO THE NEXT SECTOR IF WE ARE ALREADY THERE.
--
-- MAYBE A (INLINE?) PSEUDO VAR SHOULD BE CREATED TO READ BYTE BY BYTE INSTEAD OF DOING 512 LOOP

var byte file_number2
var word step1
forever loop
   next() -- send "-----" then loop and wait for user input

   while !serial_hw_data_available loop
   end loop

   var byte x = serial_hw_read(file_number2)

   -- choose a file for reading or dir for opening
   if fat32_cd(file_number2) then             -- if change directory is successful
      fat32_list_dir()                        -- sends dir listing via serial port
   elsif fat32_file_open(file_number2) then   -- if go into file is successful
      while fat32_file_data_available loop
         fat32_read_file_sector() -- read one sector of file data
         for 512 using step1 loop
            serial_hw_data = fat32_sector_buffer[step1]
         end loop
      end loop
   end if
end loop



-- WORKS GOOD BUT NOT FULLY TESTED
var byte file_number3
forever loop
   next() -- send "-----" then loop and wait for user input

   while !serial_hw_data_available loop
   end loop

   var byte x = serial_hw_read(file_number2)

   -- choose a file for reading or dir for opening
   if fat32_cd(file_number3) then             -- if change directory is successful
      fat32_list_dir()                        -- sends dir listing via serial port
   elsif fat32_file_open(file_number3) then   -- if go into file is successful
      fat32_start_read (fat32_file_location)  -- go in the file, get ready to read
      for (fat32_file_size) loop              -- reading one byte
         data = fat32_raw_data_byte
         serial_hw_data = data
      end loop
      fat32_stop_read () -- end of file, set media idle
   end if
end loop
