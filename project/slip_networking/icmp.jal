-- Title: Internet control message protocol (ICMP)
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4l
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: Establishes communication between computers
--
-- Sources:
-- http://www.faqs.org/rfcs/rfc792.html
--
-- Notes:
-- Linux default echo/ping message size is 64, windows is 32
-- const byte ICMP_MAX_MESSAGE_SIZE = 64
--

const byte ICMP = 1 -- ICMP protocol number for ip header

-- ICMP message types
const ICMP_ECHO_REPLY = 0
const ICMP_DESTINATION_UNREACHABLE = 3
const ICMP_SOURCE_QUENCH = 4
const ICMP_REDIRECT = 5
const ICMP_ECHO = 8
const ICMP_TIME_EXCEEDED = 11
const ICMP_PARAMETER_PROBLEM = 12
const ICMP_TIMESTAMP = 13
const ICMP_TIMESTAMP_REPLY = 14
const ICMP_INFORMATION_REQUEST = 15
const ICMP_INFORMATION_REPLY = 16

var byte icmp_message[ICMP_MAX_MESSAGE_SIZE]
var byte icmp_type at icmp_message : 0
var byte icmp_code at icmp_message : 8
var word icmp_checksum at icmp_message : 16
var word icmp_identifier at icmp_message : 32
var word icmp_sequence_number at icmp_message : 48
   
--------------------------------------------------------------------------------
-- Sends an echo (PING) message
--------------------------------------------------------------------------------
procedure icmp_send_echo(byte in ip_3, byte in ip_2, byte in ip_1, byte in ip_0) is

   var byte sending_ping[] = "---------- sending ping... ----------"
   debug_string(DEBUG_2,sending_ping)
   debug_crlf(DEBUG_2)

   -- send the ip header
   const byte ECHO_DATA_LENGTH = 8
   ip_header_send(ip_3,ip_2,ip_1,ip_0,ICMP,ECHO_DATA_LENGTH)
   
   icmp_type = ICMP_ECHO
   icmp_code = 0
   icmp_checksum = 0
   icmp_identifier = 1
   icmp_sequence_number = 0

   network_switch_word_bytes(icmp_identifier)  -- switch bytes for network out format
   network_switch_word_bytes(icmp_sequence_number)  -- switch bytes for network out format
   
   -- set the checksum bytes for transmit
   checksum_16_byte_calc(icmp_message,0,8,icmp_checksum)
   network_switch_word_bytes(icmp_checksum)  -- switch bytes for network out format

   -- put the data into the output buffer
   var byte count1 = 0
   for 8 using count1 loop  -- loop through all bytes in packet
      network_send_data(icmp_message[count1]) -- send slip packet data via serial port
      -- send the data for debugging
   end loop
   
   -- complete the packet and send it
   network_end_packet() -- slip end packet (ethernet not tested yet)
end procedure

--------------------------------------------------------------------------------
-- Sends an echo reply message
--------------------------------------------------------------------------------
procedure icmp_send_echo_reply(byte in data_left) is
   -- calculate icmp message size
   var byte message_size = data_left + 1
   if message_size > ICMP_MAX_MESSAGE_SIZE then
      const byte icmp_str2[] = "---------- ICMP ERROR: Received Data Is Too Large ----------"
      debug_string(DEBUG_1, icmp_str2)
      debug_crlf(DEBUG_1)
      message_size = ICMP_MAX_MESSAGE_SIZE
   else
      debug_crlf(DEBUG_2)
      const byte icmp_str1[] = "---------- sending ping reply! ----------"
      debug_string(DEBUG_2, icmp_str1)
      debug_crlf(DEBUG_2)
   end if
   
   -- get 8 bytes of icmp message + icmp data
   -- except the first byte, we already got ICMP_ECHO in icmp_read_packet()
   var word step = 1
   for data_left loop
      icmp_message[step] = network_rx_buffer
      debug_byte_hex(DEBUG_4, icmp_message[step])
      debug_char(DEBUG_4," ")
      step = step + 1
   end loop

   -- send an ip header
   ip_header_send(ip_header_source_ip_3,ip_header_source_ip_2,ip_header_source_ip_1,ip_header_source_ip_0,ICMP,data_left + 1)

   -- set the type byte in icmp message
   icmp_message[0] = ICMP_ECHO_REPLY

   -- set the checksum bytes in icmp message
   icmp_checksum = 0
   checksum_16_byte_calc(icmp_message,0,message_size,icmp_checksum)
   network_switch_word_bytes(icmp_checksum)  -- switch bytes for network out format

   -- put the data into the output buffer
   var byte count2 = 0
   for message_size using count2 loop   -- loop through all bytes in packet
      network_send_data(icmp_message[count2]) -- send slip packet data via serial port
      debug_byte_hex(DEBUG_4, icmp_message[count2])
      debug_char(DEBUG_4," ")
   end loop

   -- complete the packet and send it
   network_end_packet() -- slip end packet (ethernet not tested yet)
end procedure

procedure icmp_read_packet(byte in data_size) is
   -- get the first byte of the icmp data (icmp message type)
   var byte icmp_message_type = network_rx_buffer

   if icmp_message_type == ICMP_ECHO_REPLY then
      debug_crlf(DEBUG_2)
      const byte icmp_str1[] = "---------- ping reply received! ----------"
   
      debug_string(DEBUG_2, icmp_str1)
      debug_crlf(DEBUG_2)

      -- print the message type
      debug_byte_hex(DEBUG_4, icmp_message_type)
      debug_char(DEBUG_4," ")

      -- print rest of the data (already sent first byte)
      for data_size - 1 loop               -- for each byte in packet
         debug_byte_hex(DEBUG_4, network_rx_buffer)
         debug_char(DEBUG_4," ")
      end loop
   elsif icmp_message_type == ICMP_ECHO then
      debug_crlf(DEBUG_2)
      const byte icmp_str1[] = "---------- ping received! ----------"
      debug_string(DEBUG_2, icmp_str1)
      debug_crlf(DEBUG_2)

      -- print the type
      debug_byte_hex(DEBUG_4, icmp_message_type)
      debug_char(DEBUG_4," ")
      
      -- reply to the ping (we already got the first byte so minus 1)
      icmp_send_echo_reply(data_size - 1)
   else
      -- print unknown ICMP message
      for data_size - 1 loop               -- for each byte in packet
         debug_byte_hex(DEBUG_4, network_rx_buffer)
         debug_char(DEBUG_4," ")
      end loop
   end if
end procedure
