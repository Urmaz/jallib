-- Title: Network Initialization & Constants
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4l
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: Sets up the network link layer and defines constants
--
-- Sources:
-- http://www.comptechdoc.org/independent/networking/protocol/protnet.html
--

----------------------------------------------------------------
-- put the network array into the output buffer
----------------------------------------------------------------
procedure network_send_packet(word in size) is
   if NETWORK_LINK_LAYER == SLIP then
      var byte count1 = 0
      for size using count1 loop
         network_send_data(network_data[count1])
         debug_byte_hex(DEBUG_4,network_data[count1])
         debug_char(DEBUG_4," ")
      end loop
      network_end_packet()
   else
      pragma error -- Layer Not Supported
   end if
   
   network_data_in_use = FALSE
end procedure

----------------------------------------------------------------
-- get the network array from the input buffer
----------------------------------------------------------------
procedure network_get_packet(word in size) is
   if NETWORK_LINK_LAYER == SLIP then
      var byte count1 = 0
      for size using count1 loop
         network_data[count1] = network_rx_buffer
         ;debug_byte_hex(DEBUG_4,network_data[count1])
         ;debug_char(DEBUG_4," ")
      end loop
   else
      pragma error -- Layer Not Supported
   end if
end procedure

--------------------------------------------------------------------------------
-- Reads a recieve packet. Verifies IP Header data such as IP
-- address and checksum (with ip_header.jal), then sends the
-- rest of the data to the correct procedure depending on packet type.
--------------------------------------------------------------------------------
procedure network_received_packet(byte in packet_size) is
   network_data_in_use = TRUE

   debug_crlf(DEBUG_2)
   const byte str1[] = "---------- PACKET RECEIVED ----------"
   debug_string(DEBUG_3, str1)
   debug_crlf(DEBUG_3)
   
   if packet_size > network_max_packet_size then
      -- your packet may have a problem, it is too large
      const byte str[] = "---------- ERROR: packet too large for buffer ----------"
      debug_string(debug_lvl_1, str)
      debug_crlf(debug_lvl_1)
      
      network_clear_rx_queue() -- clear bad data in the queues
      return                   -- ignore the packet
   end if
   
   network_get_packet(packet_size)
   
   -- check if the header destination ip matches PIC ip,
   -- and check if ip_header checksum is ok.
   if ip_header_verify() == 1 then
   
      -- print the entire data
      var byte count1 = 0
      for ip_header_size using count1 loop
         debug_byte_hex(DEBUG_4,network_data[count1])
         debug_char(DEBUG_4," ")
      end loop
   
      debug_crlf(debug_lvl_3)

      -- check what type of packet it is (what protocol)
      if ip_header_protocol == ICMP then -- ICMP protocol
         const byte str2[] = "-- ICMP Packet --"
         debug_string(debug_lvl_3, str2)

         -- send the data to ICMP lib for reading
         icmp_read_packet(packet_size - ip_header_size)
         
      elsif ip_header_protocol == UDP then -- UDP protocol
         const byte str2[] = "-- UDP Packet --"
         debug_string(debug_lvl_3, str2)

         -- send the data to UDP lib for reading
         udp_read_packet(packet_size - ip_header_size)
      else                               -- unknown protocol
         const byte str3[] = "-- raw data --"
         debug_string(debug_lvl_3, str3)
         debug_crlf(debug_lvl_3)
         
         -- just print the raw data
         for packet_size - ip_header_size loop               -- for each byte in packet
            debug_byte_hex(DEBUG_4, network_rx_buffer)
            debug_char(DEBUG_4," ")
         end loop
      end if
   else
      -- ignore the packet, it wasn't for us, or ip header checksum failed.
      -- must read all packet data to keep buffer in sync.
      debug_crlf(debug_lvl_3)
      const byte str2[] = "-- packet ignored --"
      debug_string(debug_lvl_3, str2)
      debug_crlf(2)
   end if
   --
   debug_crlf(DEBUG_3)
   
   network_data_in_use = FALSE
end procedure

----------------------------------------------------------------
-- switch byte order in a word
----------------------------------------------------------------
procedure network_switch_word_bytes(word in out data) is
   var byte _data[2] at data
   var byte temp
   temp = _data[0]
   _data[0] = _data[1]
   _data[1] = temp
end procedure

----------------------------------------------------------------
-- switch byte order in a dword
----------------------------------------------------------------
procedure network_switch_dword_bytes(dword in out data) is
   var byte _data[4] at data
   var byte temp
   temp = _data[0]
   _data[0] = _data[3]
   _data[3] = temp

   temp = _data[1]
   _data[1] = _data[2]
   _data[2] = temp
end procedure

----------------------------------------------------------------
-- functions to get/put variables into the network array
----------------------------------------------------------------
function network_byte'get(word in variable) return byte is
   pragma inline
   return network_data[network_var_offset + variable]
end function
procedure network_byte'put(word in variable, byte in value) is
   pragma inline
   network_data[network_var_offset + variable] = value
end procedure

procedure network_word'put(word in variable, word in value) is
   pragma inline
   var byte _value[2] at value
   network_data[network_var_offset + variable] = _value[1]
   network_data[network_var_offset + variable + 1] = _value[0]
end procedure
function network_word'get(word in variable) return word is
   pragma inline
   var word value
   var byte _value[2] at value
   _value[1] = network_data[network_var_offset + variable]
   _value[0] = network_data[network_var_offset + variable + 1]
   return value
end function

procedure network_dword'put(word in variable, dword in value) is
   var byte _value[4] at value
   network_data[network_var_offset + variable] = _value[3]
   network_data[network_var_offset + variable + 1] = _value[2]
   network_data[network_var_offset + variable + 2] = _value[1]
   network_data[network_var_offset + variable + 3] = _value[0]
end procedure
function network_dword'get(word in variable) return dword is
   var dword value
   var byte _value[4] at value
   _value[3] = network_data[network_var_offset + variable]
   _value[2] = network_data[network_var_offset + variable + 1]
   _value[1] = network_data[network_var_offset + variable + 2]
   _value[0] = network_data[network_var_offset + variable + 3]
   return value
end function
