// parser - parse source.  
//
// Adapted-by: Joep Suijs
// Compiler: >=2.4m
//
// This file is part of jallib (http://jallib.googlecode.com)
// Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
//
// Description: 
//
//
// based on:
// Example of a grammar for parsing C sources,
// Adapted from Java equivalent example, by Terence Parr
// Author: Jim Idle - April 2007
// Permission is granted to use this example code in any way you want, so long as
// all the original authors are cited.
//

#include "jat.h"

//#include <stdio.h>
//
//// antlr generated
//#include    "jalLexer.h"
//#include    "jalParser.h"

pjalLexer		    lxr;


jalParser_program_return ParseSource(pANTLR3_UINT8 fName)
{
    // Now we declare the ANTLR related local variables we need.
    // Note that unless you are convinced you will never need thread safe
    // versions for your project, then you should always create such things
    // as instance variables for each invocation.
    // -------------------

    // Name of the input file. Note that we always use the abstract type pANTLR3_UINT8
    // for ASCII/8 bit strings - the runtime library guarantees that this will be
    // good on all platforms. This is a general rule - always use the ANTLR3 supplied
    // typedefs for pointers/types/etc.
    //
//    pANTLR3_UINT8	    fName;

    // The ANTLR3 character input stream, which abstracts the input source such that
    // it is easy to provide input from different sources such as files, or 
    // memory strings.
    //
    // For an ASCII/latin-1 memory string use:
    //	    input = antlr3NewAsciiStringInPlaceStream (stringtouse, (ANTLR3_UINT64) length, NULL);
    //
    // For a UCS2 (16 bit) memory string use:
    //	    input = antlr3NewUCS2StringInPlaceStream (stringtouse, (ANTLR3_UINT64) length, NULL);
    //
    // For input from a file, see code below
    //
    // Note that this is essentially a pointer to a structure containing pointers to functions.
    // You can create your own input stream type (copy one of the existing ones) and override any
    // individual function by installing your own pointer after you have created the standard 
    // version.
    //
    pANTLR3_INPUT_STREAM    input;

   // The lexer is of course generated by ANTLR, and so the lexer type is not upper case.
   // The lexer is supplied with a pANTLR3_INPUT_STREAM from whence it consumes its
   // input and generates a token stream as output.
   //
   // (moved to global)   pjalLexer		    lxr;

   // The token stream is produced by the ANTLR3 generated lexer. Again it is a structure based
   // API/Object, which you can customise and override methods of as you wish. a Token stream is
   // supplied to the generated parser, and you can write your own token stream and pass this in
   // if you wish.
   //
   pANTLR3_COMMON_TOKEN_STREAM	    tstream;

   // The C parser is also generated by ANTLR and accepts a token stream as explained
   // above. The token stream can be any source in fact, so long as it implements the 
   // ANTLR3_TOKEN_SOURCE interface. In this case the parser does not return anything
   // but it can of course specify any kind of return type from the rule you invoke
   // when calling it.
   //
   pjalParser				psr;
   
   // Create the input stream based upon the argument supplied to us on the command line
   // for this example, the input will always default to ./input if there is no explicit
   // argument.
   //           

   // Create the input stream using the supplied file name
   // (Use antlr3AsciiFileStreamNew for UCS2/16bit input).
   //
   input	= antlr3AsciiFileStreamNew(fName);
   
   // The input will be created successfully, providing that there is enough
   // memory and the file exists etc
   //
   if ( input == NULL) {
      fprintf(stderr, "Failed to open file %s\n", (char *)fName);
      exit(1);
   }
   
   // Our input stream is now open and all set to go, so we can create a new instance of our
   // lexer and set the lexer input to our input stream:
   //  (file | memory | ?) --> inputstream -> lexer --> tokenstream --> parser ( --> treeparser )?
   //
   lxr	    = jalLexerNew(input);	    // CLexerNew is generated by ANTLR
   
   assert(lxr != NULL) ; // Unable to create the lexer due to malloc() failure1
   
   // Our lexer is in place, so we can create the token stream from it
   // NB: Nothing happens yet other than the file has been read. We are just 
   // connecting all these things together and they will be invoked when we
   // call the parser rule. ANTLR3_SIZE_HINT can be left at the default usually
   // unless you have a very large token stream/input. Each generated lexer
   // provides a token source interface, which is the second argument to the
   // token stream creator.
   // Note that even if you implement your own token structure, it will always
   // contain a standard common token within it and this is the pointer that
   // you pass around to everything else. A common token as a pointer within
   // it that should point to your own outer token structure.
   //
   tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
   
   assert (tstream != NULL); // Out of memory trying to allocate token stream

    // Finally, now that we have our lexer constructed, we can create the parser
    //
    psr	    = jalParserNew(tstream);  // CParserNew is generated by ANTLR3

    assert (psr != NULL); // Out of memory trying to allocate parser
   
   // We are all ready to go. Though that looked complicated at first glance,
   // I am sure, you will see that in fact most of the code above is dealing
   // with errors and there isn't really that much to do (isn't this always the
   // case in C? ;-).
   //
   // So, we now invoke the parser. All elements of ANTLR3 generated C components
   // as well as the ANTLR C runtime library itself are pseudo objects. This means
   // that they are represented as pointers to structures, which contain any
   // instance data they need, and a set of pointers to other interfaces or
   // 'methods'. Note that in general, these few pointers we have created here are
   // the only things you will ever explicitly free() as everything else is created
   // via factories, that allocated memory efficiently and free() everything they use
   // automatically when you close the parser/lexer/etc.
   //
   // Note that this means only that the methods are always called via the object
   // pointer and the first argument to any method, is a pointer to the structure itself.
   // It also has the side advantage, if you are using an IDE such as VS2005 that can do it
   // that when you type ->, you will see a list of tall the methods the object supports.
   //
   jalParser_program_return r = psr->program(psr);       // js 'program' is het root element van de taal


   // If the parser ran correctly, we will have a tree to parse. In general I recommend 
   // keeping your own flags as part of the error trapping, but here is how you can 
   // work out if there were errors if you are using the generic error messages 
   // 
   if (psr->pParser->rec->state->errorCount > 0) { 
      fprintf(stderr, "The parser returned %d errors, tree walking aborted.\n", psr->pParser->rec->state->errorCount); 
      exit(1);
   }       
   
   return r;
}
            
            
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
pANTLR3_INPUT_STREAM JalOpenInclude(char *Line) 
{  int State, i;
   char *BaseName;                       
   char FileName[256];
   pANTLR3_INPUT_STREAM    in;

   if (NoInclude) {
      printf("// Ignore include line %s\n", Line);
      return NULL;
   }
   
//   printf("// JalInclude line: %s\n", Line);

   State = 0;
   for (i=0; ((Line[i] != 0)&(State != 3)); i++) {
      switch(State) {
         case 0 : { // search for first whitespace
            if ((Line[i] == ' ') | (Line[i] == '\t')) {
               State = 1;
            }
            break;  
         }          
         case 1 : { // search for non-whitespace, which is start of filename/path
            if ((Line[i] != ' ') & (Line[i] != '\t')) {
               BaseName = &Line[i];
               State = 2;
            }
            break;  
         }          
         case 2 : { // search for first whitespace, which is end of filename/path
//            if (Line[i] == '/') {
//               Line[i] = '\\';  // seems not required in windows...
//            }
            if ((Line[i] == ' ') | (Line[i] == '\t') | (Line[i] == '\r') | (Line[i] == '\n')) {
               Line[i] = 0; // terminate string
               State = 3;
            }
            break;  
         }               
         default : {
            printf("Error state: %d, i: %d\n", State, i);     
            break;
         }
      }
   }
   printf("// include BaseName: _%s_\n", BaseName);   

   sprintf(FileName, "%s.jal", BaseName);
// TODO:
//
// walk include path to find file.                                  

   in = antlr3AsciiFileStreamNew(FileName);

   if (in == NULL) {
      printf("Error opening include file %s\n", FileName);
      fprintf(stderr, "Error opening include file %s\n", FileName);
      exit(1);
   }

   // note: PUSHSTREAM macro only works in LEX context (not in this code, nor PARSER context).
   // So leave PUSHSTREAM in the gramar-file.
   return in;
}
