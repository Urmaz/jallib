include pic_target


;------------------------------------------------------------------------------
; test of forever loop, if elsif, else, exit loop
test_header(1)

var word e
 e = 5

function plus_five (byte in param) return byte is
   return param + 5
end function

forever loop   

   if (e == 10) then 
      e=20 
   elsif e==30 then 
      e=40 
   elsif e==50 then 
      exit loop
   else 
      e=plus_five(e) 
   end if

   print_var(e)

end loop

;------------------------------------------------------------------------------
; while loop test
test_header(2)

e=0
while (e < 35) loop  

   if (e == 10) then 
      e=20 
   elsif e==30 then 
      e=40 
   elsif e==60 then 
      exit loop
   else 
      e=plus_five(e) 
   end if

   print_var(e)

end loop

;------------------------------------------------------------------------------
; repeat until   
test_header(3)

repeat

   if (e == 10) then 
      e=20 
   elsif e==30 then 
      e=40 
   elsif e==60 then 
      exit loop
   else 
      e=plus_five(e) 
   end if

   print_var(e)

until(e < 35) 


;------------------------------------------------------------------------------
;  for loop
test_header(4)

e = 5
for 4 loop

   e = e + 1
   print_var(e)

end loop 

for 4 using e loop

   print_var(e)

end loop 

;------------------------------------------------------------------------------
; case and block             
test_header(5)

for 10 using e loop
   case e of
      0 : print_var(0)
      1, 2 : print_var(12)
      
      3, 4 : block 
         print_var(34)
      end block
      
      5, 6 : block
      end block
   
      otherwise print_var(100+e)
   end case
end loop              

;------------------------------------------------------------------------------
; test call by reference
test_header(5)

procedure increment(byte in out v) is
   v = v + 1
end procedure

var byte a = 1

increment(a)

print_var(a)

;------------------------------------------------------------------------------
; test call by reference II
test_header(6)

procedure intermediate(byte in out w) is
   increment(w)
end procedure

a = 1

intermediate(a)

print_var(a)

;------------------------------------------------------------------------------
; pvar put and get
test_header(7)

procedure aap'put(byte in p) is
   print_var(100 + p)
end procedure

function  aap'get() return byte is
   return 7
end function

aap = aap 

;------------------------------------------------------------------------------
;------------------------------------------------------------------------------
; test group:
;  call *by* code, reference and value X call *from* code, reference, value
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------

procedure callby_code(volatile byte in out v) is
   v = v + 1
end procedure

procedure callby_reference(byte in out v) is
   v = v + 2
end procedure

var byte a

;------------------------------------------------------------------------------
; test call by code, reference and value from *value*
test_header(9)

procedure TestFromValue(byte in c) is
   callby_code(c)
   callby_reference(c)
   print_var(c)
end procedure

a = 1
TestFromValue(a)
print_var(a)

;------------------------------------------------------------------------------
; test call by code, reference and value from *reference*
test_header(10)                                          

procedure TestFromReference(byte in out b) is
   callby_code(b)
   callby_reference(b)
   print_var(b)
end procedure

a = 1
TestFromReference(a)
print_var(a)

;------------------------------------------------------------------------------
; test call by code, reference and value from *code*
test_header(11)

procedure TestFromCode(volatile byte in out b) is
   callby_code(b)
;   callby_reference(b)
   print_var(b)
end procedure

a = 1
TestFromCode(a)
print_var(a)         












;------------------------------------------------------------------------------
; ahead (roughly ordered from close to far):                                                                  
;                                                     
;  - rework parsing so procedure defs are always encountered in pass one.
;  currently, a procedure def within if, loop etc is not recoginised.
;  (guess more rework is required to support conditional compile...)  
;
;  - support reference-parameter as input for call-by-code
;  Probably requires analysis of procedure call and write wrapping-code before 
;  actuall printing code as the program does now.
;
;  - run this testset on a real pic, capture output and use it as a regression test
;  
;  - create a setup to manage the testsets and it's output.                   
;                     
;  - test all relevant combinations of in/out with call by value/reference/code
;
;  - test proper casting on procedure parameters.
;
;  - support use of pseudo vars as parameters (value/reference/code
;  
;  - add alias
;  
;  - check if all 'pragma' keywords (like data) are valid identifiers at any point.
;
;  - use C 'volatile' keyword when relevant.
;    
;  - find a sollution for (expr == true)
;  C has no bit vars, so any value that is not false is considered true. Of course we 
;  could just replace this particular compare, but that would not catch similar statements
;  like (true == expr),( expr == on) where on equals to true etc. It would be nice if
;  there was a sollution without replacing all expression evaluation of C,
;  
;  - support bit variables, both single bit as multibit and at offset of a byte
;  (for now, I intend to limit to bits into one byte or maybe other vars)
;
;  - support of 'at', at least for bit variables.
;
;  - support for 'variable prototypes' (equivalent to 'extern' in C).
;  with this, both size and reference type (pointer = in/out) or value definition should be supported  
;
;  - support of arrays (have not thought of this yet, passing of arrays may require quite a lot of rework)
;    
;  - better parser error support - try leaving out 'is' from a valid procedure definition and you know
;  what I mean.  
;    
;  Later, maybe never:  
;  - support of odd-sized vars, like byte*3 (below 32 bits)
;  
;  - support of long vars, like byte*8 (beyond 32 bits).
;  
;  - conditional compile (if an expression of an if-statement contains constants only, irrelevant code is
;     not compiled. Code does not need to be valid (e.g. can contain vars that does not exist), but when
;     we leave it out of C, we get the same effect.
   
   


