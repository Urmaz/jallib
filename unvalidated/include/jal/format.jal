-- Title: Writes formatted values to output device
-- Author: Stef Mientki, Copyright (c) 2002 .. 2006, all rights reserved.
-- Adapted-by: Joep Suijs
-- Compiler: >=2.2
-- 
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Sources: 
-- 
-- Description: Outputs variables to output device.
-- .  Writes formatted signed/unsiged bytes/words to the specified output device.
-- .  Decimal (with fraction), Hex and Time formats available.
-- .  
-- .     procedure format_byte_dec(device,data,n_tot,N2)
-- .     procedure format_sbyte_dec(device,data,n_tot,N2)
-- .     procedure format_byte_hex(device,data)
-- .  
-- .     procedure format_word_dec(device,data,n_tot,N2)
-- .     procedure format_sword_dec(device,data,n_tot,N2)
-- .     procedure format_word_hex(device,data)
-- .  
-- .     procedure format_time_word (device, minutes)
-- .     procedure format_time_bytes(device,HH,MM)
-- .
-- .  Example:
-- .     
-- .     var sword BHL = -684
-- .     
-- .     -- send the signed word to the LCD display
-- .     -- with 2 digits behind the decimal point
-- .     format_sword_dec(LCD_char,BHL,6,2)
-- .     
-- .     -- and now send the same signed word to the serial port
-- .     format_sword_dec(Serial_HW_data,BHL,6,2)
-- .      -----------------------------------------------------------------------------
-- .   
--   
-- Notes: 
--

-- -----------------------------------------------------------------------------
-- global vars
-- -----------------------------------------------------------------------------
var byte _format_leader
var byte _format_digit
var byte _format_sign
var bit  _format_signed
-- -----------------------------------------------------------------------------

-- -----------------------------------------------------------------------------
-- -----------------------------------------------------------------------------
procedure _write_real_digit(volatile byte out device) is

   if _format_signed then
      device = _format_sign
      _format_signed = false
   end if

   if _format_digit < 10 then
      device = "0" + _format_digit
   else
      device = "A" + _format_digit - 10
   end if

   -- after writing a real digit, always make leader a "0" !!
   _format_leader = "0"

end procedure
-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- -----------------------------------------------------------------------------
procedure _write_digit(volatile byte out device, byte in digit, bit in point) is

   _format_digit = digit
   if point then
      _write_real_digit(device)
      device = "."
   else
      if _format_digit == 0 then device = _format_leader
      else _write_real_digit(device)
      end if
   end if

end procedure
-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- writes decimal formatted byte to output device
-- the output can be specified as a fraction
--   n_tot = the total length (including sign and decimal point)
--   N2   = number of digits behind the point
-- -----------------------------------------------------------------------------
procedure format_byte_dec(volatile byte out device, byte in data, byte in n_tot, byte in N2) is

   const word C100   = 100
   const word C10    = 10
   var byte digit

   -- start with spaces as a leader
   _format_leader = " "

   -- determine the next digit and display it
   if n_tot >= 3 then
      digit = byte(data / C100)
      data  = byte(data % C100)
      _write_digit(device, digit, N2==2)
   end if

   if n_tot >= 2 then
      digit = byte(data / C10)
      data  = byte(data % C10)
      _write_digit(device, digit, N2==1)
   end if

   -- last digit must always be written
   _format_digit = data
   _write_real_digit(device)
end procedure
-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- writes decimal formatted word to output device
-- the output can be specified as a fraction
--   n_tot = the total length (including sign and decimal point)
--   N2   = number of digits behind the point
-- -----------------------------------------------------------------------------
procedure format_word_dec(volatile byte out device, word in data, byte in n_tot, byte in N2) is

   const word C10000 = 10000
   const word C1000  = 1000
   const word C100   = 100
   const word C10    = 10
   var byte digit

   -- start with spaces as a leader
   _format_leader = " "

   -- determine the next digit and display it
   if n_tot >=5 then
      digit = byte(data / C10000)
      data  = data % C10000
      _write_digit(device, digit, N2==4)
   end if

   if n_tot >= 4 then
      digit = byte(data / C1000)
      data  = data % C1000
      _write_digit(device, digit, N2==3)
   end if

   if n_tot >= 3 then
      digit = byte(data / C100)
      data  = data % C100
      _write_digit(device, digit, N2==2)
   end if

   if n_tot >= 2 then
      digit = byte(data / C10)
      data  = data % C10
      _write_digit(device, digit, N2==1)
   end if

   -- last digit must always be written
   _format_digit = byte(data)
   _write_real_digit(device)
end procedure
-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- writes decimal formatted signed byte to output device
-- the output can be specified as a fraction
--   n_tot = the total length (including sign and decimal point)
--   N2   = number of digits behind the point
-- -----------------------------------------------------------------------------
procedure format_sbyte_dec(volatile byte out device, sbyte in data, byte in n_tot, byte in N2) is

   var bit sign at data:7

   if sign then
      _format_sign = "-"
      data = -data
   else
      _format_sign = " "
   end if

   _format_signed = true
   format_byte_dec(device, data, n_tot-1, N2)
end procedure
-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- writes decimal formatted signed word to output device
-- the output can be specified as a fraction
--   n_tot = the total length (including sign and decimal point)
--   N2   = number of digits behind the point
-- -----------------------------------------------------------------------------
procedure format_sword_dec(volatile byte out device, sword in data, byte in n_tot, byte in N2) is

   ;var byte digit
   ;var byte B[2] at data
   ;var bit sign at B[1]:7
   var bit sign at data:15

   if sign then
      _format_sign = "-"
      data = -data
   else
      _format_sign = " "
   end if

   _format_signed = true
   format_word_dec(device, data, n_tot-1, N2)
end procedure
-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- writes hex formatted byte to output device
-- -----------------------------------------------------------------------------
procedure format_byte_hex(volatile byte out device, byte in data) is

   var byte digit

   -- start with zeroes as a leader
   _format_leader = "0"

   -- determine the next digit and display it
   for 2 loop
      digit = (data & 0xF0) >> 4
      data  = data << 4
      _write_digit(device,digit,false)
   end loop

end procedure
-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- writes hex formatted word to output device
-- -----------------------------------------------------------------------------
procedure format_word_hex(volatile byte out device, word in data) is

   var byte digit
   var byte B[2] at data

   -- start with zeroes as a leader
   _format_leader = "0"

   -- determine the next digit and display it
   for 4 loop
      digit = (B[1] & 0xF0) >> 4
      data  = data << 4
      _write_digit(device,digit,false)
   end loop

end procedure
-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Displays a time in HH:MM notation at specified position
-- Hours and minutes are specified separate
-- -----------------------------------------------------------------------------
procedure format_time_bytes(volatile byte out device,byte in HH, byte in MM) is
   var byte D10

   D10 = HH / 10
   HH  = HH % 10

   -- always dsiplay Zeroes
   device = "0" + D10
   device = "0" + HH
   device = ":"

   D10 = MM / 10
   MM  = MM % 10

   device = "0" + D10
   device = "0" + MM
end procedure
-- -----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Displays a time in HH:MM notation at specified position
-- the input is specified in minutes
-- -----------------------------------------------------------------------------
procedure format_time_word(volatile byte out device,word in minutes) is
   var byte D10
   var byte HH
   var byte MM

   HH = byte(minutes / 60)
   MM = byte(minutes % 60)
   HH = HH % 24

   format_time_bytes(device, HH, MM)
end procedure
-- -----------------------------------------------------------------------------
