-- Title: USART hardware control
-- Author: Stef Mientki, Copyright (c) 2002..2006, all rights reserved.
-- Adapted-by: Sebastien Lelong.
-- Compiler: >=2.4g
-- 
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: USART hardware control.
-- Routines for sending and receiving through the PIC-usart,
-- both RS232 and SPI are supported (for SPI see spi_hardware.jal)
-- Baudrate can simply be set through a human constant,
-- because the baudrate depending registers are calculated by this unit.
-- Baudrate is calculated, starting at the high baudrate flag,
-- which will ensure the highest possible accuracy.
-- SPI routines are setup for more SPI-devices,
-- in which case CS should be controled outside this unit.
--
-- TODO: should this be configurable ?
-- Transmission parameters are 8 databits, 1 stopbit, no parity, no handshake.
--



-- some variables made available under a general (pic-independant) name

var volatile bit serial_hw_data_available is PIR1_RCIF
var volatile bit serial_hw_data_ready	 is PIR1_TXIF


-- internal function, calculates and sets baudrate divider
-- and stores it in the appropiate register.
-- the high-speed / low-speed bit is not stored but returned as the result
--
-- Special attention is payed to the highest and lowest baudrates,
-- a deviation of 5% is accepted in these cases
--
-- Asynchronous baudrate settings (see also page 74/75 of DS40300B):
-- {{{
-- if TXSTA_BRGH = 0 (low speed)
--  SPBRG = ( Fosc / ( 64 * Baudrate ) ) -1
--
-- if TXSTA_BRGH = 1 (high speed)
--  SPBRG = ( Fosc / ( 16 * Baudrate ) ) -1
-- }}}
-- 
-- Synchronous baudrate settings:
--  * TXSTA_BRGH = 0 (low speed)
--  * SPBRG = ( Fosc / ( 4 * Baudrate ) ) -1
--
procedure _calculate_and_set_baudrate() is
	const max_deviation = 5  -- maximum % deviation of the realized baudrate

	if usart_hw_serial then
		-- SPBRG = ( Fosc / ( 4 * Baudrate ) ) -1
		-- first try high baudrate, will generate highest accuarcy
		-- to get the right rounding (5 + 10*f(x)) /10
		const usart_div =((5 + ( ( 10 * target_clock ) / ( 16 * serial_hw_baudrate ))  ) / 10 ) - 1

		-- special case if divider is 0,
		-- test if deviation is not too much
		if usart_div <= 0 then
			if (100 * (serial_hw_baudrate - (target_clock / 16) )) / serial_hw_baudrate >= max_deviation then
				pragma error  -- asynchronous baudrate is too high
			end if
		end if

		-- if divider small enough,
		-- calculate divider and set high-speed
		if usart_div <= 255 then
  			if usart_div >= 0 then 
				SPBRG = usart_div 
			else
				SPBRG = 0
			end if
  			TXSTA_BRGH = true
			-- try the low-speed mode
		else
  			const usart_div_low = ((((10 * target_clock) / ( 64 * serial_hw_baudrate )) + 5 ) / 10) - 1
			-- here divider will never be 0
			-- but special case to consider,
			-- if baudrate is just a little too low
			if (usart_div_low > 255) & (100 * ((target_clock / (64 * 256 )) - serial_hw_baudrate)) / serial_hw_baudrate < max_deviation then
				SPBRG = 255
				TXSTA_BRGH = false
				-- now calculate divider and set high-speed / low-speed bit
  			elsif usart_div_low <= 255 then
				if usart_div_low >= 0 then
					SPBRG = usart_div_low 
				else
					SPBRG = 0
				end if
				TXSTA_BRGH = false
  			else
				pragma error -- asynchronous baudrate is too low
  			end if
		end if

	else  -- synchronous mode
		const usart_div_sync = ( target_clock / ( 4 * serial_hw_baudrate )) - 1
		
		-- special case if divider is 0 or negative
		-- test if baudrate is a little bit too high
		if usart_div_sync <= 0 then
			if (100 * (serial_hw_baudrate - (target_clock / 4 ) )) / serial_hw_baudrate >= max_deviation then
				pragma error  -- synchronous baudrate is too high
			end if
		end if
		
		-- special case to consider,
		-- if baudrate is just a little too high
		if (usart_div_sync > 255) & (100 * ((target_clock / (4 * 256)  ) - serial_hw_baudrate)) / serial_hw_baudrate < max_deviation then
			SPBRG = 255
		elsif usart_div_sync <= 255 then
			if SPBRG >= 0 then
				SPBRG = usart_div_sync
			else
				SPBRG = 0
			end if
		else
			pragma error -- synchronous baudrate is too low
		end if
	end if

end procedure


-- Initializes the RS232 port, calculates baudrate registers.
-- Normally this routine should not be called by the user program,
-- it's called just once at the end of this unit
-- Only after "asynch_disable_hw" it's necessary to call this routine,
-- to enable the RS232 hardware again.
procedure serial_hw_init() is 
	-- Calculate and Load baudrate generator
	_calculate_and_set_baudrate()
	
	-- disable all USART interrupts
	PIE1_RCIE = false
	PIE1_TXIE = false
	
	-- Enable transmitter : TXSTA_TXEN=1 (preserve TXSTA_BRGH)
	TXSTA_TXEN = true

	-- Enable serial port : RCSTA_SPEN=1
	-- Enable receiving   : RCSTA_CREN=1
	RCSTA = 0x90

end procedure


-- Disables USART (wether used as RS232 or SPI),
-- so ports can be used (temporary) for other purposes.
-- USART can be enabled again by calling serial_hw_enable()
procedure serial_hw_disable() is
	-- wait till running transmissions are finished
	while !TXSTA_TRMT loop end loop
	-- Disable Serial port:
	RCSTA_SPEN = false
end procedure


-- Enables USART (wether used as RS232 or SPI),
procedure serial_hw_enable() is
	-- Enable Serial port
	RCSTA_SPEN = true
end procedure


-- Asynchronuous RS232 send routine, using the TX pin
-- Sends byte X (8 bit with no parity) to the serial port
-- First checks (and waits if necessary) if transmit buffer is empty
--
-- remark: PIR1-register (containing _TXIF-flag) must be in bank0 !!
procedure serial_hw_write(byte in data) is
	-- wait until TXREG is empty
	while ! PIR1_TXIF loop end loop
	-- then put new byte in TXREG (prepare for transmission)
	TXREG = data
end procedure


-- like Serial_H_write, but then with a word as input
-- The MSB is outputed first
procedure serial_hw_write_word(word in data) is
	var byte DX[2] at data
	-- can be blocked by debugging
	while ! PIR1_TXIF loop end loop
	TXREG = DX[1]
	-- this is necessary for damned good optimized compilers
	-- loading of the TXREG doesn't immediatly set PIR1_TXIF !!!!
	asm nop
	while ! PIR1_TXIF loop end loop
	TXREG = DX[0]
end procedure


-- Returns true if a character was received, otherwise returns false.
-- Overrun error flag is cleared.
function serial_hw_read(byte out data) return bit is
	-- test if byte available, and if so,
	-- get byte and transport to outer world
	if PIR1_RCIF then
		data = RCREG
	else
		return false  ;result = false
	end if
	
	if RCSTA_OERR then
		RCSTA_CREN = false
		RCSTA_CREN =true
	end if
  
	return true
end function

-- Here Serial read and write are definied as pseudo variables
-- so you use them as normal vars, like
--  * wait for character being received,
--  * then echo the inverted character
-- {{{
-- serial_hw_data = ! serial_hw_data
-- }}}
--
-- these procedures will wait till they can perform their action
-- therefore it's better to use to following construct
-- {{{
-- -- if charater received, echo the inverted character
-- if  serial_hw_data_available then
--     serial_hw_data = ! serial_hw_data
-- end if
-- -- do other things
-- }}}
--
procedure serial_hw_data'put(byte in data) is
	-- -----------------------------------------------
	-- BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG	  
	-- -----------------------------------------------
	-- this doesn't work (always?)
	  serial_hw_write(data)
	-- tested by putting the next statement instead
	;  serial_hw_write(0x33)
end procedure


function serial_hw_data'get() return byte is
	var byte data
	while ! serial_hw_read(data) loop end loop
	return data
end function


-- These are real raw procedures, declared as pseudo variables
-- the user is totally responsible for testing the transmit/receive
-- flag before using these functions
procedure serial_hw_data_raw'put(byte in data) is
	TXREG = data
end procedure

function serial_hw_data_raw'get() return byte is
	return RCREG
end function

