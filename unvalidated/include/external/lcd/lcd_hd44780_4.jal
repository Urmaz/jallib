-- -----------------------------------------------------------------------------
-- Title: LCD library for HD44780 compatible LCDs, with 4 bits wide datatransfer
-- Author: Rob Hamerling, Copyright (c) 2008..2008, all rights reserved.
-- Adapted-by: Eur van Andel
-- Compiler:  >=2.4g
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Sources:
--
-- Description: Controls HD44780 compatible alphanumeric LCD screens.
--              Screens can range from 2x8  (2 lines, 8 chars) to 4x20.
--              Uses 4 bit wide datapath + 2 handshake lines (total 6 PIC pins).
--              Expects: - 2 pins for handshake: 'lcd_rs' and 'lcd_en'
--                       - 1 port nibble for data: 'lcd_dataport'
--
-- Dependencies: delay_any_mc.jal
--
-- Code example:
--
-- The application program must declare the following variables (aliases)
-- _before_ the include of this library!
--
-- var  byte lcd_dataport            is  portA_low         -- LCD data
-- var  byte lcd_dataport_direction  is  portA_low_direction
-- var  bit  lcd_en                  is  pin_A4            -- LCD data trigger
-- var  bit  lcd_en_direction        is  pin_A4_direction
-- var  bit  lcd_rs                  is  pin_A5            -- LCD cmd/data select
-- var  bit  lcd_rs_direction        is  pin_A5_direction
--
-- Above is an example: Bits 0..3 of portA are used for data, pins 4 and 5 of
-- portA are used for handshake. Any other available nibble and handshake pins
-- could be used (provided these are configurable for output).
--
-- Available functions for application programs:
--       lcd_setup()                               (called automatically)
--       lcd_clearscreen()                         clear screen, cursor home
--       lcd_setcursor(<row>,<column>)             position cursor
--       lcd_writechar(<byte>)                     write single character
--                                                 at cursor position and
--                                                 shift cursor position 1 right
-- A pseudo variable 'lcd' is available as alternative for lcd_writechar(<byte>):
--       var byte lcd
-- So in stead of writing: lcd_writechar(<byte>)
-- you may write:          lcd = <byte>
--
-- -----------------------------------------------------------------------------

include delay_any_mc                            -- delay procedures

-- -----------------------------------------------------
-- Write nibble (lower order 4 bits of byte) to LCD.
-- Nibble is sent to dataport.
-- lcd_rs is not touched: function can be used for commands and data.
-- When wait is required after write then caller should wait
-- (in 4-bit mode only required after second nibble).
-- -----------------------------------------------------

procedure  _lcd_writenibble(byte in data) is

   lcd_dataport = data                          -- replace low nibble
   lcd_en = HIGH                                -- trigger on
   asm nop                                      -- wait (> 400 ns)
   lcd_en = LOW                                 -- trigger off

end procedure

-- ----------------------------------------------------------
-- Send byte to the LCD as 2 nibbles (most significant nibble first)
-- (and automatically set the cursor one position right)
-- ----------------------------------------------------------

procedure  lcd_writechar(byte in c) is

   _lcd_writenibble(c >> 4)                     -- write high nibble
   _lcd_writenibble(c)                          -- write low nibble
   delay_10us(4)                                -- > 37 us

end procedure


-- ----------------------------------------------------------
-- Pseudo variable 'lcd' as alternative for lcd_writechar(<byte>)
-- ----------------------------------------------------------

procedure  lcd'put(byte in c) is
   lcd_writechar(c)
end procedure


-- ------------------------------------------------------------
-- Clear screen
-- (and set the cursor to the upper left corner: row 0, column 0)
-- ------------------------------------------------------------

procedure  lcd_clearscreen() is

   lcd_rs = LOW                                 -- set to control char mode
   lcd_writechar(0b0000_0001)                   -- clear screen, cursor home
   delay_1ms(2)                                 -- > 1.5 ms
   lcd_rs = HIGH                                -- set to data char mode

end procedure


-- About cursor positions: the LCDs are internally 2x40 char devices.
-- The first line starts at offset 0, the second line at offset 64 (0x40).
-- With a 4x16 or 4x20 LCD the third line starts at offset 20 and the
-- fourth line at offset 84 (0x40 + 20).
-- Note: Some 1x16 LCDs are implemented as 2x8 line LCDs, which means that
--       the second half of the line has to be handled as the second line.
--
-- ------------------------------------------------------------
-- Set cursor position
-- Specify row and column in base-0 notation (first line is 0).
-- ------------------------------------------------------------

procedure  lcd_setcursor(byte in row, byte in col)  is

   col = col | 0b1000_0000                      -- set to DRAM offset top line
   case row of
      1: col = col + 0x40                       -- 2nd line of 2 or 4 line displays
      2: col = col        + 20                  -- 3rd line  \ 4x16 or
      3: col = col + 0x40 + 20                  -- 4th line  / 4x20
   end case
   lcd_rs = LOW                                 -- set to control char mode
   lcd_writechar(col)                           -- set new cursor position
   lcd_rs = HIGH                                -- set to data char mode

end procedure


-- -----------------------------------------------------
-- Initialize LCD
-- - global init to 4-bit data mode
-- - 2-line (/ 4-line) mode, shift right invisible cursor
-- -----------------------------------------------------

procedure  lcd_setup()  is

-- Initialize the port and pin directions

   lcd_dataport_direction = all_output          -- make datapath output
   lcd_en_direction       = output              -- \
   lcd_rs_direction       = output              -- / make handshake lines output

-- Initialize HD44780 controller for 4-bit data mode

   lcd_rs = LOW                                 -- set to control char mode
   delay_1ms(15)                                -- 15 ms power-up delay
   _lcd_writenibble(0b0000_0011)                -- function set
   delay_1ms(5)                                 -- > 4.1 milliseconds
   _lcd_writenibble(0b0000_0011)                -- function set
   delay_10us(10)                               -- > 100 æs
   _lcd_writenibble(0b0000_0011)                -- function set
   delay_10us(4)                                -- > 37 æs
   _lcd_writenibble(0b0000_0010)                -- to 4-bit mode
   delay_10us(4)                                -- > 37 æs
   lcd_writechar(0b0010_1000)                   -- 4-bits, 2 lines, 5x8 font
   lcd_writechar(0b0001_1100)                   -- cursor move right
   lcd_writechar(0b0000_1100)                   -- display on, cursor,blink off
   lcd_writechar(0b0000_0110)                   -- cursor->right, no shift
   lcd_clearscreen()                            -- clear screen
                                                -- (incl switch to data char mode)
end procedure


-- -----------------------------------------------------
-- actually initialize the LCD
-- -----------------------------------------------------

lcd_setup()                                     -- to get the LCD active

-- -----------------------------------------------------

