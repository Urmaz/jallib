-- Title: LCD library
-- Author: Rob Hamerling, Copyright (c) 2008..2008, all rights reserved.
-- Adapted-by: Eur van Andel
-- Compiler:  >=2.4g
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Sources:
--
-- Description: controls HD44780 compatible alphanumeric LCD screens
-- screens can range from 2x8  (2 lines, 8 chars) to 4x20.
-- 4 bit connection, uses 6 PIC pins
--
-- Expects: - 2 pins for handshake: lcd_rs and lcd_en
--          - a port nibble for data: data_port
--
-- Example below, handshake pins can be on a different port, data pins can be high nibble as well
--
-- var  bit  LCD_RS     is pin_x5       -- LCD command/data select.
-- var  bit  LCD_EN     is pin_x4       -- LCD data trigger
-- var byte data_port   is portx_low    -- LCD data
-- portx_low_direction  = all_output    -- LCD data is portx_low
--
-- These parameters should be specified _before_ the include of this library.
--

include delay_any_mc                -- delay procedures

-- =======================================================================
--                 LCD procedures and functions
-- =======================================================================

-- -----------------------------------------------------
-- Write nibble (lower order 4 bits of byte) to LCD.
-- Nibble is sent to data_port.
-- RS not touched: function can be used for commands and data
-- Required wait after write expected to be done by caller,
-- in 4-bit mode only required after second nibble.
-- -----------------------------------------------------

procedure  lcdwrtnibble(byte in data) is

  data_port = data                              -- replace low nibble
  LCD_EN = high                                 -- trigger on
  asm nop                                       -- wait (> 400 ns)
  LCD_EN = low                                  -- trigger off

end procedure

-- ----------------------------------------------------------
-- Send byte to the LCD as 2 nibbles (most significant first)
-- ----------------------------------------------------------

procedure  lcdwrtchar(byte in c) is

  lcdwrtnibble(c >> 4)                          -- write high nibble
  lcdwrtnibble(c)                               -- write low nibble
  delay_10us(4)                                 -- > 37 æs

end procedure


-- procedure lcd'put(byte in c) is

--  lcdwrtnibble(c >> 4)                          -- write high nibble
--  lcdwrtnibble(c)                               -- write low nibble
--  delay_10us(4)                                 -- > 37 æs

-- end procedure


-- ------------------------------------------------------------
-- Clear screen LCD
-- ------------------------------------------------------------

procedure  lcdclearscreen() is

  LCD_RS = low                                  -- control character follows
  lcdwrtchar(0b0000_0001)                       -- clear screen, cursor home
  delay_10us(150)                               -- 1.5 ms
  LCD_RS = high                                 -- switch back to data chars

end procedure


-- ------------------------------------------------------------
-- Set cursor position
-- ------------------------------------------------------------

procedure  lcdsetcursor(byte in row, byte in col)  is

  col = col | 0b1000_0000                       -- add offset top line
  if (row > 0) then                             -- 2nd line req'd
    col = col | 0b0100_0000                     -- add offset 2nd line
  end if
  LCD_RS = low                                  -- control character follows
  lcdwrtchar(col)                               -- new cursor position
  LCD_RS = high                                 -- switch back to data chars

end procedure

-- -----------------------------------------------------
-- Initialize LCD
-- - global init
-- - 2-line mode, no cursor
-- -----------------------------------------------------

procedure  lcdsetup()  is

  LCD_RS = low                                  -- set control mode
  delay_1ms(15)                                 -- 15 ms power-up delay
  lcdwrtnibble(0b0000_0011)                     -- function set
  delay_1ms(5)                                  -- > 4.1 milliseconds
  lcdwrtnibble(0b0000_0011)                     -- function set
  delay_10us(110)                               -- > 100 æs
  lcdwrtnibble(0b0000_0011)                     -- function set
  delay_10us(4)                                 -- > 37 æs
  lcdwrtnibble(0b0000_0010)                     -- to 4-bit mode
  delay_10us(4)                                 -- > 37 æs
  lcdwrtchar(0b0010_1000)                       -- 4-bits, 2 lines, 5x8 font
  lcdwrtchar(0b0001_1100)                       -- cursor move right
  lcdwrtchar(0b0000_1100)                       -- display on, cursor,blink off
  lcdwrtchar(0b0000_0110)                       -- cursor->right, no shift
  lcdclearscreen                                -- clear screen
                                                -- incl switch to data mode
end procedure


-- startup code

lcdsetup()                                    -- to get the LCD running

