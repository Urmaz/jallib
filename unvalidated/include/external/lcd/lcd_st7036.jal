-- Title: control for ST7036 based LCD
-- Author: Richard Zengerink,  Copyright (c) 2008, all rights reserved
--
-- Compiler: =2.4g
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)

-- Description:
-- -----------------------------------------------------------------------------
-- Library for the control of ST7036 controller LCD's
--
-- this type can be attached to your microcontroller parallel 4 or 8 line
-- whiche makes a total of 7 to 11 lines or serial with only 4 lines in total
--
-- example type name: EA DOG-M order at WWW.CONRAD.nl  order nr:181874
--

--
-- ------------- place this below, in your MAIN file and add to    ---------
-- ------------- the pins which are not used the variable:         ---------
-- ------------- "not_connected".                                  ---------
-- ------------- change the other pins according to your hardware. ---------
-- ------------- (now selected as serial)                          ---------
-- ------------- also remove the "--"                              ---------
--
-- var bit not_connected
--
--
-- var volatile bit lcd_data  is pin_d0
-- var volatile bit lcd_data_dir  is pin_d0_direction
-- var volatile bit lcd_clock  is pin_d1
-- var volatile bit lcd_enable  is not_connected
-- var volatile bit lcd_rw is not_connected
-- var volatile bit lcd_rs is pin_d2   -- data/command select
-- var volatile bit lcd_csb  is pin_d3
--
-- var volatile bit lcd_d0 is not_connected
-- var volatile bit lcd_d1 is not_connected
-- var volatile bit lcd_d2 is not_connected
-- var volatile bit lcd_d3 is not_connected
-- var volatile bit lcd_d4 is not_connected
-- var volatile bit lcd_d5 is not_connected
-- var volatile bit lcd_d6 is not_connected
-- var volatile bit lcd_d7 is not_connected
--
--
-- const lcd_hardware = 1    ;4 is 4 line, 8 = 8 line and 1 is serial
-- const lcd_number_of_display_lines      = 2  ; 1,2,3
-- const lcd_number_of_display_characters = 16 ;
--
--
-- include lcd_st7036_rz
-- --------------------------------------------------------------------------
-- --------------------------------------------------------------------------
--
--
--
--
--
--
--
-- -------------------------------------------------------------------------
--  procedures which can be used in your Main file
-- -------------------------------------------------------------------------
--
-- * lcd_write_data( byte in value ):
--   writes (byte) data to lcd
--   example: lcd_write_data( "E" )  or lcd_write_data( 69 )
--        ---------------
-- * lcd_new_line_cursor_position (byte in line, byte in pos):
--   places the cursor on position (pos) in line (line)
--   example: lcd_new_line_cursor_position (1, 8)
--         --------------
-- * lcd_shift_left (byte in value):
--   shifts the display [value] times to the left without changing DDRAM data.
--   example: lcd_shift_left (4)
--   or       lcd_shift_left(variable)
--
-- * lcd_shift_right  (byte in value):
--   shifts the display [value] times to the right without changing DDRAM data.
--   example: lcd_shift_right (12)
--   or       lcd_shift_right(variable)
--
-- * lcd_cursor_shift_left (byte in value):
--   shifts the cursor [value] times to the left without changing display
--   contents and DDRAM data.
--   example: lcd_cursor_shift_left (8)
--   or       lcd_cursor_shift_left(variable)
--
-- * lcd_cursor_shift_right (byte in value):
--   shifts the cursor [value] times to the right without changing display
--   contents and DDRAM data.
--   example: lcd_cursor_shift_right (3)
--   or       lcd_cursor_shift_right(variable)
--
-- * lcd_clear:
--   Write "20H" to DDRAM. and set
--   DDRAM address to "00H" from AC
--
-- * lcd_home:
--   Set DDRAM address to "00H" from
--   AC and return cursor to its original
--   position if shifted. The contents of
--   DDRAM are not changed.
--
-- * lcd_cursor_blink_display (bit in cursor,bit in blink,bit in display):
--   sets the cursor on/off, let the cursor blink or not (if the cursor is on),
--   and puts the display on/off
--   example: lcd_cursor_blink_display (on,off,on)
--
-- * lcd_clear_line  ( byte in line  )
--   clears the line [line] of the lcd including DDRAM data of that line
--   example: lcd_clear_line (1)
--
-- * lcd_progress  (byte in line, byte in amount)
--   create a progress bar on line [line] with a lenght of [amout]
--   example: lcd_progress  (2,12)
--
--
-- * lcd_bvalue_dp_line_pos_left_sign ( byte in value, byte in dp, byte in line, byte in poskar, bit in left, bit in sign )
--   displays a byte value with decimal point on position [dp] on line [line] on position [pos] left alignment true/false,
--   signed value true/false
--   byte value = 0 to 255 as value or as variable, dp = 0 means 100 dp = 1 means 10.0 dp = 2 means 1.00 and dp > than 3 means 0.100
--
--
--   example1: lcd_bvalue_dp_line_pos_left_sign (25,0,1,5,true,false)
--   result on line 1 on position 5 you get 25
--
--   example2: lcd_bvalue_dp_line_pos_left_sign (25,0,1,5,false,false)
--   result on line 1 on position 5 you get [space]25 (25 starts at position 6)
--
--   example3: lcd_bvalue_dp_line_pos_left_sign (225,0,2,1,true,true)
--   result on line 2 on position 1 you get -31
--
--   example4: lcd_bvalue_dp_line_pos_left_sign (225,0,2,1,true,false)
--   result on line 2 on position 1 you get 225
--
--
-- * lcd_wvalue_dp_line_pos_left_sign ( word in value, byte in dp, byte in line, byte in poskar, bit in left, bit in sign )
--
--
--
-- * lcd_time ( byte in hrs, byte in minut, byte in second, byte in seperator )
--
--
--
-- * lcd_date ( byte in day, byte in mounth, word in year, byte in seperator, bit in day_mounth_notation )
--
--
-- -------------------------------------------------------------------------
--  Start of code
-- -------------------------------------------------------------------------
--
-- -----------------------------------------------------------------------------
-- delay's necessary for initialisation and some commands
-- -----------------------------------------------------------------------------
const lcd_short_delay     = 5   -- delay in 10 usec units

const lcd_long_delay      = 180 -- delay in 10 usec units

-- -----------------------------------------------------------------------------

-- -----------------------------------------------------------------------------
-- some constants to control the lcd
-- -----------------------------------------------------------------------------
const lcd_clear_display       = 0b_0000_0001
const lcd_return_home         = 0b_0000_0010

const lcd_display_onoff       = 0b_0000_1000

const lcd_cursor_shift_r_val  = 0b_0001_0100
const lcd_cursor_shift_l_val  = 0b_0001_0000
const lcd_display_shift_right = 0b_0001_1100
const lcd_display_shift_left  = 0b_0001_1000


const lcd_set_CGRAM_address   = 0b_0100_0000
const lcd_set_DDRAM_address   = 0b_1000_0000
-- -----------------------------------------------------------------------------


var byte lcd_maxdigit
var byte lcd_nodigit

var volatile byte lcd_pos = 0


-- ----------------------------------------------------------------------------
-- generate clockpuls
-- (this routine is only used inside this file)
-- ----------------------------------------------------------------------------
procedure lcd_clock  is
    -- generate clockpuls
  if lcd_hardware == 4 | lcd_hardware == 8 then
     lcd_Enable  = high   -- enable high
     delay_10uS ( 4 )
     lcd_Enable  = low    -- enable  high --> low = clock data
  end if

  if lcd_hardware == 1 then
     lcd_clk = high
     delay_10uS ( 4 )
     lcd_clk = low
  end if
end procedure
-- ----------------------------------------------------------------------------

-- ----------------------------------------------------------------------------
-- sends low nibble from value to the lcd
-- can be used for both commands and data
-- (requires no wait cycli inbetween upper and lower nibble)
-- (this routine is only used inside this file)
-- ----------------------------------------------------------------------------
procedure lcd_write_low_nibble ( byte in value ) is
  var bit bit0 at value : 0
  var bit bit1 at value : 1
  var bit bit2 at value : 2
  var bit bit3 at value : 3

  -- setup databits
  lcd_d4 = bit0
  lcd_d5 = bit1
  lcd_d6 = bit2
  lcd_d7 = bit3


  -- generate clockpuls
  lcd_clock
end procedure
-- ----------------------------------------------------------------------------





-- ----------------------------------------------------------------------------
-- sends byte from value to register of the lcd
-- (this procedure is only used inside this file)
-- ----------------------------------------------------------------------------
procedure lcd_write( byte in value ) is
   lcd_rw = low                   -- select write mode

   if lcd_hardware == 4 then
      lcd_write_low_nibble( value >> 4 ) -- output high nibble
      lcd_write_low_nibble( value )      -- output low nibble
   end if
   if lcd_hardware == 8 then
       var bit bit0 at value : 0
       var bit bit1 at value : 1
       var bit bit2 at value : 2
       var bit bit3 at value : 3
       var bit bit4 at value : 4
       var bit bit5 at value : 5
       var bit bit6 at value : 6
       var bit bit7 at value : 7

        -- setup databits
       lcd_d0 = bit0
       lcd_d1 = bit1
       lcd_d2 = bit2
       lcd_d3 = bit3
       lcd_d4 = bit4
       lcd_d5 = bit5
       lcd_d6 = bit6
       lcd_d7 = bit7

       lcd_clock
   end if

   if lcd_hardware == 1 then
      for 8 loop
          var bit bit7 at value : 7
          lcd_data = bit7
          lcd_clock
          value = value << 1
      end loop
   
   end if

end procedure
-- ----------------------------------------------------------------------------


-- ----------------------------------------------------------------------------
-- sends data byte in value to lcd
--
--
-- ----------------------------------------------------------------------------
procedure lcd_write_data( byte in value ) is
   lcd_rs = high                   -- select instruction
   lcd_write( value )                 -- output byte
   delay_10uS( lcd_short_delay )      -- required delay
end procedure
-- ----------------------------------------------------------------------------


-- ----------------------------------------------------------------------------
-- sends command byte in value to lcd
-- for slow commands an extra delay should be added
-- (this routine is only used inside this file)
-- ----------------------------------------------------------------------------
procedure lcd_write_Command( byte in value ) is
   lcd_rs = low                   -- select instruction
   lcd_write( value )                 -- output byte
   delay_10uS(lcd_short_delay )      -- required delay
end procedure
-- ----------------------------------------------------------------------------



-- ----------------------------------------------------------------------------
-- sets the cursor of the lcd to the position in the shadow register
-- (this routine is only used inside this file)
-- ----------------------------------------------------------------------------
procedure lcd_restore_cursor is
  -- set lcd back to normal operation
  lcd_write_Command ( lcd_set_ddram_address | lcd_pos )
end procedure
-- ----------------------------------------------------------------------------


-- ----------------------------------------------------------------------------
-- sets the cursor of the lcd on "pos" position in line "line" in the shadow register
--
-- ----------------------------------------------------------------------------
procedure lcd_new_line_cursor_position (byte in line, byte in pos) is
  pos = pos -1
  if lcd_number_of_display_lines == 1 then
    lcd_pos = pos

  elsif lcd_number_of_display_lines == 2 then
    if line == 1 then
       lcd_pos = pos
    else
       lcd_pos = pos + 0x40
    end if
  else -- 3 lines
    if    line == 1 then lcd_pos = pos
    elsif line == 2 then lcd_pos = pos + 0x10
    else  line == 3 then lcd_pos = pos + 0x20
    end if
  end if

  lcd_restore_cursor
end procedure

-- ----------------------------------------------------------------------------

-- ----------------------------------------------------------------------------
-- shifts the coplete display one position to the left
-- ----------------------------------------------------------------------------
procedure lcd_shift_left (byte in value) is
  -- set lcd back to normal operation

  if value != 0 then
      for value loop
          lcd_write_Command ( lcd_display_shift_left )
          delay_10uS ( lcd_short_delay )
      end loop
  end if
end procedure
-- ----------------------------------------------------------------------------

-- ----------------------------------------------------------------------------
-- shifts the complete display one position to the right
-- ----------------------------------------------------------------------------
procedure lcd_shift_right  (byte in value) is
  if value != 0 then
      for value loop
          lcd_write_Command ( lcd_display_shift_right )
          delay_10uS ( lcd_short_delay )
      end loop
  end if
end procedure
-- ----------------------------------------------------------------------------




-- ----------------------------------------------------------------------------
-- shifts cursor one position to the left
-- ----------------------------------------------------------------------------
procedure lcd_cursor_shift_left (byte in value) is
  if value != 0 then
      for value loop
          lcd_write_Command ( lcd_cursor_shift_l_val )
          delay_10uS ( lcd_short_delay )
      end loop
  end if
end procedure
-- ----------------------------------------------------------------------------

-- ----------------------------------------------------------------------------
-- shifts cursor one position to the right
-- ----------------------------------------------------------------------------
procedure lcd_cursor_shift_right (byte in value) is
  if value != 0 then
      for value loop
          lcd_write_Command ( lcd_cursor_shift_r_val )
          delay_10uS ( lcd_short_delay )
      end loop
  end if
end procedure
-- ----------------------------------------------------------------------------


-- ----------------------------------------------------------------------------
-- clears the lcd
-- ----------------------------------------------------------------------------
procedure lcd_clear  is
         lcd_write_Command ( lcd_clear_display )
         delay_10uS ( lcd_long_delay )
end procedure
-- ----------------------------------------------------------------------------


-- ----------------------------------------------------------------------------
-- sets or resets cursor blink and puts display on or off
-- ----------------------------------------------------------------------------
procedure lcd_cursor_blink_display (bit in cursor,bit in blink,bit in display) is
  var byte Register

  Register = lcd_display_onoff
  if display then Register = Register + 4 end if
  if cursor  then Register = Register + 2 end if
  if blink   then Register = Register + 1 end if
  lcd_write_Command ( Register )
end procedure
-- ----------------------------------------------------------------------------



-- ----------------------------------------------------------------------------
-- cursor returns home (line 1, position 1)
-- ----------------------------------------------------------------------------
procedure lcd_home  is
         lcd_write_Command ( lcd_return_home )
         delay_10uS ( lcd_long_delay )
end procedure
-- ----------------------------------------------------------------------------


-- ----------------------------------------------------------------------------
-- clears the line "line" of the lcd
-- ----------------------------------------------------------------------------
procedure lcd_clear_line  ( byte in line  ) is
  -- set lcd-cursor at start of line
  if lcd_number_of_display_lines == 1 then    ; 1 line display
     lcd_pos = 0
     lcd_restore_cursor
     for 80 loop
         lcd_write_data( " " )
     end loop
  elsif lcd_number_of_display_lines == 2 then ; 2 line display
     if line == 1 then lcd_pos = 0 end if
     if line == 2 then lcd_pos = 0x40 end if
     lcd_restore_cursor
     for 40 loop
         lcd_write_data( " " )
     end loop


  else -- 3 lines
     if     line == 1 then lcd_pos = 0        ; 3 line display
      elsif line == 2 then lcd_pos = 0x10
      else  line == 3 then lcd_pos = 0x20
     end if
     lcd_restore_cursor
     for 16 loop
         lcd_write_data( " " )
     end loop
  end if
  lcd_restore_cursor    ;set cursor at begin of deleted line
end procedure
-- ----------------------------------------------------------------------------



-- -----------------------------------------------------------------------------
-- Displays a progress bar
--
-- -----------------------------------------------------------------------------
procedure lcd_progress  (byte in line, byte in amount, byte in Pattern) is
  if lcd_number_of_display_lines == 1 then    ; 1 line display
     lcd_pos = pos
  elsif lcd_number_of_display_lines == 2 then ; 2 line display
     if line == 1 then lcd_pos = 0 end if
     if line == 2 then lcd_pos = 0x40 end if
  else -- 3 lines
     if     line == 1 then lcd_pos = 0        ; 3 line display
      elsif line == 2 then lcd_pos = 0x10
      else  line == 3 then lcd_pos = 0x20
     end if
  end if
 lcd_restore_cursor
  for amount loop
      lcd_write_data( Pattern )
  end loop
  
  for ( lcd_number_of_display_characters - amount) loop
        lcd_write_data( " " )
  end loop

end procedure
-- ----------------------------------------------------------------------------




-- -----------------------------------------------------------------------------
-- Displays a value (byte), white or without Decimal Point, on specified line
-- and position , non leading zero ,with or without left alignment, signed
-- or not signed.
-- -----------------------------------------------------------------------------
procedure lcd_bvalue_dp_line_pos_left_sign ( byte in value, byte in dp, byte in line, byte in poskar, bit in left, bit in sign ) is
   var byte digit0 = 0
   var byte digit1 = 0
   var byte digit2 = 0
   var bit negative = false
   
   if sign then
      if value >= 128   then
         negative = true
         value = 128 - (value - 128)
      end if
   end if

   while value >= 100 loop
      digit2 = digit2 + 1
      value = value - 100
   end loop

   while value >= 10 loop
      digit1 = digit1 + 1
      value = value - 10
   end loop

   digit0 = value
   
   if digit2 == 0 & dp < 2 then
      digit2 = 32
   else
      digit2 = digit2 + 48
   end if

   if digit1 == 0 & digit2 == 32 & dp < 1 then
      digit1 = 32
   else
      digit1 = digit1 + 48
   end if

   digit0 = digit0 + 48

   
   lcd_new_line_cursor_position (line, poskar)
   
   var bit Decp = false
   var byte counter = 0
   lcd_nodigit = 0

         for 5 loop

          if negative then
             lcd_write_data ("-")
             negative = false
             lcd_nodigit = lcd_nodigit + 1
           end if

          if dp > 2 & !Decp  then
             lcd_write_data (".")
             Decp = true
             lcd_nodigit = lcd_nodigit + 1
          else
             if counter == 1 then
                if !left | digit2 != 32 then
                   lcd_write_data (digit2)
                   lcd_nodigit = lcd_nodigit + 1
                end if
             end if
             if counter == 2 then
                if !left | digit1 != 32 then
                   lcd_write_data (digit1)
                   lcd_nodigit = lcd_nodigit + 1
                end if
             end if
             if counter == 3 then
                if !left | digit0 != 32 then
                   lcd_write_data (digit0)
                   lcd_nodigit = lcd_nodigit + 1
                end if
             end if
             counter = counter + 1
          end if

          if dp != 0 then
             dp = dp + 1
          end if

       end loop

       if lcd_nodigit > lcd_maxdigit then
          lcd_maxdigit = lcd_nodigit
       else
          while lcd_maxdigit > lcd_nodigit  loop
                lcd_write_data (32)
                lcd_maxdigit = lcd_maxdigit - 1
          end loop
       end if

end procedure
-- ----------------------------------------------------------------------------



-- -----------------------------------------------------------------------------
-- Displays a value (word), white or without Decimal Point, on specified line
-- and position,  non leading zero ,with or without left alignment, signed
-- or not signed
-- -----------------------------------------------------------------------------

procedure lcd_wvalue_dp_line_pos_left_sign ( word in value, byte in dp, byte in line, byte in poskar, bit in left, bit in sign ) is
   var byte digit0 = 0   ;l
   var byte digit1 = 0   ;10
   var byte digit2 = 0   ;100
   var byte digit3 = 0   ;1000
   var byte digit4 = 0   ;10000
   var bit negative = false

if sign then
   if value >= 32768   then
      negative = true
      value = 32768 - (value - 32768)
   end if
end if

while value >= 10000 loop
      digit4 = digit4 + 1
      value = value - 10000
end loop

while value >= 1000 loop
      digit3 = digit3 + 1
      value = value - 1000
end loop

while value >= 100 loop
      digit2 = digit2 + 1
      value = value - 100
end loop

while value >= 10 loop
      digit1 = digit1 + 1
      value = value - 10
end loop

digit0 = value

if digit4 == 0 & dp < 4 then
   digit4 = 32
else
   digit4 = digit4 + 48
end if

if digit3 == 0 & digit4 == 32 & dp < 3 then
   digit3 = 32
else
   digit3 = digit3 + 48
end if

if digit2 == 0 & digit3 == 32 & digit4 == 32 & dp < 2 then
   digit2 = 32
else
   digit2 = digit2 + 48
end if
   
if digit1 == 0 & digit2 == 32 & digit3 == 32 & digit4 == 32 & dp < 1 then
   digit1 = 32
else
   digit1 = digit1 + 48
end if

digit0 = digit0 + 48



 lcd_new_line_cursor_position (line, poskar)

 var bit Decp = false
 var byte counter = 0
 lcd_nodigit = 0

         for 7 loop

          if negative then
             lcd_write_data ("-")
             negative = false
             lcd_nodigit = lcd_nodigit + 1
           end if

          if dp > 5 & !Decp  then
             lcd_write_data (".")
             Decp = true
             lcd_nodigit = lcd_nodigit + 1
          else
             if counter == 1 then
                if !left | digit4 != 32 then
                   lcd_write_data (digit4)
                   lcd_nodigit = lcd_nodigit + 1
                end if
             end if
             if counter == 2 then
                if !left | digit3 != 32 then
                   lcd_write_data (digit3)
                   lcd_nodigit = lcd_nodigit + 1
                end if
             end if
             if counter == 3 then
                if !left | digit2 != 32 then
                  lcd_write_data (digit2)
                   lcd_nodigit = lcd_nodigit + 1
                end if
             end if
             if counter == 4 then
                if !left | digit1 != 32 then
                   lcd_write_data (digit1)
                   lcd_nodigit = lcd_nodigit + 1
                end if
             end if
             if counter == 5 then
                lcd_write_data (digit0)
                lcd_nodigit = lcd_nodigit + 1
             end if
             counter = counter + 1
          end if

          if dp != 0 then
             dp = dp + 1
          end if

       end loop
       if lcd_nodigit > lcd_maxdigit then
          lcd_maxdigit = lcd_nodigit
       else
          while lcd_maxdigit > lcd_nodigit  loop
               lcd_write_data (32)
                lcd_maxdigit = lcd_maxdigit - 1
          end loop
       end if
end procedure
-- ----------------------------------------------------------------------------

-- -----------------------------------------------------------------------------
-- Displays a time (byte),
-- -----------------------------------------------------------------------------

procedure lcd_time ( byte in hrs, byte in minut, byte in second, byte in seperator ) is
   var byte hrs_digit0 = 0   ;l
   var byte hrs_digit1 = 0   ;10
   var byte minut_digit0 = 0   ;1
   var byte minut_digit1 = 0   ;10
   var byte second_digit0 = 0   ;1
   var byte second_digit1 = 0   ;10

   while hrs >= 10 loop
      hrs_digit1 = hrs_digit1 + 1
      hrs = hrs - 10
   end loop
   hrs_digit0 = hrs + 48
   hrs_digit1 = hrs_digit1 + 48
   while minut >= 10 loop
      minut_digit1 = minut_digit1 + 1
      minut = minut - 10
   end loop
   minut_digit0 = minut +48
   minut_digit1 = minut_digit1 + 48
   while second >= 10 loop
      second_digit1 = second_digit1 + 1
      second = second - 10
   end loop
   second_digit0 = second + 48
   second_digit1 = second_digit1 + 48

   lcd_write_data (hrs_digit1  )
   lcd_write_data (hrs_digit0)
   lcd_write_data (seperator)
   lcd_write_data (minut_digit1)
   lcd_write_data (minut_digit0)
   lcd_write_data (seperator)
   lcd_write_data (second_digit1)
   lcd_write_data (second_digit0)

end procedure
-- ----------------------------------------------------------------------------

-- -----------------------------------------------------------------------------
-- Displays a date (byte),
-- -----------------------------------------------------------------------------

procedure lcd_date ( byte in day, byte in mounth, word in year, byte in seperator, bit in day_mounth_notation ) is
   var byte day_digit0 = 0   ;l
   var byte day_digit1 = 0   ;10
   var byte mounth_digit0 = 0   ;1
   var byte mounth_digit1 = 0   ;10
   var byte year_digit0 = 0   ;1
   var byte year_digit1 = 0   ;10
   var byte year_digit2 = 0   ;100
   var byte year_digit3 = 0   ;1000
   var word year_mem = year


   while day >= 10 loop
         day_digit1 = day_digit1 + 1
         day = day - 10
   end loop
   day_digit0 = day + 48
   day_digit1 = day_digit1 + 48
   while mounth >= 10 loop
         mounth_digit1 = mounth_digit1 + 1
         mounth = mounth - 10
   end loop
   mounth_digit0 = mounth +48
   mounth_digit1 = mounth_digit1 + 48



   while year >= 1000 loop
         year_digit3 = year_digit3 + 1
         year = year - 1000
   end loop

   while year >= 100 loop
         year_digit2 = year_digit2 + 1
         year = year - 100
   end loop

   while year >= 10 loop
         year_digit1 = year_digit1 + 1
         year = year - 10
   end loop
   year_digit3 = year_digit3 + 48
   year_digit2 = year_digit2 + 48
   year_digit1 = year_digit1 + 48
   year_digit0 = year + 48


   if !day_mounth_notation then
      lcd_write_data (mounth_digit1)
      lcd_write_data (mounth_digit0)
      lcd_write_data (seperator)
      lcd_write_data (day_digit1  )
      lcd_write_data (day_digit0)
      lcd_write_data (seperator)
   else
      lcd_write_data (day_digit1  )
      lcd_write_data (day_digit0)
      lcd_write_data (seperator)
      lcd_write_data (mounth_digit1)
      lcd_write_data (mounth_digit0)
      lcd_write_data (seperator)
   end if

   if year_mem > 100 then
      lcd_write_data (year_digit3)
      lcd_write_data (year_digit2)
   else
      lcd_write_data ("'")
   end if

   lcd_write_data (year_digit1)
   lcd_write_data (year_digit0)

end procedure
-- ----------------------------------------------------------------------------



-- -----------------------------------------------------------------------------
-- Displays a byte value in Hex,
-- -----------------------------------------------------------------------------
procedure lcd_bvalue_hex ( byte in value) is
  var byte temp
   lcd_write_data ("0")
   lcd_write_data ("x")
   temp = value >> 4
   if temp < 10 then
      lcd_write_data (temp + 48)
   else
      lcd_write_data (temp + 55)
   end if
   value = value & 0b00001111
   if value < 10 then
      lcd_write_data (value + 48)
   else
      lcd_write_data (value + 55)
   end if

end procedure

-- ----------------------------------------------------------------------------


-- -----------------------------------------------------------------------------
-- Displays a word value in Hex,
-- -----------------------------------------------------------------------------
procedure lcd_wvalue_hex ( word in value) is
  var byte temp
   lcd_write_data ("0")
   lcd_write_data ("x")
   temp = value >> 12
   if temp < 10 then
      lcd_write_data (temp + 48)
   else
      lcd_write_data (temp + 55)
   end if
   temp = value >> 8
   temp = temp & 0b00001111
   if temp < 10 then
      lcd_write_data (temp + 48)
   else
      lcd_write_data (temp + 55)
   end if
   temp = value >> 4
   temp = temp & 0b00001111
   if temp < 10 then
      lcd_write_data (temp + 48)
   else
      lcd_write_data (temp + 55)
   end if
   value = value & 0b0000000000001111
   if value < 10 then
      lcd_write_data (value + 48)
   else
      lcd_write_data (value + 55)
   end if

end procedure

-- ----------------------------------------------------------------------------








-- -----------------------------------------------------------------------------
-- Initialise display
-- (this routine is only used inside this file)
-- -----------------------------------------------------------------------------
procedure lcd_init is

 lcd_Enable = low
  delay_1mS ( 45 )                  --
  lcd_rw = low                      -- select command

     if lcd_hardware == 4  then
        lcd_write_low_nibble( 0b_0000_0011 ) --
        delay_1mS ( 2)                       --
        lcd_write_low_nibble( 0b_0000_0011 ) --
        delay_1mS ( 2 )                      --
        lcd_write_low_nibble( 0b_0000_0011 ) --
        delay_10uS( 4 )

        lcd_write_low_nibble( 0b_0000_0010 )--
        delay_10uS( 4 )

        if lcd_number_of_display_lines == 1 then
           lcd_write_low_nibble( 0b_0000_0010 )--
           delay_10uS( 4 )
           lcd_write_low_nibble( 0b_0000_0001 )--
           delay_10uS( 4 )
           lcd_write_low_nibble( 0b_0000_0001 )--
           delay_10uS( 4 )
           lcd_write_low_nibble( 0b_0000_0100 )--
        end if

        if lcd_number_of_display_lines == 2 then
           lcd_write_low_nibble( 0b_0000_0010 )--
           delay_10uS( 4 )
           lcd_write_low_nibble( 0b_0000_1001 )--
           delay_10uS( 4 )
           lcd_write_low_nibble( 0b_0000_0001 )--
           delay_10uS( 4 )
           lcd_write_low_nibble( 0b_0000_0100 )--
        end if

        if lcd_number_of_display_lines == 3 then
           lcd_write_low_nibble( 0b_0000_0010 )--
           delay_10uS( 4 )
           lcd_write_low_nibble( 0b_0000_1001 )--
           delay_10uS( 4 )
           lcd_write_low_nibble( 0b_0000_0001 )--
           delay_10uS( 4 )
           lcd_write_low_nibble( 0b_0000_0101 )--
        end if

       lcd_write_low_nibble( 0b_0000_0111 )--
       delay_10uS( 4 )
       lcd_write_low_nibble( 0b_0000_1000 )--
       delay_10uS( 4 )
       lcd_write_low_nibble( 0b_0000_0101 )--
       delay_10uS( 4 )
       lcd_write_low_nibble( 0b_0000_1110 )--
       delay_10uS( 4 )
       lcd_write_low_nibble( 0b_0000_0110 )--
       delay_10uS( 4 )
       lcd_write_low_nibble( 0b_0000_1010 )--
       delay_10uS( 4 )
       lcd_write_low_nibble( 0b_0000_0000 )--
       delay_10uS( 4 )
       lcd_write_low_nibble( 0b_0000_1100 )--
       delay_10uS( 4 )
       lcd_write_low_nibble( 0b_0000_0000 )--
       delay_10uS( 4 )
       lcd_write_low_nibble( 0b_0000_0001 )--
       delay_10uS( 4 )
       lcd_write_low_nibble( 0b_0000_0000 )--
       delay_10uS( 4 )
       lcd_write_low_nibble( 0b_0000_0110 )--
       delay_1mS( 4 )

    end if


    if lcd_hardware == 1 | lcd_hardware == 8 then
       if lcd_number_of_display_lines == 1 then
          lcd_write_Command( 0b_0011_0000 ) -- function set lcd port
          delay_10uS ( 3 )                       -- extra delay
          lcd_write_Command( 0b_0011_0001 ) -- function set lcd port
          delay_10uS ( 3 )                      -- extra delay
          lcd_write_Command( 0b_0001_0100 ) -- BIAS
          delay_10uS ( 3 )                      -- extra delay

       end if

       if lcd_number_of_display_lines == 2 then
          lcd_write_Command( 0b_0011_1000 ) -- function set lcd port
          delay_10uS ( 3 )                       -- extra delay
          lcd_write_Command( 0b_0011_1001 ) -- function set lcd port
          delay_10uS ( 3 )                      -- extra delay
          lcd_write_Command( 0b_0001_0100 ) -- BIAS
          delay_10uS ( 3 )                      -- extra delay

       end if

       if lcd_number_of_display_lines == 3 then
          lcd_write_Command( 0b_0011_1000 ) -- function set lcd port
          delay_10uS ( 3 )                       -- extra delay
          lcd_write_Command( 0b_0011_1001 ) -- function set lcd port
          delay_10uS ( 3 )                      -- extra delay
          lcd_write_Command( 0b_0001_0101 ) -- BIAS
          delay_10uS ( 3 )                      -- extra delay
       end if

       lcd_write_Command( 0b_0111_0000 ) -- contrast set
       delay_10uS( 3)                    -- extra delay
       lcd_write_Command( 0b_0101_1110 ) -- power/ICON/contrast control
       delay_10uS( 3 )
       lcd_write_Command( 0b_0110_1010 ) -- follower control
       delay_10mS( 21 )
       lcd_write_Command( 0b_0011_1000 ) -- function set lcd port
       delay_10uS ( 3 )                      -- extra delay
       lcd_write_Command( 0b_0000_1100 )-- display on/off control
  	   delay_10us( 3 )
       lcd_write_Command( 0b_0000_0001 )-- clear display
  	   delay_10us( 40 )
       lcd_write_Command( 0b_0000_0110 )-- entry mode set, cursor moves to right
  	   delay_10us( 40 )
    end if



end procedure


------------------------------------------------------------------------



lcd_init                  ; init the lcd

