-- ------------------------------------------------------
-- Title: control for ST7036 based LCD
--
-- Author: Richard Zengerink,  Copyright (c) 2008, all rights reserved
-- Adapted-by:
-- Compiler: =2.4
--
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: Library for the control of ST7036 LCD's in spi, 4 line en 8 line mode
--
-- Sources:
--
-- Notes:
--
--
-- ------------------------------------------------------
--
--
-- this type can be attached to your microcontroller parallel 4 or 8 line
-- whiche makes a total of 7 to 11 lines or serial with only 4 lines in total
--
-- example type name: EA DOG-M order at WWW.CONRAD.nl  order nr:181874
--

-- delay's necessary for initialisation and some commands
-- delay in 10 usec units
const LCD_SHORT_DELAY     = 5
-- delay in 10 usec units
const LCD_LONG_DELAY      = 18



-- some constants to control the lcd

const LCD_CLEAR_DISPLAY       = 0b_0000_0001
const LCD_RETURN_HOME         = 0b_0000_0010

const LCD_DISPLAY_ONOFF       = 0b_0000_1000

const LCD_CURSOR_SHIFT_R_VAL  = 0b_0001_0100
const LCD_CURSOR_SHIFT_L_VAL  = 0b_0001_0000
const LCD_DISPLAY_SHIFT_RIGHT = 0b_0001_1100
const LCD_DISPLAY_SHIFT_LEFT  = 0b_0001_1000

const LCD_SET_DDRAM_ADRESS   = 0b_1000_0000


var byte lcd_maxdigit
var byte lcd_nodigit

var volatile byte lcd_pos = 0


-- generate clockpuls
-- (this routine is only used inside this file)
procedure _lcd_clock()  is
     -- generate clockpuls
   if lcd_hardware == 4 | lcd_hardware == 8 then
      lcd_enable = high   -- enable high
      delay_10us(4)
      lcd_enable = low    -- enable  high --> low = clock data
   end if
 
   if lcd_hardware == 1 then
      lcd_clk = high
      delay_10us( 4 )
      lcd_clk = low
   end if
end procedure

-- sends low nibble from value to the lcd
-- can be used for both commands and data
-- (requires no wait cycli inbetween upper and lower nibble)
-- (this routine is only used inside this file)
procedure _lcd_write_low_nibble( byte in value ) is
  var bit bit0 at value : 0
  var bit bit1 at value : 1
  var bit bit2 at value : 2
  var bit bit3 at value : 3

  -- setup databits
  lcd_d4 = bit0
  lcd_d5 = bit1
  lcd_d6 = bit2
  lcd_d7 = bit3

  -- generate clockpuls
  _lcd_clock()
end procedure


-- sends byte from value to register of the lcd
-- (this procedure is only used inside this file)
procedure _lcd_write( byte in value ) is
   pragma inline
   lcd_rw = low                   -- select write mode
   lcd_csb = low
   if lcd_hardware == 4 then
      _lcd_write_low_nibble( value >> 4 ) -- output high nibble
      _lcd_write_low_nibble( value )      -- output low nibble
   end if
   if lcd_hardware == 8 then
       var bit bit0 at value : 0
       var bit bit1 at value : 1
       var bit bit2 at value : 2
       var bit bit3 at value : 3
       var bit bit4 at value : 4
       var bit bit5 at value : 5
       var bit bit6 at value : 6
       var bit bit7 at value : 7

        -- setup databits
       lcd_d0 = bit0
       lcd_d1 = bit1
       lcd_d2 = bit2
       lcd_d3 = bit3
       lcd_d4 = bit4
       lcd_d5 = bit5
       lcd_d6 = bit6
       lcd_d7 = bit7

       _lcd_clock()
   end if

   if lcd_hardware == 1 then
      for 8 loop
          var bit bit7 at value : 7
          lcd_data = bit7
          _lcd_clock()
          value = value << 1
      end loop
   
   end if
   lcd_csb = high
end procedure


-- sends data byte in value to lcd
procedure lcd_write_data( byte in value ) is
   lcd_rs = high                   -- select instruction
   _lcd_write( value )                 -- output byte
   delay_10us( LCD_SHORT_DELAY )      -- required delay
end procedure


-- sends command byte in value to lcd
-- for slow commands an extra delay should be added
-- (this routine is only used inside this file)
procedure _lcd_write_command( byte in value ) is
   lcd_rs = low                   -- select instruction
   _lcd_write( value )                 -- output byte
   delay_10us(LCD_SHORT_DELAY )      -- required delay
end procedure


-- sets the cursor of the lcd to the position in the shadow register
-- (this routine is only used inside this file)
procedure _lcd_restore_cursor() is
  _lcd_write_command( LCD_SET_DDRAM_ADRESS | lcd_pos )
end procedure


-- sets the cursor of the lcd on "pos" position in line "line" in the shadow register
procedure lcd_new_line_cursor_position(byte in line, byte in pos) is
  pos = pos -1
  if lcd_number_of_display_lines == 1 then
     lcd_pos = pos

  elsif lcd_number_of_display_lines == 2 then
        if line == 1 then
           lcd_pos = pos
        else
           lcd_pos = pos + 0x40
        end if
  else -- 3 lines
        if    line == 1 then lcd_pos = pos
        elsif line == 2 then lcd_pos = pos + 0x10
        else  line == 3 then lcd_pos = pos + 0x20
        end if
  end if

  _lcd_restore_cursor()
end procedure


-- shifts the complete display one position to the left
procedure lcd_shift_left(byte in value) is
  -- set lcd back to normal operation
  if value != 0 then
      for value loop
          _lcd_write_command( LCD_DISPLAY_SHIFT_LEFT )
          delay_10us( LCD_SHORT_DELAY )
      end loop
  end if
end procedure


-- shifts the complete display one position to the right
procedure lcd_shift_right(byte in value) is
  if value != 0 then
      for value loop
          _lcd_write_command( LCD_DISPLAY_SHIFT_RIGHT )
          delay_10us( LCD_SHORT_DELAY )
      end loop
  end if
end procedure


-- shifts cursor one position to the left
procedure lcd_cursor_shift_left(byte in value) is
  if value != 0 then
      for value loop
          _lcd_write_command( LCD_CURSOR_SHIFT_L_VAL )
          delay_10us( LCD_SHORT_DELAY )
      end loop
  end if
end procedure


-- shifts cursor one position to the right
procedure lcd_cursor_shift_right(byte in value) is
  if value != 0 then
      for value loop
          _lcd_write_command( LCD_CURSOR_SHIFT_R_VAL )
          delay_10us( LCD_SHORT_DELAY )
      end loop
  end if
end procedure


-- clears the lcd
procedure lcd_clear()  is
  _lcd_write_command( LCD_CLEAR_DISPLAY )
  delay_10us( LCD_LONG_DELAY )
end procedure


-- sets or resets cursor blink and puts display on or off
procedure lcd_cursor_blink_display(bit in cursor,bit in blink,bit in display) is
  var byte register

  register = LCD_DISPLAY_ONOFF
  if display then register = register + 4 end if
  if cursor  then register = register + 2 end if
  if blink   then register = register + 1 end if
  _lcd_write_command( register )
end procedure


-- cursor returns home(line 1, position 1)
procedure lcd_home()  is
  _lcd_write_command( LCD_RETURN_HOME )
  delay_10us( LCD_LONG_DELAY )
end procedure


-- clears the line "line" of the lcd
procedure lcd_clear_line( byte in line ) is
  -- set lcd-cursor at start of line
  if lcd_number_of_display_lines == 1 then    ; 1 line display
     lcd_pos = 0
     _lcd_restore_cursor()
     for 80 loop
         lcd_write_data( " " )
     end loop
  elsif lcd_number_of_display_lines == 2 then ; 2 line display
     if line == 1 then lcd_pos = 0 end if
     if line == 2 then lcd_pos = 0x40 end if
     _lcd_restore_cursor()
     for 40 loop
         lcd_write_data( " " )
     end loop

  else -- 3 lines
     if     line == 1 then lcd_pos = 0        ; 3 line display
     elsif line == 2 then lcd_pos = 0x10
     else  line == 3 then lcd_pos = 0x20
     end if
     _lcd_restore_cursor()
     for 16 loop
         lcd_write_data( " " )
     end loop
  end if
  _lcd_restore_cursor()    ;set cursor at begin of deleted line
end procedure


-- Displays a progress bar
procedure lcd_progress(byte in line, byte in amount, byte in pattern) is
  if lcd_number_of_display_lines == 1 then    ; 1 line display
     lcd_pos = pos
  elsif lcd_number_of_display_lines == 2 then ; 2 line display
     if line == 1 then lcd_pos = 0 end if
     if line == 2 then lcd_pos = 0x40 end if
  else -- 3 lines
     if     line == 1 then lcd_pos = 0        ; 3 line display
     elsif line == 2 then lcd_pos = 0x10
     else  line == 3 then lcd_pos = 0x20
     end if
  end if
  _lcd_restore_cursor()
  for amount loop
      lcd_write_data( pattern )
  end loop
  
  for ( lcd_number_of_display_characters - amount) loop
        lcd_write_data( " " )
  end loop

end procedure


-- Displays a value (byte), white or without Decimal Point, on specified line
-- and position , non leading zero ,with or without left alignment, signed
-- or not signed.
procedure lcd_bvalue_dp_line_pos_left_sign( byte in value, byte in dp, byte in line, byte in poskar, bit in left, bit in sign ) is
   var byte digit0 = 0
   var byte digit1 = 0
   var byte digit2 = 0
   var bit negative = false
   
   if sign then
      if value >= 128   then
         negative = true
         value = 128 - (value - 128)
      end if
   end if

   while value >= 100 loop
      digit2 = digit2 + 1
      value = value - 100
   end loop

   while value >= 10 loop
      digit1 = digit1 + 1
      value = value - 10
   end loop

   digit0 = value
   
   if digit2 == 0 & dp < 2 then
      digit2 = 32
   else
      digit2 = digit2 + 48
   end if

   if digit1 == 0 & digit2 == 32 & dp < 1 then
      digit1 = 32
   else
      digit1 = digit1 + 48
   end if

   digit0 = digit0 + 48

   
   lcd_new_line_cursor_position(line, poskar)
   
   var bit decp = false
   var byte counter = 0
   lcd_nodigit = 0

         for 5 loop

          if negative then
             lcd_write_data("-")
             negative = false
             lcd_nodigit = lcd_nodigit + 1
          end if

          if dp > 2 & !decp  then
             lcd_write_data(".")
             decp = true
             lcd_nodigit = lcd_nodigit + 1
          else
             if counter == 1 then
                if !left | digit2 != 32 then
                   lcd_write_data(digit2)
                   lcd_nodigit = lcd_nodigit + 1
                end if
             end if
             if counter == 2 then
                if !left | digit1 != 32 then
                   lcd_write_data(digit1)
                   lcd_nodigit = lcd_nodigit + 1
                end if
             end if
             if counter == 3 then
                if !left | digit0 != 32 then
                   lcd_write_data(digit0)
                   lcd_nodigit = lcd_nodigit + 1
                end if
             end if
             counter = counter + 1
          end if

          if dp != 0 then
             dp = dp + 1
          end if

       end loop

       if lcd_nodigit > lcd_maxdigit then
          lcd_maxdigit = lcd_nodigit
       else
          while lcd_maxdigit > lcd_nodigit  loop
                lcd_write_data(32)
                lcd_maxdigit = lcd_maxdigit - 1
          end loop
       end if

end procedure


-- Displays a value (word), white or without Decimal Point, on specified line
-- and position,  non leading zero ,with or without left alignment, signed
-- or not signed
procedure lcd_wvalue_dp_line_pos_left_sign( word in value, byte in dp, byte in line, byte in poskar, bit in left, bit in sign ) is
   var byte digit0 = 0   ;l
   var byte digit1 = 0   ;10
   var byte digit2 = 0   ;100
   var byte digit3 = 0   ;1000
   var byte digit4 = 0   ;10000
   var bit negative = false

   if sign then
     if value >= 32768   then
        negative = true
        value = 32768 - (value - 32768)
     end if
   end if

   while value >= 10000 loop
        digit4 = digit4 + 1
        value = value - 10000
   end loop

   while value >= 1000 loop
        digit3 = digit3 + 1
        value = value - 1000
   end loop

   while value >= 100 loop
        digit2 = digit2 + 1
        value = value - 100
   end loop

   while value >= 10 loop
        digit1 = digit1 + 1
        value = value - 10
   end loop

   digit0 = value

   if digit4 == 0 & dp < 4 then
     digit4 = 32
   else
     digit4 = digit4 + 48
   end if

   if digit3 == 0 & digit4 == 32 & dp < 3 then
     digit3 = 32
   else
     digit3 = digit3 + 48
   end if

   if digit2 == 0 & digit3 == 32 & digit4 == 32 & dp < 2 then
     digit2 = 32
   else
     digit2 = digit2 + 48
   end if

   if digit1 == 0 & digit2 == 32 & digit3 == 32 & digit4 == 32 & dp < 1 then
     digit1 = 32
   else
     digit1 = digit1 + 48
   end if

   digit0 = digit0 + 48

   lcd_new_line_cursor_position(line, poskar)

   var bit decp = false
   var byte counter = 0
   lcd_nodigit = 0

   for 7 loop

      if negative then
         lcd_write_data("-")
         negative = false
         lcd_nodigit = lcd_nodigit + 1
      end if

      if dp > 5 & !decp  then
         lcd_write_data(".")
         decp = true
         lcd_nodigit = lcd_nodigit + 1
      else
         if counter == 1 then
            if !left | digit4 != 32 then
               lcd_write_data(digit4)
               lcd_nodigit = lcd_nodigit + 1
            end if
         end if
         if counter == 2 then
            if !left | digit3 != 32 then
               lcd_write_data(digit3)
               lcd_nodigit = lcd_nodigit + 1
            end if
         end if
         if counter == 3 then
            if !left | digit2 != 32 then
              lcd_write_data(digit2)
               lcd_nodigit = lcd_nodigit + 1
            end if
         end if
         if counter == 4 then
            if !left | digit1 != 32 then
               lcd_write_data(digit1)
               lcd_nodigit = lcd_nodigit + 1
            end if
         end if
         if counter == 5 then
            lcd_write_data(digit0)
            lcd_nodigit = lcd_nodigit + 1
         end if
         counter = counter + 1
      end if

      if dp != 0 then
         dp = dp + 1
      end if

   end loop

   if lcd_nodigit > lcd_maxdigit then
      lcd_maxdigit = lcd_nodigit
   else
      while lcd_maxdigit > lcd_nodigit  loop
         lcd_write_data(32)
         lcd_maxdigit = lcd_maxdigit - 1
      end loop
   end if

end procedure

-- Displays a time (byte),
procedure lcd_time( byte in hrs, byte in minut, byte in second, byte in seperator ) is
   var byte hrs_digit0 = 0   ;l
   var byte hrs_digit1 = 0   ;10
   var byte minut_digit0 = 0   ;1
   var byte minut_digit1 = 0   ;10
   var byte second_digit0 = 0   ;1
   var byte second_digit1 = 0   ;10

   while hrs >= 10 loop
      hrs_digit1 = hrs_digit1 + 1
      hrs = hrs - 10
   end loop
   hrs_digit0 = hrs + 48
   hrs_digit1 = hrs_digit1 + 48
   while minut >= 10 loop
      minut_digit1 = minut_digit1 + 1
      minut = minut - 10
   end loop
   minut_digit0 = minut +48
   minut_digit1 = minut_digit1 + 48
   while second >= 10 loop
      second_digit1 = second_digit1 + 1
      second = second - 10
   end loop
   second_digit0 = second + 48
   second_digit1 = second_digit1 + 48

   lcd_write_data(hrs_digit1  )
   lcd_write_data(hrs_digit0)
   lcd_write_data(seperator)
   lcd_write_data(minut_digit1)
   lcd_write_data(minut_digit0)
   lcd_write_data(seperator)
   lcd_write_data(second_digit1)
   lcd_write_data(second_digit0)

end procedure


-- Displays a date (byte),
procedure lcd_date( byte in day, byte in mounth, word in year, byte in seperator, bit in day_mounth_notation ) is
   var byte day_digit0 = 0   ;l
   var byte day_digit1 = 0   ;10
   var byte mounth_digit0 = 0   ;1
   var byte mounth_digit1 = 0   ;10
   var byte year_digit0 = 0   ;1
   var byte year_digit1 = 0   ;10
   var byte year_digit2 = 0   ;100
   var byte year_digit3 = 0   ;1000
   var word year_mem = year


   while day >= 10 loop
         day_digit1 = day_digit1 + 1
         day = day - 10
   end loop
   day_digit0 = day + 48
   day_digit1 = day_digit1 + 48
   while mounth >= 10 loop
         mounth_digit1 = mounth_digit1 + 1
         mounth = mounth - 10
   end loop
   mounth_digit0 = mounth +48
   mounth_digit1 = mounth_digit1 + 48

   while year >= 1000 loop
         year_digit3 = year_digit3 + 1
         year = year - 1000
   end loop

   while year >= 100 loop
         year_digit2 = year_digit2 + 1
         year = year - 100
   end loop

   while year >= 10 loop
         year_digit1 = year_digit1 + 1
         year = year - 10
   end loop
   year_digit3 = year_digit3 + 48
   year_digit2 = year_digit2 + 48
   year_digit1 = year_digit1 + 48
   year_digit0 = year + 48

   if !day_mounth_notation then
      lcd_write_data(mounth_digit1)
      lcd_write_data(mounth_digit0)
      lcd_write_data(seperator)
      lcd_write_data(day_digit1  )
      lcd_write_data(day_digit0)
      lcd_write_data(seperator)
   else
      lcd_write_data(day_digit1  )
      lcd_write_data(day_digit0)
      lcd_write_data(seperator)
      lcd_write_data(mounth_digit1)
      lcd_write_data(mounth_digit0)
      lcd_write_data(seperator)
   end if

   if year_mem > 100 then
      lcd_write_data(year_digit3)
      lcd_write_data(year_digit2)
   else
      lcd_write_data("'")
   end if

   lcd_write_data(year_digit1)
   lcd_write_data(year_digit0)

end procedure


-- Displays a byte value in Hex,
procedure lcd_bvalue_hex( byte in value) is
   var byte temp
   lcd_write_data("0")
   lcd_write_data("x")
   temp = value >> 4
   if temp < 10 then
      lcd_write_data(temp + 48)
   else
      lcd_write_data(temp + 55)
   end if
   value = value & 0b00001111
   if value < 10 then
      lcd_write_data(value + 48)
   else
      lcd_write_data(value + 55)
   end if

end procedure


-- Displays a word value in Hex,
procedure lcd_wvalue_hex( word in value) is
   var byte temp
   lcd_write_data("0")
   lcd_write_data("x")
   temp = value >> 12
   if temp < 10 then
      lcd_write_data(temp + 48)
   else
      lcd_write_data(temp + 55)
   end if
   temp = value >> 8
   temp = temp & 0b00001111
   if temp < 10 then
      lcd_write_data(temp + 48)
   else
      lcd_write_data(temp + 55)
   end if
   temp = value >> 4
   temp = temp & 0b00001111
   if temp < 10 then
      lcd_write_data(temp + 48)
   else
      lcd_write_data(temp + 55)
   end if
   value = value & 0b0000000000001111
   if value < 10 then
      lcd_write_data(value + 48)
   else
      lcd_write_data(value + 55)
   end if

end procedure


-- Initialise display
-- (this routine is only used inside this file)
procedure lcd_init() is
   pragma inline
   lcd_enable = low
   delay_1ms( 45 )                  --
   lcd_rw = low                      -- select command

   if lcd_hardware == 4  then
      _lcd_write_low_nibble( 0b_0000_0011 ) --
      delay_1ms( 2)                       --
      _lcd_write_low_nibble( 0b_0000_0011 ) --
      delay_1ms( 2 )                      --
      _lcd_write_low_nibble( 0b_0000_0011 ) --
      delay_10us( 4 )

      _lcd_write_low_nibble( 0b_0000_0010 )--
      delay_10us( 4 )

      if lcd_number_of_display_lines == 1 then
         _lcd_write_low_nibble( 0b_0000_0010 )--
         delay_10us( 4 )
         _lcd_write_low_nibble( 0b_0000_0001 )--
         delay_10us( 4 )
         _lcd_write_low_nibble( 0b_0000_0001 )--
         delay_10us( 4 )
         _lcd_write_low_nibble( 0b_0000_0100 )--
      end if

      if lcd_number_of_display_lines == 2 then
         _lcd_write_low_nibble( 0b_0000_0010 )--
         delay_10us( 4 )
         _lcd_write_low_nibble( 0b_0000_1001 )--
         delay_10us( 4 )
         _lcd_write_low_nibble( 0b_0000_0001 )--
         delay_10us( 4 )
         _lcd_write_low_nibble( 0b_0000_0100 )--
      end if

      if lcd_number_of_display_lines == 3 then
         _lcd_write_low_nibble( 0b_0000_0010 )--
         delay_10us( 4 )
         _lcd_write_low_nibble( 0b_0000_1001 )--
         delay_10us( 4 )
         _lcd_write_low_nibble( 0b_0000_0001 )--
         delay_10us( 4 )
         _lcd_write_low_nibble( 0b_0000_0101 )--
      end if

      _lcd_write_low_nibble( 0b_0000_0111 )--
      delay_10us( 4 )
      _lcd_write_low_nibble( 0b_0000_1000 )--
      delay_10us( 4 )
      _lcd_write_low_nibble( 0b_0000_0101 )--
      delay_10us( 4 )
      _lcd_write_low_nibble( 0b_0000_1110 )--
      delay_10us( 4 )
      _lcd_write_low_nibble( 0b_0000_0110 )--
      delay_10us( 4 )
      _lcd_write_low_nibble( 0b_0000_1010 )--
      delay_10us( 4 )
      _lcd_write_low_nibble( 0b_0000_0000 )--
      delay_10us( 4 )
      _lcd_write_low_nibble( 0b_0000_1100 )--
      delay_10us( 4 )
      _lcd_write_low_nibble( 0b_0000_0000 )--
      delay_10us( 4 )
      _lcd_write_low_nibble( 0b_0000_0001 )--
      delay_10us( 4 )
      _lcd_write_low_nibble( 0b_0000_0000 )--
      delay_10us( 4 )
      _lcd_write_low_nibble( 0b_0000_0110 )--
      delay_1ms( 4 )

   end if

   if lcd_hardware == 1 | lcd_hardware == 8 then
      if lcd_number_of_display_lines == 1 then
         _lcd_write_command( 0b_0011_0000 ) -- function set lcd port
         delay_10us( 3 )                       -- extra delay
         _lcd_write_command( 0b_0011_0001 ) -- function set lcd port
         delay_10us( 3 )                      -- extra delay
         _lcd_write_command( 0b_0001_0100 ) -- BIAS
         delay_10us( 3 )                      -- extra delay
      end if

      if lcd_number_of_display_lines == 2 then
         _lcd_write_command( 0b_0011_1000 ) -- function set lcd port
         delay_10us( 3 )                       -- extra delay
         _lcd_write_command( 0b_0011_1001 ) -- function set lcd port
         delay_10us( 3 )                      -- extra delay
         _lcd_write_command( 0b_0001_0100 ) -- BIAS
         delay_10us( 3 )                      -- extra delay
      end if

      if lcd_number_of_display_lines == 3 then
         _lcd_write_command( 0b_0011_1000 ) -- function set lcd port
         delay_10us( 3 )                       -- extra delay
         _lcd_write_command( 0b_0011_1001 ) -- function set lcd port
         delay_10us( 3 )                      -- extra delay
         _lcd_write_command( 0b_0001_0101 ) -- BIAS
         delay_10us( 3 )                      -- extra delay
      end if

      _lcd_write_command( 0b_0111_0000 ) -- contrast set
      delay_10us( 3)                    -- extra delay
      _lcd_write_command( 0b_0101_1110 ) -- power/ICON/contrast control
      delay_10us( 3 )
      _lcd_write_command( 0b_0110_1010 ) -- follower control
      delay_1ms( 210 )
      _lcd_write_command( 0b_0011_1000 ) -- function set lcd port
      delay_10us( 3 )                      -- extra delay
      _lcd_write_command( 0b_0000_1100 )-- display on/off control
  	  delay_10us( 3 )
      _lcd_write_command( 0b_0000_0001 )-- clear display
  	  delay_10us( 40 )
      _lcd_write_command( 0b_0000_0110 )-- entry mode set, cursor moves to right
  	  delay_10us( 40 )
   end if

end procedure


lcd_init()                  ; init the lcd

