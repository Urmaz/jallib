<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd" []>
<topic id="template_id">
  <title>Hard Disks - IDE/PATA</title>
  <prolog>
    <author>Matthew Schinkel</author>
    <publisher>Jallib Group</publisher>
    <metadata>
      <category>Tutorials</category>
      <prodinfo>
        <prodname>Jallib</prodname>
        <vrmlist>
          <vrm version="0.0"/>
        </vrmlist>
      </prodinfo>
    </metadata>
  </prolog>
  <body>
    <p id="firstcontent">IDE Paralel ATA hard disk drive tutorial</p>
    <section>
      <title>Introduction to hard disks drives</title>
      <p>If your are like me, you have too many old hard disks laying around. I have gathered quite a collection of drives from PC&apos;s I have had in the past. Now you can dust off your  drives and put them in your circuit. I have extra drives ranging in size from 171MB to 120GB.</p>
      <p>Before you start, make sure you use a drive you do not care about. We are not responsible for your drive of the data that is on it.</p>
      <p>You can find more general info at <xref href="http://en.wikipedia.org/wiki/Parallel_ATA" format="html">http://en.wikipedia.org/wiki/Parallel_ATA</xref>, and you can find more detailed technical info at <xref href="http://www.gaby.de/gide/IDE-TCJ.txt" format="html">http://www.gaby.de/gide/IDE-TCJ.txt</xref></p>
      <image href="images/pata_hard_disk_pile.jpg" width="450"/>
    </section>
    <section>
      <title>Drive Types - PATA vs SATA</title>
      <p>There are two types of hard disks PATA (parallel ata) and SATA (serial ata). In this tutorial we will use PATA, these drives use a 40 pin IDE connector. The newer type of drive SATA has only 7 pins but there is no Jallib library for these drives at the moment. Both types of hard disks  are available with massive amounts of data space.</p>
    </section>
    <section>
      <title>Drive Data Size</title>
      <p>The current jallib library will accept drives up to 128GB. The 128GB limit is due to and addressing limitation, this is the 28 bit addressing limitation.The max address you will be able to reach is hex 0xFFFFFFF. If you multiply this address by 512 bytes (1 sector) you get a max size of 137,438,952,960 bytes, yes this does equal 128GB. Eventually I may upgrade the library for 48bit addressing which will allow up to a max drive size hex 0xFFFFFFFFFFFF * 512 = 128P Petabytes. But now that I think about it, 128 GB should be enough!</p>
    </section>
    <section>
      <title>Actual Size</title>
      <p>The most common drive sizes today are 3.5&quot; and 2.5&quot;. The 3.5 inch drives are commonly used in desktop computers, 2.5&quot; drives are used in laptops. The 2.5&quot; drives are nice for your circuit because they do not require a 12v supply voltage, and they use much less power.</p>
      <image href="images/pata_hard_disk_drive_size.jpg" width="450"/>
      <p>If you wish to use a 2.5&quot; laptop hard drive, you may need a 2.5&quot; to 3.5&quot; IDE adapter like this one:</p>
      <image href="images/pata_hard_disk_adapter.jpg" width="200" otherprops="clickable"/>
      <image href="images/pata_hard_disk_adapter2.jpg" width="200"/>
    </section>
    <section>
      <title>Build a breadboard connector</title>
      <p>Now, if your going to put one of these into your circuit, you&apos;ll need to plug the drive into your breadboard. I took a 40pin IDE connector off an old motherboard. The easiest way to get large components of a board is to use a heat gun on the bottom side of the board to melt the solder on all pins at once. </p>
      <p>Now take this connector and stick it into some blank breadboard and add some pins. The blank breadboard I cut is 4 holes wide by 20 long. Put the connector in the middle and connect the pins on the outside, join each pin with each pin of the connector. </p>
      <p>Of course you will also need a 40pin  IDE cable, I like the ones with the notch so you don&apos;t plug it in backwards. Here&apos;s the one I made:</p>
      <image href="images/pata_hard_disk_connector_top.jpg" width="200" otherprops="clickable"/>
      <image href="images/pata_hard_disk_connector_bottom.jpg" width="200" otherprops="clickable"/>
      <image href="images/pata_hard_disk_connector_side.jpg" width="200" otherprops="clickable"/>
    </section>
    <section>
      <title>Circuit Power</title>
      <p>It is very important that you have enough power to drive your circuit. Hard drives need a lot of amps to run, especially the 3.5&quot; drives, so make sure you have a decent 5v and 12v power supply. I suggest that you DO NOT use your PC&apos;s power supply to drive your circuit. You can easily short circuit your power supply and blow up your PC. If you really insist on doing this, you better put a fuse on both 5v and 12v between your PC and your circuit. Just remember that I told you not to!</p>
    </section>
    <section>
      <title>IDE Connector Pin-out</title>
      <p>Pin 1 on the IDE cable is the red stripe. Here the pin out for the male connector I took off a motherboard:</p>
      <image href="images/pata_hard_disk_pins.jpg"/>
    </section>
    <section>
      <p><table>
          <tgroup cols="4">
            <thead>
              <row>
                <entry>PIN</entry>
                <entry>FUNCTION</entry>
                <entry>PIN</entry>
                <entry>FUNCTION</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1</entry>
                <entry>/RESET</entry>
                <entry>2</entry>
                <entry>GND</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>D7</entry>
                <entry>4</entry>
                <entry>D8</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>D6</entry>
                <entry>6</entry>
                <entry>D9</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>D5</entry>
                <entry>8</entry>
                <entry>D10</entry>
              </row>
              <row>
                <entry>9</entry>
                <entry>D4</entry>
                <entry>10</entry>
                <entry>D11</entry>
              </row>
              <row>
                <entry>11</entry>
                <entry>D3</entry>
                <entry>12</entry>
                <entry>D12</entry>
              </row>
              <row>
                <entry>13</entry>
                <entry>D2</entry>
                <entry>14</entry>
                <entry>D13</entry>
              </row>
              <row>
                <entry>15</entry>
                <entry>D1</entry>
                <entry>16</entry>
                <entry>D14</entry>
              </row>
              <row>
                <entry>17</entry>
                <entry>D0</entry>
                <entry>18</entry>
                <entry>D15</entry>
              </row>
              <row>
                <entry>19</entry>
                <entry>GND</entry>
                <entry>20</entry>
                <entry>NO PIN</entry>
              </row>
              <row>
                <entry>21</entry>
                <entry/>
                <entry>22</entry>
                <entry>GND</entry>
              </row>
              <row>
                <entry>23</entry>
                <entry>/IOWR - READ Pin</entry>
                <entry>24</entry>
                <entry>GND</entry>
              </row>
              <row>
                <entry>25</entry>
                <entry>/IORD - Write Pin</entry>
                <entry>26</entry>
                <entry>GND</entry>
              </row>
              <row>
                <entry>27</entry>
                <entry/>
                <entry>28</entry>
                <entry>ALE - 1K resistor to 5v</entry>
              </row>
              <row>
                <entry>29</entry>
                <entry/>
                <entry>30</entry>
                <entry>GND</entry>
              </row>
              <row>
                <entry>31</entry>
                <entry/>
                <entry>32</entry>
                <entry/>
              </row>
              <row>
                <entry>33</entry>
                <entry>A1</entry>
                <entry>34</entry>
                <entry/>
              </row>
              <row>
                <entry>35</entry>
                <entry>A0</entry>
                <entry>36</entry>
                <entry>A2</entry>
              </row>
              <row>
                <entry>37</entry>
                <entry>/CS0 (to 5v)</entry>
                <entry>38</entry>
                <entry>/CS1 (to GND)</entry>
              </row>
              <row>
                <entry>39</entry>
                <entry>ACT - BUSY LED</entry>
                <entry>40</entry>
                <entry>GND</entry>
              </row>
            </tbody>
          </tgroup>
        </table></p>
      <title>Build the circuit</title>
      <p>Build the circuit below. As you can see it is quite simple. As you can see, it only requires 3 resistors, a led and a bunch of wire. You can put a reset button on the IDE connector if you like, but I have found no use for it so I connect it direct to 5v.</p>
      <image href="images/pata_hard_disk_schematic.jpg" width="500" otherprops="clickable"/>
      <p>Here&apos;s what the completed circuit should look like (don&apos;t turn on the power yet):</p>
      <image href="images/pata_hard_disk_small_drive.jpg" width="500" otherprops="clickable"/>
      <image href="images/pata_hard_disk_large_drive.jpg" width="500" otherprops="clickable"/>
    </section>
    <section>
      <title>Compile and write the software to your PIC</title>
      <p>The hard disk lib (pata_hard_disk.jal) and a sample file (16f877_pata_hard_disk.jal) will be needed for this project. You will find these files in the lib &amp; sample directories of your jallib installation. </p>
      <p>The most up to date version of the sample &amp; library can be found at:</p>
      <p>Sample file - <xref href="http://jallib.googlecode.com/svn/trunk/sample/16f877_pata_hard_disk.jal" format="html">http://jallib.googlecode.com/svn/trunk/sample/16f877_pata_hard_disk.jal</xref></p>
      <p>Library file - <xref href="http://jallib.googlecode.com/svn/trunk/include/external/storage/harddisk/pata_hard_disk.jal" format="html">http://jallib.googlecode.com/svn/trunk/include/external/storage/harddisk/pata_hard_disk.jal</xref></p>
      <p>Now lets test it and make sure it works. Compile and program your pic with 16f877_sd_card.jal from your jallib samples directory. If you are using another pic, change the &quot;include 16f877&quot; line in 16f877_sd_card.jal to specify your PIC before compiling. </p>
      <p>Now that you have compiled it, burn the .hex file to your PIC with your programmer</p>
    </section>
    <section>
      <title>Power It Up</title>
      <p>Plug your circuit into your PC for serial port communication at 38400 baud rate. Now turn it on.  It should do the following in this order:</p>
      <ol>
        <li>Drive will power up with the led on, after power up the led will go off.</li>
        <li>The led will blink once quickly and the drive will &quot;spin down&quot;.</li>
        <li>The led will turn on while the drive now &quot;spins up&quot;</li>
        <li>The led will blink once quickly and the drive will &quot;spin down&quot; again.</li>
        <li>The led will turn on while the drive now &quot;spins up&quot; again.</li>
        <li>The led will turn on and off a few times and send some data to your PC&apos;s serial port.</li>
        <li>The PIC now &quot;spin down&quot; the drive at the end of the program.</li>
      </ol>
      <b>ASCII output</b>
      <p><image href="images/pata_hard_disk_ascii.jpg" width="450" otherprops="clickable"/></p>
      <p><b>Hex output</b></p>
      <image href="images/pata_hard_disk_hex.jpg" width="450" otherprops="clickable"/>
      <p>In the first image, If your disk is formatted with fat32 you may be able to see some readable data as well as some junk. There is too much data for me to show it all in the image, on my drive formatted with fat32 I can read &quot;Invalid partition t
ableError loading operating system...&quot;
</p>
      <p>In the second image (after clearing the output and resetting the circuit), there was too much data to show it all again. It only shows the last bytes received. If you get the same hex output &quot;CC DD&quot; followed by many &quot;FF&quot;, your circuit has successfully written data and read it back again. You now have a working hard disk circuit!</p>
    </section>
    <section>
      <title>Understand and modify the code</title>
      <p>I will go over some of the key points you need to know about hard disk coding. Open the sample file with an editor if you  have not done so already. The code in the sample file may change, therefore it may be different then what you see here. The sample file you have downloaded will always be tested and correct.</p>
      <p><b>Include the chip</b></p>
      <p>Select the PIC you wish to use and your clock frequency</p>
      <codeblock>-- include chip
include 16F877a                    -- target PICmicro
pragma target clock 20_000_000     -- oscillator frequency
-- configure fuses
pragma target OSC  HS              -- HS crystal or resonator
pragma target WDT  disabled        -- no watchdog
pragma target LVP  disabled        -- no Low Voltage Programming</codeblock>
      <p><b>Disable all analog pins</b></p>
      <codeblock>enable_digital_io() -- disable all analog pins if any</codeblock>
      <p><b>Include required libraries</b></p>
      <codeblock>include delay       -- include the delay library</codeblock>
      <p><b>Setup serial port and choose baud rate 38400</b></p>
      <codeblock>-- setup uart for communication
const serial_hw_baudrate  = 38400   -- set the baudrate
include serial_hardware
serial_hw_init()</codeblock>
      <p><b>Setup the hard disk library constants/settings</b></p>
      <p>The registers Alternate Status, Digital Output, and Drive Address registers will only be used by advanced users, so keep the default PATA_HD_USE_CS0_CS1_PINS = FALSE</p>
      <p>The pins /iowr, /iord, /cs0, /cs1 are active low pins that are supposed to require an inverter. If you leave PATA_HD_NO_INVERTER = TRUE, the PIC will do the inversion for you. You will most likely want to keep the default &quot;TRUE&quot;.</p>
      <codeblock>-- setup hard disk library

-- set true if you will use Alternate Status, 
-- Digital Output or Drive Address registers
const byte PATA_HD_USE_CS0_CS1_PINS = FALSE 

-- if true, an external inverter chip is not 
-- needed on /iowr, /iord, /cs0, /cs1 pins
const bit PATA_HD_NO_INVERTER = TRUE </codeblock>
      <p><b>Setup pin assignments</b></p>
      <p>Yes, pata hard disks have a lot of pins. You will need two full 8pin port&apos;s (port B and port D of 16F877) for data transfer, three register select pins, one read pulse pin and one write pulse pin. A total of 19 io pins. I am able to  comment out cs1/cs0 and save pins because of the constant we set.</p>
      <codeblock>-- pin assignments
alias     pata_hd_data_low              is portb   -- data port (low bits)
alias     pata_hd_data_low_direction    is portb_direction
alias     pata_hd_data_high             is portd   -- data port (high bits)
alias     pata_hd_data_high_direction   is portd_direction

alias     pata_hd_a0                    is pin_a3
alias     pata_hd_a0_direction          is pin_a3_direction
alias     pata_hd_a1                    is pin_a1
alias     pata_hd_a1_direction          is pin_a1_direction
alias     pata_hd_a2                    is pin_a0
alias     pata_hd_a2_direction          is pin_a0_direction

alias     pata_hd_iowr                  is pin_e0
alias     pata_hd_iowr_direction        is pin_e0_direction
alias     pata_hd_iord                  is pin_a4
alias     pata_hd_iord_direction        is pin_a4_direction

;alias     pata_hd_cs1                   is pin_a3
;alias     pata_hd_cs1_direction         is pin_a3_direction
;alias     pata_hd_cs0                   is pin_a4
;alias     pata_hd_cs0_direction         is pin_a4_direction

pata_hd_a0_direction = output    -- register select pin
pata_hd_a1_direction = output    -- register select pin
pata_hd_a2_direction = output    -- register select pin

pata_hd_iowr_direction = output  -- used for write pulse
pata_hd_iord_direction = output  -- used for read pulse

;pata_hd_cs1_direction = output   -- register select pin
;pata_hd_cs0_direction = output   -- register select pin</codeblock>
      <p><b>Now include the library</b></p>
      <codeblock>include pata_hard_disk           -- include the parallel ata ide hard disk library
pata_hd_init()                   -- initialize startup settings</codeblock>
      <p><b>Add user&apos;s procedure and variables</b></p>
      <p>Hard disks send data 2 bytes at a time since there are two 8 pin data ports, so I made a small serial port procedure to send 2 bytes via the serial port:</p>
      <codeblock>-- Function for sending hard disk data via serial 
-- port, data is read 2 bytes at a time.
procedure send_word(byte in lowbit, byte in highbit) is
serial_hw_write(lowbit)  -- send 1st serial data byte
serial_hw_write(highbit) -- send 2nd serial data byte
end procedure</codeblock>
      <p>Now declare variables for recieved data</p>
      <codeblock>-- Declare variables for this example.
var byte in_a
var byte in_b</codeblock>
      <p>Wait for power to stabilize then send &quot;START&quot; to the serial port to notify the user (YOU) that the program has started ok</p>
      <codeblock>_usec_delay (1_000_000) -- wait for power to stabilize

-- send &quot;start&quot; to pc / test uart communication
send_word(&quot;S&quot;, &quot;T&quot;)
send_word(&quot;A&quot;, &quot;R&quot;)
send_word(&quot;T&quot;, 0x20)
send_word(13, 10)
send_word(13, 10)</codeblock>
      <p><b>Spin Up/Spin Down test</b></p>
      <p>It is important to know if we have some basic communication to the drive. We will try to spin up (turn on the drive&apos;s motor) and spin down (turn off the drive&apos;s motor). This will simply send the &quot;spin up&quot; command to the command register then &quot;spin down&quot;, then it will do the same once more. This shows that we have  communication from your PIC to the hard drive.</p>
      <codeblock>for 2 loop
   pata_hd_register_write(PATA_HD_COMMAND_REG,PATA_HD_SPIN_UP)   -- turn on motor
   _usec_delay(5_000_000) -- 5 sec delay
   pata_hd_register_write(PATA_HD_COMMAND_REG,PATA_HD_SPIN_DOWN) -- turn off motor
   _usec_delay(5_000_000) -- 5 sec delay
end loop

pata_hd_register_write(PATA_HD_COMMAND_REG,PATA_HD_SPIN_UP)       -- turn on motor</codeblock>
      <p>Wait 10 seconds before next example</p>
      <codeblock>_usec_delay(10_000_000) -- wait 10 seconds before next example</codeblock>
      <p><b>Read the first and second sector from the hard drive </b></p>
      <p>Now that we know we are able to write to the registers, we can try to read some data. One sector is 512 bytes. Since data is transfered 2 bytes at a time, we will loop 256 times to read one full sector while sending the data via serial port.</p>
      <p>Reading is easy, there are 3 procedures within the library that MUST be used. You will notice this process is similar to the SD card tutorial.</p>
      <p><b>pata_hd_start_read(0)</b> - start reading at specified sector (sector 0)</p>
      <p><b>pata_hd_read_data(byte1, byte2)</b> - actually read data from the card (2 bytes at a time)</p>
      <p><b>pata_hd_stop_read()</b> - stop the read process</p>
      <p>You can also use the pata_hd_read_pulse(number) procedure to skip past data. For every 1 value added, there will be 2 bytes skipped since this procedure simply reads data and ignores the input.</p>
      <codeblock>-- Read one sector
for 256 loop                            -- 256 words, 512 bytes per sector
   pata_hd_read_data(in_b, in_a)        -- read data
   send_word(in_b, in_a)                -- send data via serial port
end loop

-- You will see hard disk LED on during this delay
-- because you did not finnish reading.
_usec_delay(2_000_000) -- 2 second delay

-- Read 2nd sector.
for 256 loop                            -- 256 words, 512 bytes per sector
   pata_hd_read_data (in_b, in_a)        -- read data
   send_word(in_b, in_a)            -- send data via serial port
end loop

pata_hd_stop_read()       -- tell drive you are done reading
-- hard disk led will turn off at this point.

_usec_delay(10_000_000) -- wait 10 seconds before next example</codeblock>
      <p><b>Identify drive command</b></p>
      <p>The identify drive command loads 512 bytes of data for you that contains information about your drive. You can retrieve info like drive serial number, model number,  drive size, number of cylinders, heads, sectors per track and a bunch of other data required by your PC. Of course you can read more info on this at the links I have given you.</p>
      <p>On the sticker of some older drives, you will see &quot;CYL&quot;, &quot;HEADS&quot;, &quot;SEC/T&quot; (this can also be found with the Identify command). You can calculate drive&apos;s addressable sectors with (cylinders * heads * sectors per track), and multipy that by 512) for the size of the drive.</p>
      <p>On newer drives, you will see on the front sticker the number of LBA&apos;s, this is the number of addressable sectors. If you multiply this value by 512, you will get the size of the drive in bytes. For example, one of my drive says 60058656 LBA&apos;s. With this drive, you can send a pata_start_read command with a addresses from 0 to (60058656 - 1). The size of this drive is 60058656 * 512 =  30GB</p>
      <p>Let&apos;s try it out, first we send the command:</p>
      <codeblock>-- send the identify drive command
pata_hd_register_write(PATA_HD_COMMAND_REG,PATA_HD_IDENTIFY_DRIVE)</codeblock>
      <p>Now we must wait till the drive is ready and has data for us:</p>
      <codeblock>-- check if drive is ready reading and set data ports as inputs
-- this MUST be used before reading since we did not use pata_hd_start_read
pata_hd_data_request(PATA_HD_WAIT_READ)</codeblock>
      <p>The drive is now has data for us, so let&apos;s read it. Notice that the input data bytes (in_b &amp; in_a) are backwards for identify drive (don&apos;t ask me why).</p>
      <codeblock>-- Read 512 bytes
for 256 loop                     -- 256 words, 512 bytes per sector
   pata_hd_read_data(in_b, in_a) -- read data
   send_word(in_a, in_b )        -- send data via serial port
end loop                         -- drive info high/low bytes are in reverse order</codeblock>
      <p>Wait 10 seconds before the next example</p>
      <codeblock>_usec_delay(10_000_000) -- wait 10 seconds before next example</codeblock>
      <p><b>Write data to the drive</b></p>
      <p>Just like reading, there are 3 procedures  that MUST be used.</p>
      <p><b>pata_hd_start_write(20)</b> - start writing at specified sector (sector 20)</p>
      <p><b>pata_hd_read_data(byte1, byte2)</b> - write  to the card (2 bytes at a time)</p>
      <p><b>pata_hd_stop_write()</b> - stop the read process</p>
      <p>When writing to your hard drive, you MUST write 512 bytes at a time. In this example, we are writing (256x2) = 512 bytes + (250x2) = 500 bytes for a total of 1012 bytes. This means we have written one sector (512 bytes), as well as 500 bytes of the next sector. The second sector (500 bytes) that we have written, will not actually be written to the hard drive until we finish the sector with data.</p>
      <p>For this reason, you will need to use the pata_hd_write_to_sector_end(value) procedure. This procedure will automatically finish the sector for you with the &quot;value&quot; data specified. In our case we are writing 0xFF till the end of the 512 bytes (end of the sector).</p>
      <p>Here&apos;s an example write, Please note that we are starting to write at sector 200</p>
      <codeblock>pata_hd_start_write(200) -- tell hd to get ready for reading

-- now write 1 sector + most of 2nd sector, data will not 
-- be written unless 512 bytes are sent
for 256 + 250 loop
   pata_hd_write_data(0xCC, 0xDD) -- write data 0xCC, 0xDD over and over
end loop
-- first sector has been written to the disk since 512 bytes where sent,
-- but 2nd sector is not finnished, only 500 bytes sent,
-- so lets finnish the sector with 6 more write pulses (0xFF&apos;s as data)
pata_hd_write_to_sector_end(0xFF)

pata_hd_stop_write()     -- tell hd we are done writing</codeblock>
      <p>Now read back the data the 1012 bytes have been written</p>
      <codeblock>-- Now read the 1st sector you just wrote, should get 
-- 0xCC, 0xDD over and over
pata_hd_start_read(200)                 -- get drive ready for reading
for 256 + 250 loop                      -- read 512 bytes + 500 bytes
   pata_hd_read_data(in_b, in_a)        -- read data
   send_word(in_b, in_a)            -- send data via serial port
end loop

-- if you want, you can read back the last 6 bytes that are 0xFF
for 6 loop
   pata_hd_read_data(in_b, in_a)        -- read data
   send_word(in_b, in_a)            -- send data via serial port
end loop

pata_hd_stop_read()                     -- tell drive we are done reading
</codeblock>
      <p>If you want, you can turn off the hard drive motor at the end of the program</p>
      <codeblock>-- We&apos;re done, lets turn off the hd motor
pata_hd_register_write(PATA_HD_COMMAND_REG,PATA_HD_SPIN_DOWN)</codeblock>
    </section>
    <section>
      <title>Your Done!</title>
      <p>That&apos;s it, Now you can read &amp; write to all those hard drives you have laying around. You can read raw data from drives and possibly even get back some lost data.</p>
      <p>Alright,  go build that hard disk thingy you where dreaming about!</p>
    </section>
  </body>
</topic>
