<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd" []>
<topic id="template_id">
  <title>SD Memory Cards</title>
  <prolog>
    <author>Matthew Schinkel</author>
    <publisher>Jallib Group</publisher>
    <metadata>
      <category>&quot;Tutorials&quot;, &quot;SD Card&quot;</category>
      <prodinfo>
        <prodname>Jallib</prodname>
        <vrmlist>
          <vrm version="0.0"/>
        </vrmlist>
      </prodinfo>
    </metadata>
  </prolog>
  <body>
    <p id="firstcontent">In this tutorial we will learn how to use an SD Card for mass data storage.</p>
    <section>
      <title>SD Card Introduction</title>
      <p>SD Cards (Secure Digital Cards) are quite popular these days for things like digital camera&apos;s, video camera&apos;s, mp3 players and mobile phones. Now you will have one in your project! The main advantages are: small size, large data storage capability, speed, cost. It has flash storage that does not require power to hold data. The current version of the sd card library that we will be using in this tutorial works with &quot;standard capacity&quot; sd cards up  4gb in size. I hope to find time to add &quot;high capacity&quot; and &quot;extended capacity&quot; capability to the library.</p>
      <p>SD Card have 2 data transfer types &quot;SD Bus&quot; and &quot;SPI Bus&quot;. Most PIC&apos;s have an SPI port.  The &quot;SD Bus&quot; is faster, however uses more pins. We will be using SPI in our circuit. For more info on SPI visit <xref href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus" format="html">http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus</xref>. The SPI mode for SD Cards is 1,1. </p>
      <p>We are not responsible for your data or SD card. Make sure you have nothing important on your SD card before you continue.</p>
      <image href="images/sd_card_sd_card.jpg" width="250"/>
      <image href="images/sd_card_pinout.jpg" width="300"/>
    </section>
    <section>
      <p>These SD Cards are 3.3v devices, therefore a 5v to 3v conversion is needed between the PIC and the sd card. We will use resistors to do the conversion, however there are many other methods. See <xref href="http://www.microchip.com/3v/" format="html">http://www.microchip.com/3v/</xref> for more information. Another setup may be needed if you are putting more devices on the same SPI bus.</p>
      <p>This circuit will use 16F877 If you are using a different PIC for your project, refer to the PIC&apos;s datasheet for pin output levels/voltage. For example, 18F452 has many pins that are 5v-input that give 3v-output. These pins show as &quot;TTL / ST&quot; - TTL compatible with CMOS level outputs in the datasheet and they will not require any voltage conversion resistors.</p>
      <title>Build a SD Card Slot</title>
      <p>Before we can build our circuit, we will need to find ourselves an sd card slot that can plug into our breadboard. You can find pre-made sd card slots on ebay and other places around the net. It is quite easy to make your own anyways. I took one out of a broken digital camera and placed it on some blank breadboard and soldered on some pins. Here are some images of my sd card holder:</p>
      <image href="images/sd_card_holder_front.jpg" width="200" otherprops="clickable"/>
      <image href="images/sd_card_holder_back.jpg" width="200" otherprops="clickable"/>
      <image href="images/sd_card_holder_with_card.jpg" width="200" otherprops="clickable"/>
      <title>Build the circuit</title>
      <p>Follow this schematic for 16f877, if you are using another PIC, check the pin-outs for the SPI bus. The pin-outs of your pic will show SDI, SDO, SCL and SS. The pin SS is the chip select pin, you can use any pin for it but the others must match.</p>
      <image href="images/sd_card_schematic.jpg" width="500" otherprops="clickable"/>
      <image href="images/sd_card_circuit.jpg" width="500" otherprops="clickable"/>
      <title>Compile and write the software to your PIC</title>
      <p>With the use of the sd card lib (sd_card.jal) and a sample file 16f877_sd_card.jal, we can easily put one in our own circuit for mass data storage! You will find these files in the lib &amp; sample directories of your jallib installation. </p>
      <p>The most up to date version of the sample &amp; library can be found at:</p>
      <p>Sample file - <xref href="http://jallib.googlecode.com/svn/trunk/sample/16f877_sd_card.jal" format="html">http://jallib.googlecode.com/svn/trunk/sample/16f877_sd_card.jal</xref></p>
      <p>Library file - <xref href="http://jallib.googlecode.com/svn/trunk/include/external/storage/sd_card/sd_card.jal" format="html">http://jallib.googlecode.com/svn/trunk/include/external/storage/sd_card/sd_card.jal</xref></p>
      <p>Now that our circuit is built, lets test it and make sure it works before we continue with more details. Compile and program your pic with 16f877_sd_card.jal from your jallib samples directory. If you are using another pic, change the &quot;include 16f877&quot; line in 16f877_sd_card.jal to specify your PIC before compiling. </p>
      <p>Now that you have compiled it, burn the .hex file to your PIC</p>
      <title>Power It Up</title>
      <p>Plug your circuit into your PC for serial port communication at 3800 baud rate. Now turn it on. Press the reset button in your circuit, you should get a result similar to this:</p>
      <b>ASCII output</b>
      <p><image href="images/sd_card_serial_data_ascii.jpg" width="450" otherprops="clickable"/></p>
      <p><b>Hex output</b></p>
      <image href="images/sd_card_serial_data.jpg" width="450" otherprops="clickable"/>
      <p>As you can see from the first image, we got some actual readable data off the sd card as well as a bunch of junk. The sample file reads the first sector (512 bytes) from the sd card. My sd card is formated with fat32, this is why I can read some of the data output.</p>
      <p>In the second image (after clearing the output and resetting the circuit), there was too much data to show it all. It only shows the last bytes received. If you get the same hex output &quot;66 22&quot; followed by many &quot;00&quot;, your circuit has successfully written data and read it back again. You now have a working sd card circuit!</p>
      <title>Understand and modify the code</title>
      <p>I&apos;m just going to quickly go over some of the key points you need to know about sd cards. Open 16f877 with a text editor if you do not have it open already.</p>
      <p><b>Include the chip</b></p>
      <p> specify the PIC you wish to use as well as your clock frequency</p>
      <codeblock>include 16f877
--
pragma target OSC HS               -- HS crystal or resonator
pragma target clock 20_000_000     -- oscillator frequency
--
pragma target WDT  disabled
pragma target LVP  disabled</codeblock>
      <p/>
      <p><b>Include other libraries required</b></p>
      <codeblock>-- include the delay library
include delay</codeblock>
      <p/>
      <p><b>Setup serial communication and port speed</b></p>
      <codeblock>-- setup uart for communication
const serial_hw_baudrate  = 38400    -- set the baudrate
include serial_hardware
serial_hw_init()</codeblock>
      <p/>
      <p><b>SPI Settings</b></p>
      <p>Here you may change the chip select pin &quot;pin_SS&quot; and &quot;pin_SS_direction&quot; to another pin. SDI, SDO and SCK must stay the same for the SPI hardware library.</p>
      <p>You may also choose the SPI rate. According to the SPI hardware library, you can use SPI_RATE_FOSC_4 SPI_RATE_FOSC_16, SPI_RATE_FOSC_64 or SPI_RATE_TMR. The fastest is FOSC_4 (oscillator frequency / 4). You may require a breadboard for the fastest speed, keep your SD Card as close to the PIC as possible.</p>
      <codeblock>-- setup spi
include spi_master_hw         -- includes the spi library
-- define spi inputs/outputs
pin_sdi_direction = input    -- spi input
pin_sdo_direction = output   -- spi output
pin_sck_direction = output   -- spi clock
-- spi chip select pin
ALIAS sd_chip_select_direction   is pin_SS_direction
ALIAS sd_chip_select             is pin_SS
sd_chip_select_direction = output    -- chip select/slave select pin
sd_chip_select = high                -- disable the sd card
--
spi_init(SPI_MODE_11,SPI_RATE_FOSC_16) -- choose spi mode and speed
</codeblock>
      <p/>
      <p><b>Include the SD card library</b></p>
      <codeblock>-- setup sd card library
include sd_card -- include sd card library
sd_init()       -- initalize the sd card</codeblock>
      <p/>
      <p><b>Read the first sector from the SD card </b></p>
      <p>Reading is easy, there are 3 procedures within the library that MUST be used.</p>
      <p><b>sd_start_read(0)</b> - start reading at specified sector (sector 0)</p>
      <p><b>sd_read_data(byte1, byte2)</b> - actually read data from the card (2 bytes at a time)</p>
      <p><b>sd_stop_read()</b> - stop the read process</p>
      <p>You can also use the sd_read_pulse(number) procedure to skip past data. For every 1 value added, there will be 2 bytes skipped since this procedure simply reads data and ignores the input.</p>
      <p>If you have more then one SPI device on the SPI bus, do not interrupt or switch devices until the complete read process has finished with sd_stop_read, do not allow the chip select pin to go  high.</p>
      <codeblock>_usec_delay(100_000)                  -- wait for power to settle
var byte low_byte, high_byte          -- vars for sending and recieving data

-- read the boot sector (sector 0)
sd_start_read(0)                      -- get sd card ready for read at sector 0
for 256 loop                          -- read 1 sector (256 words)
  sd_read_data (low_byte, high_byte)  -- read 2 bytes of data
  serial_hw_write (low_byte)          -- send byte via serial port
  serial_hw_write (high_byte)         -- send byte via serial port
end loop
sd_stop_read()                        -- tell sd card you are done reading</codeblock>
      <p/>
      <p><b>Write some data to your sd card</b></p>
      <p>Writing is also easy, there are 3 procedures within the library that MUST be used.</p>
      <p><b>sd_start_write(20)</b> - start writing at specified sector (sector 20)</p>
      <p><b>sd_read_data(byte1, byte2)</b> - write  to the card (2 bytes at a time)</p>
      <p><b>sd_stop_write()</b> - stop the read process</p>
      <p>When writing to your SD card, you MUST write 512 bytes at a time. In this example, we are writing (256x2) = 512 bytes + (128x2) = 256 bytes for a total of 768 bytes. This means we have written one sector (512 bytes), as well as half of a sector (265 bytes). The half of a sector(256 bytes) that we have written, will not actually be written to the sd card until we finish the sector with data.</p>
      <p>For this reason, you will need to use the sd_write_to_sector_end(value) procedure. This procedure will automatically finish the sector for you with the &quot;value&quot; data specified. In our case we are writing 0x00 till the end of the 512 bytes (end of the sector).</p>
      <p>Just as we noted with reading data, you may not interrupt the SPI port until you have completed the write process with the sd_stop_write procedure.</p>
      <p>Please note that we are writing to sector 20</p>
      <codeblock>-- write (0x66, 0x22) to sector 20 over and over.
low_byte = 0x66                       -- set low byte to write
high_byte = 0x22                      -- set high byte to write

sd_start_write(20)                    -- get sd card ready for write
for 256 + 128 loop                    -- write 1 sector + 1/2 sector
  sd_write_data(low_byte, high_byte)  -- write data to the card
end loop
sd_write_to_sector_end(0x00)          -- 2nd sector is not done, so finish it
                                      -- sectors must be completed during write
                                      
sd_stop_write()                       -- tell sd card you are done writing</codeblock>
      <p/>
      <p><b>Read back the data we have written</b></p>
      <p>Now read 2 sectors (1024 bytes) from sector 20 (where we had previously written data). You will get 512  + 256 bytes of 0x66 &amp; 0x22 as well as 256 bytes of 0x00&apos;s</p>
      <codeblock>-- read the data back, should get (0x66, 0x22) over and over.
sd_start_read(20)                     -- get sd card ready for read at sector 20
for 512 loop                          -- read 2 sectors (512 words)
  sd_read_data (low_byte, high_byte)  -- read 2 bytes of data
  serial_hw_write (low_byte)          -- send byte via serial port
  serial_hw_write (high_byte)         -- send byte via serial port
end loop
sd_stop_read()                        -- tell sd card you are done reading</codeblock>
      <p/>
      <p>Now you can put whatever you want on your SD card, or possibly read lost data off of it.</p>
      <p>If you want to read files stored on the card by your PC, there wil soon be a FAT32 library and tutorial so you can easily browse, read and write to files and folders stored on your card. </p>
      <p>What are you waiting for, go build something cool!</p>
    </section>
  </body>
</topic>
