<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
    <head>
		<title>usb_serial - jallib API doc</title>
    </head>
    <body>
		
		        <div id="page">
        
            <div id="pagecontent">

			    
	<a href="#toc" name="usb_serial">
    <h1>usb_serial</h1>
	</a>

    <div>
		<font size="+1"><i>USB Serial</i></font>
	</div>

	<br/>

    <div class="narrow">
        
	<table>
	<tr>
		<td style="border: 1px solid #aaa; padding: 5px;">
			<b>Author</b>
		</td>
		<td style="border: 1px solid #aaa; padding: 5px;">
			Albert Faber, Copyright (c) 2009, all rights reserved.
		</td>
	</tr>
	<tr>
		<td style="border: 1px solid #aaa; padding: 5px;">
			<b>Adapted-by</b>
		</td>
		<td style="border: 1px solid #aaa; padding: 5px;">
			
		</td>
	</tr>
	<tr>
		<td style="border: 1px solid #aaa; padding: 5px;">
			<b>Compiler</b>
		</td>
		<td style="border: 1px solid #aaa; padding: 5px;">
			>=2.4k
		</td>
	</tr>
	</table>

	<br/>
	
	<b>Description</b>
	<p>
		<pre>The library will ease the use of for serial communication over 
the USB interface. By default nothing has to be defined by the user, below
an example how to use the library


                                                                        
include usb_serial
..
usb_serial_init()
..
;-- optionally wait till USB becomes available
while ( usb_cdc_line_status() ==  0x00 )  loop
end loop
..
;-- main loop
var byte ch
forever loop
;   -- call the flush routine on a regular base in the main loop
;   -- in order to keep the USB communicaiton alive
    usb_serial_flush()
    if ( usb_serial_read( ch ) )
		usb_serial_data = ch -- echo
	end if
    	.....
end loop


                                                                        
In addition this library can be used in combination with other JAL
libraries, like print.jal and format.jal, for example to send a
string, one can use the following code fragment:


                                                                        
const byte str[] = "Hello World"
print_string( usb_serial_data, str )


                                                                        
customization
The usb_serial library offers the following custimization prameters, 
the user has the ability to set these const parameter(s) before the 
inclusion of the usb_serial file


                                                                        
const byte USB_CDC_RX_BUFFER_SIZE = 0x??  -- set receive FIFO size
const byte USB_CDC_TX_BUFFER_SIZE = 0x??  -- set transmit FIFO size
const word USB_SERIAL_PRODUCT_ID = 0x???? -- set USB device product ID
const word USB_SERIAL_VENDOR_ID = 0x????  -- set USB device vendor ID
const byte USB_STRING0[] = { .. }         -- set USB language string
const byte USB_STRING1[] = { .. }         -- set USB mfg string
const byte USB_STRING2[] = { .. }         -- set USB product string
</pre>

	</p>
	<br/>


	<b>Notes</b>
	<p>
		<pre>-
</pre>

	</p>
	<br/>
	
	<b>Dependencies</b>
	<p>
		<ul>
			<li><a href="usb_drv.html">usb_drv</a></li>
			<li><a href="usb_defs.html">usb_defs</a></li>
			<li><a href="usb_drv_cdc_class.html">usb_drv_cdc_class</a></li>
			<li><a href="usb_drv_core.html">usb_drv_core</a></li>
		</ul>


			<br/>
				<h2><a name="summary">Summary</a></h2>

		<h3><a name="Global variables/contants">Global variables/contants</a></h3>
		<ul>
		<li>
				<b><code name="code" class="python"><a href="#8fb7014d78a20bff78e6ecf0eff73254">const byte USB_DSC_FN_ACM                  = 0x02    -- ACM - Abstract Control Management
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#c00a9fbe2e1b106391538bd5da6f6953">const word USB_EP1_IN_ADDR  = (USB_EP1_OUT_ADDR + USB_EP1_OUT_SIZE )
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#64969fce3a4dc0dbde5cbabfa6f3d5a3">const byte USB_DSC_FN_USB_TERMINAL         = 0x09
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#00306088e6d815c46a32f5d52018845b">const bit USB_EP1 = 1
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#8578157fd8424d6c424341bcc5b9e991">const byte USB_DSC_FN_RPT_CAPABILITIES     = 0x05
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#714fb3bbfdd88974a9829d68f0ddd465">const byte USB_EP1_OUT_SIZE = 8
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#605b901fffa84ef441274689775f1d12">var volatile byte usb_cdc_eptx_buffer[USB_EP3_IN_SIZE] at USB_EP3_IN_ADDR
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#70bcd1fb7139137949880e10eaefce7b">const byte USB_DSC_FN_TELEPHONE_RINGER     = 0x04
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#a021cc2174e575946538a36610718376">const byte USB_DSC_FN_UNION                = 0x06
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#1718126bc503541c640fb451c2c800d3">const byte USB_EP1_IN_SIZE  = 8
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#17cf486ddfdd27fdc5c4cc61c3095f45">const byte USB_EP2_IN_SIZE  = 8
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#f424f95e86468ffa41488092864c2c7e">const byte USB_DSC_FN_TEL_OP_MODES         = 0x08
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#ad0730b860865fd6ba7114f3b6234909">const word USB_EP1_OUT_ADDR = (USB_BASE_ADDRESS + 0x0030 )
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#9bd5154468e76ef9504c4305b61273cb">var volatile byte usb_ep1in_buf[ USB_EP1_IN_SIZE ] at USB_EP1_IN_ADDR
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#514d68efe332ae52172e2ca7684b025c">const byte USB_EP3_OUT_SIZE = 8
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#69c0776fee7c7b7837ca305e60cffdf9">const byte USB_STRING1[0x36] = 
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#81ace7a17118de9f933a7d3283a5f97f">const byte USB_DSC_FN_CALL_MGT             = 0x01
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#b9efbfe57b4a091bbc36937f6598cb06">const word USB_SERIAL_PRODUCT_ID = 0x000A
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#460d5c30521065bc57180bcd28f80329">const byte USB_DSC_FN_COUNTRY_SELECTION    = 0x07
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#695bdf5e3bce4ad1f410339fcdee3936">const byte USB_STRING0[] = 
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#c86c2cf3c068614a650cfd4023ea02ef">const word USB_EP0_OUT_ADDR = (USB_BASE_ADDRESS + 0x0020 )
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#47b72724d5d6ec39a2e1a53665505798">const byte USB_EP3_IN_SIZE = 8
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#c34c181687a1ab24150395ce5ba6dc6c">const bit USB_EP3 = 1
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#8ce7bff9e2176a641ef6a1e3331fa87a">const byte USB_DEVICE_DESCRIPTOR[USB_DEVICE_DESCRIPTOR_SIZE] = {
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#f4c8290da11635d2ac4f7d012a6781a2">const word USB_SERIAL_VENDOR_ID = 0x04D8
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#6dbe2764b4baf44cb2f6f76330323a00">const byte USB_CDC_NO_PROTOCOL = 0x00    -- No class specific protocol required
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#c6739c3d4f86105e5132e71caac0e7fb">const word USB_EP2_OUT_ADDR = (USB_BASE_ADDRESS + 0x0040 )
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#c2324d925a3c5baa39e15c652e792a27">var volatile byte usb_ep3out_buf[ USB_EP3_OUT_SIZE ] at USB_EP3_OUT_ADDR
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#db4b4143a83165773305f9bf21a59338">const byte USB_EP0_IN_SIZE  = 8
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#1097247dfe21f11e99d5289ff713a377">const word USB_CDC_BULK_OUT_EP_ADDR = USB_EP3_OUT_ADDR
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#25d24e540e13800761edd43a089494f3">const byte USB_CDC_DATA_ENDPOINT = 3
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#0f03c25e8f5f84eccbc7058f53b21382">var volatile byte usb_ep1out_buf[ USB_EP1_OUT_SIZE ] at USB_EP1_OUT_ADDR
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#6ff716ea3444a32eaa1d092198df6531">const byte USB_DSC_FN_DLM                  = 0x03    -- DLM - Direct Line Managment
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#70bd06be40bb41af26d2041fd07132db">const bit USB_EP2 = 1
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#6f75993aeb5f11d9782677def8cab364">const word USB_CDC_LINE_CODING_LOC = (USB_BASE_ADDRESS + 0x00E8 )
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#da66aca4af07b7a10df4a98370c4025c">const byte USB_STRING2[30] = 
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#9cf2affd4298a4776f00eddafa84adb3">const byte USB_CONFIGURATION_DESCRIPTOR[ USB_CONFIGURATION_DESCRIPTOR_SIZE ]=
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#24400778d40f6f0b0c5cc351bccbf739">const byte USB_CDC_BULK_IN_EP_SIZE  = USB_EP3_IN_SIZE
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#2c49e97e401c7af9f5ca23766c5934ca">const byte USB_CDC_RX_BUFFER_SIZE = 0x10
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#c39e329376fd5d501afb9326dba2f000">const byte USB_EP0_OUT_SIZE = 8
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#e8502a8c3ec182c3d96308925633e7d9">const word USB_EP2_IN_ADDR  = (USB_EP2_OUT_ADDR + USB_EP2_OUT_SIZE )
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#c7c39aa6c23829ffeff6437ae775cad3">var volatile byte usb_ep3in_buf[ USB_EP3_IN_SIZE ] at USB_EP3_IN_ADDR
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#4c3d9b8ee773006e52c1bf2ba57c651e">const word USB_EP3_OUT_ADDR = (USB_BASE_ADDRESS + 0x0050 )
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#9f7cf9f86e5262b86054cc6225954798">const byte USB_CDC_DATA_INTF = 0x0A
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#8f39027da252a8d49bdf0b42577ac6e8">const byte USB_CS_INTERFACE                = 0x24
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#d0c821279f29f36ef749911cb6930402">const byte USB_EP2_OUT_SIZE = 8
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#505dbc709d63bd5a2b16050fc71a1345">const USB_CONFIGURATION_DESCRIPTOR_SIZE = 0x09 + 0x09 + 0x05 + 0x04 + 0x05 + 0x05 + 0x07 + 0x09 + 0x07 + 0x07
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#d6bce837dad9bebb35955d10c9c714bd">const byte USB_DSC_FN_HEADER               = 0x00
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#6b6bb94fab932ed57d7debdc6d830244">var volatile byte usb_ep2in_buf[ USB_EP2_IN_SIZE ] at USB_EP2_IN_ADDR
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#f7a8ef1386e56c138884ee600a37e3f7">var volatile byte usb_ep0in_buf[ USB_EP0_IN_SIZE ] at USB_EP0_IN_ADDR
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#86dc61988c7425498529e1d38ec75588">const word USB_EP0_IN_ADDR  = (USB_EP0_OUT_ADDR + USB_EP0_OUT_SIZE )
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#d56c2dce7eca61e26a4374207c77351b">const byte USB_CDC_INT_EP_SIZE = 8
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#be8ab9fdee0853a5b6a5dc79359fd517">const byte USB_CDC_COMM_INTF_ID = 0x00
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#e45d967c814d0a469b41280ce3404710">var volatile byte usb_ep0out_buf[ USB_EP0_OUT_SIZE ] at USB_EP0_OUT_ADDR
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#cd9c44819b1bbf4d9da93fd200986cfd">const word USB_EP3_IN_ADDR  = (USB_EP3_OUT_ADDR + USB_EP3_OUT_SIZE )
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#e92399bf894a3a537f7ba592a4db049e">const word USB_CDC_BULK_IN_EP_ADDR = USB_EP3_IN_ADDR
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#9e6ace6011b689a8722d2dcdeb7cc0f3">const byte USB_CDC_DATA_INTF_ID = 0x01
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#5961ce301aa111738d3f7e4beddc2eb3">var volatile byte usb_ep2out_buf[ USB_EP2_OUT_SIZE ] at USB_EP2_OUT_ADDR
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#d8e58388a5af01e7aec2450f9eab3288">const byte USB_CS_ENDPOINT                 = 0x25
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#0e2a77696c10e50bc1b1f41b7773cfe7">const byte USB_DCS_INTERFACE               = 0x04
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#395a1c10c00f0fd38b6edc8881d01f12">const byte USB_CDC_TX_BUFFER_SIZE = 0x20
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#46303d3ab976f419b542721a7a1e93ff">var volatile byte usb_cdc_eprx_buffer[USB_EP3_OUT_SIZE] at USB_EP3_OUT_ADDR
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#23a60f506ca6bee2848cf696ebdb5731">const bit USB_EP0 = 1
</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#4aababb884af408d406413abc731c38e">const byte USB_CDC_BULK_OUT_EP_SIZE = USB_EP3_OUT_SIZE
</a></code></b>
		</li>
	</ul>


		<h3><a name="Procedures">Procedures</a></h3>
		<ul>
		<li>
				<b><code name="code" class="python"><a href="#b0762301920c006f6ff9733dae4d8b3a">usb_serial_data'put(byte in data)</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#63fcc9d873d37866570c163784f3df84">usb_serial_init()</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#9d4aaf39dd0104d860ea3c5ea77bf153">usb_serial_flush()</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#84274d949f7bc217a09eac370dfa8d27">usb_serial_write(byte in data)</a></code></b>
		</li>
	</ul>


		<h3><a name="Functions">Functions</a></h3>
		<ul>
		<li>
				<b><code name="code" class="python"><a href="#4b0aee1f9f648dca0eee42868e19738a">usb_serial_data'get() return byte</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#7509c0829986e150bdec81777a1c7bb4">usb_serial_read(byte out data) return bit</a></code></b>
		</li>
	</ul>

	<i><small>Private</small></i>
		<ul>
		<li>
				<b><code name="code" class="python"><a href="#84f9ef42763d9fde7256fe6e88f75770">_usb_serial_read(byte out data) return bit</a></code></b>
		</li>
	</ul>

	<br/>


			<br/>
				<h2><a name="api">API details</a></h2>

		<h3><a name="Global variables/contants">Global variables/contants</a></h3>
		<ul>
		<li>
				<b><code name="code" class="python"><a name="8fb7014d78a20bff78e6ecf0eff73254" href="#summary">const byte USB_DSC_FN_ACM                  = 0x02    -- ACM - Abstract Control Management
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="c00a9fbe2e1b106391538bd5da6f6953" href="#summary">const word USB_EP1_IN_ADDR  = (USB_EP1_OUT_ADDR + USB_EP1_OUT_SIZE )
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="64969fce3a4dc0dbde5cbabfa6f3d5a3" href="#summary">const byte USB_DSC_FN_USB_TERMINAL         = 0x09
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="00306088e6d815c46a32f5d52018845b" href="#summary">const bit USB_EP1 = 1
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="8578157fd8424d6c424341bcc5b9e991" href="#summary">const byte USB_DSC_FN_RPT_CAPABILITIES     = 0x05
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="714fb3bbfdd88974a9829d68f0ddd465" href="#summary">const byte USB_EP1_OUT_SIZE = 8
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="605b901fffa84ef441274689775f1d12" href="#summary">var volatile byte usb_cdc_eptx_buffer[USB_EP3_IN_SIZE] at USB_EP3_IN_ADDR
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="70bcd1fb7139137949880e10eaefce7b" href="#summary">const byte USB_DSC_FN_TELEPHONE_RINGER     = 0x04
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="a021cc2174e575946538a36610718376" href="#summary">const byte USB_DSC_FN_UNION                = 0x06
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="1718126bc503541c640fb451c2c800d3" href="#summary">const byte USB_EP1_IN_SIZE  = 8
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="17cf486ddfdd27fdc5c4cc61c3095f45" href="#summary">const byte USB_EP2_IN_SIZE  = 8
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="f424f95e86468ffa41488092864c2c7e" href="#summary">const byte USB_DSC_FN_TEL_OP_MODES         = 0x08
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="ad0730b860865fd6ba7114f3b6234909" href="#summary">const word USB_EP1_OUT_ADDR = (USB_BASE_ADDRESS + 0x0030 )
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="9bd5154468e76ef9504c4305b61273cb" href="#summary">var volatile byte usb_ep1in_buf[ USB_EP1_IN_SIZE ] at USB_EP1_IN_ADDR
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="514d68efe332ae52172e2ca7684b025c" href="#summary">const byte USB_EP3_OUT_SIZE = 8
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="69c0776fee7c7b7837ca305e60cffdf9" href="#summary">const byte USB_STRING1[0x36] = 
</a></code></b>
				<p>	<pre>
USB_STRING1 shall contain the USB device descriptor string
The user has the ability to define the string content of 
USB_STRING1 before inclusion of the usb_serial library to 
override the default content ("Microchip Technology Inc.").
note that the USB shall contain 16 bit unicode characters, little endian
encoded, and that the first field of USB_STRING1 shall contain the size
of the entire USB_STRING1 array, the second byte shall be set to  
USB_DT_STRING (=0x03).

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="81ace7a17118de9f933a7d3283a5f97f" href="#summary">const byte USB_DSC_FN_CALL_MGT             = 0x01
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="b9efbfe57b4a091bbc36937f6598cb06" href="#summary">const word USB_SERIAL_PRODUCT_ID = 0x000A
</a></code></b>
				<p>	<pre>
USB_SERIAL_PRODUCT_ID is set to Microchip CDC if const is not defined 
by the user of the usb_serial library can set the USB_SERIAL_PRODUCT_ID
by defining the const before inclusion of the usb_serial library

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="460d5c30521065bc57180bcd28f80329" href="#summary">const byte USB_DSC_FN_COUNTRY_SELECTION    = 0x07
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="695bdf5e3bce4ad1f410339fcdee3936" href="#summary">const byte USB_STRING0[] = 
</a></code></b>
				<p>	<pre>
USB_STRING0 shall contain the USB strings language ID
The user has the ability to define the string content of 
USB_STRING0 before inclusion of the usb_serial library to 
override the default content ( 0x0904 ).
note that the USB shall contain 16 bit unicode characters, little endian
encoded, and that the first field of USB_STRING0 shall contain the size
of the entire USB_STRING0 array, the second byte shall be set to  
USB_DT_STRING (=0x03).

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="c86c2cf3c068614a650cfd4023ea02ef" href="#summary">const word USB_EP0_OUT_ADDR = (USB_BASE_ADDRESS + 0x0020 )
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="47b72724d5d6ec39a2e1a53665505798" href="#summary">const byte USB_EP3_IN_SIZE = 8
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="c34c181687a1ab24150395ce5ba6dc6c" href="#summary">const bit USB_EP3 = 1
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="8ce7bff9e2176a641ef6a1e3331fa87a" href="#summary">const byte USB_DEVICE_DESCRIPTOR[USB_DEVICE_DESCRIPTOR_SIZE] = {
</a></code></b>
				<p>	<pre>
Sets the default USB_DEVICE_DESCRIPTOR record. It is not expected
that the user of the usb_serial library needs to create its own
record. However, if needed in exeptional cases, the user has the
ability to define the 
const byte USB_DEVICE_DESCRIPTOR[USB_DEVICE_DESCRIPTOR_SIZE]
before inclusion of the usb_serial library

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="f4c8290da11635d2ac4f7d012a6781a2" href="#summary">const word USB_SERIAL_VENDOR_ID = 0x04D8
</a></code></b>
				<p>	<pre>USB_SERIAL_VENDOR_ID is set to Microchip if const is not defined by 
the user of the usb_serial library. One can set the USB_SERIAL_VENDOR_ID
by defining the const before inclusion of the usb_serial library

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="6dbe2764b4baf44cb2f6f76330323a00" href="#summary">const byte USB_CDC_NO_PROTOCOL = 0x00    -- No class specific protocol required
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="c6739c3d4f86105e5132e71caac0e7fb" href="#summary">const word USB_EP2_OUT_ADDR = (USB_BASE_ADDRESS + 0x0040 )
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="c2324d925a3c5baa39e15c652e792a27" href="#summary">var volatile byte usb_ep3out_buf[ USB_EP3_OUT_SIZE ] at USB_EP3_OUT_ADDR
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="db4b4143a83165773305f9bf21a59338" href="#summary">const byte USB_EP0_IN_SIZE  = 8
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="1097247dfe21f11e99d5289ff713a377" href="#summary">const word USB_CDC_BULK_OUT_EP_ADDR = USB_EP3_OUT_ADDR
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="25d24e540e13800761edd43a089494f3" href="#summary">const byte USB_CDC_DATA_ENDPOINT = 3
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="0f03c25e8f5f84eccbc7058f53b21382" href="#summary">var volatile byte usb_ep1out_buf[ USB_EP1_OUT_SIZE ] at USB_EP1_OUT_ADDR
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="6ff716ea3444a32eaa1d092198df6531" href="#summary">const byte USB_DSC_FN_DLM                  = 0x03    -- DLM - Direct Line Managment
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="70bd06be40bb41af26d2041fd07132db" href="#summary">const bit USB_EP2 = 1
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="6f75993aeb5f11d9782677def8cab364" href="#summary">const word USB_CDC_LINE_CODING_LOC = (USB_BASE_ADDRESS + 0x00E8 )
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="da66aca4af07b7a10df4a98370c4025c" href="#summary">const byte USB_STRING2[30] = 
</a></code></b>
				<p>	<pre>
USB_STRING2 shall contain the USB product descriptor string
The user has the ability to define the string content of 
USB_STRING1 before inclusion of the usb_serial library to 
override the default content ("JAL Serial.").
note that the USB shall contain 16 bit unicode characters, little endian
encoded, and that the first field of USB_STRING1 shall contain the size
of the entire USB_STRING2 array, the second byte shall be set to  
USB_DT_STRING (=0x03).

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="9cf2affd4298a4776f00eddafa84adb3" href="#summary">const byte USB_CONFIGURATION_DESCRIPTOR[ USB_CONFIGURATION_DESCRIPTOR_SIZE ]=
</a></code></b>
				<p>	<pre>
Sets the default USB_CONFIGURATION_DESCRIPTOR record. It is not expected
that the user of the usb_serial library needs to create its own
record. However, if needed in exeptional cases, the user has the
ability to define the const byte USB_CONFIGURATION_DESCRIPTOR[]
before inclusion of the usb_serial library to customize the USB
conifguration

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="24400778d40f6f0b0c5cc351bccbf739" href="#summary">const byte USB_CDC_BULK_IN_EP_SIZE  = USB_EP3_IN_SIZE
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="2c49e97e401c7af9f5ca23766c5934ca" href="#summary">const byte USB_CDC_RX_BUFFER_SIZE = 0x10
</a></code></b>
				<p>	<pre>
USB_CDC_RX_BUFFER_SIZE contains the size of the receive FIFO buffer
a large(r) buffer can speed up the transmission speed at the cost
of free memory space. The user of the usb_serial library has the 
ability to control size of the FIFO buffer, by defining the 
const byte USB_CDC_RX_BUFFER_SIZE = 0x?? before the inclusion of
the usb_serial file

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="c39e329376fd5d501afb9326dba2f000" href="#summary">const byte USB_EP0_OUT_SIZE = 8
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="e8502a8c3ec182c3d96308925633e7d9" href="#summary">const word USB_EP2_IN_ADDR  = (USB_EP2_OUT_ADDR + USB_EP2_OUT_SIZE )
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="c7c39aa6c23829ffeff6437ae775cad3" href="#summary">var volatile byte usb_ep3in_buf[ USB_EP3_IN_SIZE ] at USB_EP3_IN_ADDR
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="4c3d9b8ee773006e52c1bf2ba57c651e" href="#summary">const word USB_EP3_OUT_ADDR = (USB_BASE_ADDRESS + 0x0050 )
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="9f7cf9f86e5262b86054cc6225954798" href="#summary">const byte USB_CDC_DATA_INTF = 0x0A
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="8f39027da252a8d49bdf0b42577ac6e8" href="#summary">const byte USB_CS_INTERFACE                = 0x24
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="d0c821279f29f36ef749911cb6930402" href="#summary">const byte USB_EP2_OUT_SIZE = 8
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="505dbc709d63bd5a2b16050fc71a1345" href="#summary">const USB_CONFIGURATION_DESCRIPTOR_SIZE = 0x09 + 0x09 + 0x05 + 0x04 + 0x05 + 0x05 + 0x07 + 0x09 + 0x07 + 0x07
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="d6bce837dad9bebb35955d10c9c714bd" href="#summary">const byte USB_DSC_FN_HEADER               = 0x00
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="6b6bb94fab932ed57d7debdc6d830244" href="#summary">var volatile byte usb_ep2in_buf[ USB_EP2_IN_SIZE ] at USB_EP2_IN_ADDR
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="f7a8ef1386e56c138884ee600a37e3f7" href="#summary">var volatile byte usb_ep0in_buf[ USB_EP0_IN_SIZE ] at USB_EP0_IN_ADDR
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="86dc61988c7425498529e1d38ec75588" href="#summary">const word USB_EP0_IN_ADDR  = (USB_EP0_OUT_ADDR + USB_EP0_OUT_SIZE )
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="d56c2dce7eca61e26a4374207c77351b" href="#summary">const byte USB_CDC_INT_EP_SIZE = 8
</a></code></b>
				<p>	<pre>set the size of the interrupt interface
</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="be8ab9fdee0853a5b6a5dc79359fd517" href="#summary">const byte USB_CDC_COMM_INTF_ID = 0x00
</a></code></b>
				<p>	<pre>set the communication interface ID
</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="e45d967c814d0a469b41280ce3404710" href="#summary">var volatile byte usb_ep0out_buf[ USB_EP0_OUT_SIZE ] at USB_EP0_OUT_ADDR
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="cd9c44819b1bbf4d9da93fd200986cfd" href="#summary">const word USB_EP3_IN_ADDR  = (USB_EP3_OUT_ADDR + USB_EP3_OUT_SIZE )
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="e92399bf894a3a537f7ba592a4db049e" href="#summary">const word USB_CDC_BULK_IN_EP_ADDR = USB_EP3_IN_ADDR
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="9e6ace6011b689a8722d2dcdeb7cc0f3" href="#summary">const byte USB_CDC_DATA_INTF_ID = 0x01
</a></code></b>
				<p>	<pre>set the interrupt interface ID
</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="5961ce301aa111738d3f7e4beddc2eb3" href="#summary">var volatile byte usb_ep2out_buf[ USB_EP2_OUT_SIZE ] at USB_EP2_OUT_ADDR
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="d8e58388a5af01e7aec2450f9eab3288" href="#summary">const byte USB_CS_ENDPOINT                 = 0x25
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="0e2a77696c10e50bc1b1f41b7773cfe7" href="#summary">const byte USB_DCS_INTERFACE               = 0x04
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="395a1c10c00f0fd38b6edc8881d01f12" href="#summary">const byte USB_CDC_TX_BUFFER_SIZE = 0x20
</a></code></b>
				<p>	<pre>
USB_CDC_TX_BUFFER_SIZE contains the size of the transmit FIFO buffer
a large(r) buffer can speed up the transmission speed at the cost
of free memory space. The user of the usb_serial library has the 
ability to control size of the FIFO buffer, by defining the 
const byte USB_CDC_TX_BUFFER_SIZE = 0x?? before the inclusion of
the usb_serial file

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="46303d3ab976f419b542721a7a1e93ff" href="#summary">var volatile byte usb_cdc_eprx_buffer[USB_EP3_OUT_SIZE] at USB_EP3_OUT_ADDR
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="23a60f506ca6bee2848cf696ebdb5731" href="#summary">const bit USB_EP0 = 1
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="4aababb884af408d406413abc731c38e" href="#summary">const byte USB_CDC_BULK_OUT_EP_SIZE = USB_EP3_OUT_SIZE
</a></code></b>
				<p><i>No documentation found</i></p>
		</li>
	</ul>


		<h3><a name="Procedures">Procedures</a></h3>
		<ul>
		<li>
				<b><code name="code" class="python"><a name="b0762301920c006f6ff9733dae4d8b3a" href="#summary">usb_serial_data'put(byte in data)</a></code></b>
				<p>	<pre>
usb_serial_data'put - write char to the USB port, blocking

Asynchronuous serial send routine, using the USB Cummunication class
Sends byte X (8 bit) to the USB host (via virtual COM port)
Note that characters are dropped when the communcation channel on the
USB host side is not opened (yet), this is a design choice in order to
avoid lockup(s)

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="63fcc9d873d37866570c163784f3df84" href="#summary">usb_serial_init()</a></code></b>
				<p>	<pre>
usb_serial_init will setup the USB communication, however, this can be
a time consuming process, therefore this call is non blocking.
In order to check if the USB device has established contact with the 
HOST USB device, one can call the usb_is_configured() function, see
usb_is_configured() documentation for additional details.

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="9d4aaf39dd0104d860ea3c5ea77bf153" href="#summary">usb_serial_flush()</a></code></b>
				<p>	<pre>
usb_serial_flush shall be called on a regular base (millisecond range)
in order to keep the USB transmision alive. Therfore it is adviced to
call the usb_serial_flush procedure in the main loop of your 
application

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="84274d949f7bc217a09eac370dfa8d27" href="#summary">usb_serial_write(byte in data)</a></code></b>
				<p>	<pre>
usb_serial_write - write char to the USB port, blocking

Asynchronuous serial send routine, using the USB Cummunication class
Sends byte X (8 bit) to the USB host (via virtual COM port)
Checks (and waits if necessary) if FIFO buffer is full
Note that characters are dropped when the communcation channel on the
USB host side is not opened (yet), this is a design choice in order to
avoid lockup(s)

</pre>
</p>
		</li>
	</ul>


		<h3><a name="Functions">Functions</a></h3>
		<ul>
		<li>
				<b><code name="code" class="python"><a name="4b0aee1f9f648dca0eee42868e19738a" href="#summary">usb_serial_data'get() return byte</a></code></b>
				<p>	<pre>
usb_serial_data'get() - read a char (blocking!)
   
usb_serial_data'get() waits till a character has been received and
returns it

</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="7509c0829986e150bdec81777a1c7bb4" href="#summary">usb_serial_read(byte out data) return bit</a></code></b>
				<p>	<pre>
usb_serial_read - read char if available (non-blocking)
   
usb_serial_read returns true if a character has been received, 
otherwise returns false. If function returns true, the data variable
is valid, and contains the character that has been received. In other
cases the data variable is not defined
Note that characters are dropped when the communcation channel on the
USB host side is not opened (yet), this is a design choice in order to
avoid lockup(s)

</pre>
</p>
		</li>
	</ul>

	<i><small>Private</small></i>
		<ul>
		<li>
				<b><code name="code" class="python"><a name="84f9ef42763d9fde7256fe6e88f75770" href="#summary">_usb_serial_read(byte out data) return bit</a></code></b>
				<p>	<pre>
_usb_serial_read - internal use only!

_usb_serial_read returns true if a character has been received, 
otherwise returns false. If function returns true, the data variable
is valid, and contains the character that has been received. In other
cases the data variable is not defined
Note that characters are dropped when the communcation channel on the
USB host side is not opened (yet), this is a design choice in order to
avoid lockup(s)

</pre>
</p>
		</li>
	</ul>

	<br/>


			<br/>
				<h2><a name="related_samples">Related samples</a></h2>
	Here are the list of samples which use this library:<br/><br/>
	<table border=1>
			<tr>
			<td><b>18f14k50</b></td><td><a href="http://code.google.com/p/jallib/source/browse/trunk/sample/18f14k50_usb_serial.jal" target="_blank">18f14k50_usb_serial.jal</a></td>
			</tr>
			<tr>
			<td><b>18f2450</b></td><td><a href="http://code.google.com/p/jallib/source/browse/trunk/sample/18f2450_usb_serial.jal" target="_blank">18f2450_usb_serial.jal</a></td>
			</tr>
			<tr>
			<td><b>18f4550</b></td><td><a href="http://code.google.com/p/jallib/source/browse/trunk/sample/18f4550_usb_serial.jal" target="_blank">18f4550_usb_serial.jal</a></td>
			</tr>
	</table>

			<br/>

            </div>
        </div>


	</body>
</html>

