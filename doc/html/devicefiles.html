<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Jallib Device Files Users Guide</title>
  <meta http-equiv="content-type" content="text/html; charset=US-ASCII">
  <meta name="author" content="Rob Hamerling">
  <meta name="description" content="Jallib Device File Users Guide">
  <meta name="copyright" content="Copyright (c) Rob Hamerling 2008..2009, All rights reserved">
  <meta name="project" content="This file is part of jallib  http://jallib.googlecode.com">
  <meta name="license" content="Released under the BSD license"
                             "http://www.opensource.org/licenses/bsd-license.php">
  <meta name="compiler" content="2.4">
  <link rel="stylesheet" href="jallib.css" type="text/css">
</head>
<body LANG="en-US" DIR="LTR">

<h1>Jallib Device Files Users Guide</h1>
<p><center>by Rob Hamerling</center>

<h2>Introduction</h2>

<p>When I started with JAL it struck me that there were so few JALV2 include
files, in particular not for some of my favorite PICmicros (e.g. 16F690,
12F683).
Unfortunately the output of INC2JAL for these chips caused compile-time
errors with my programs and I was informed that INC2JAL is not up-to-date
for JalV2.
I realized that more people would be in the same position like me.
Having some experience with scanning MPLAB files (for my Xwisp2 program)
I decided to make a script to generate the device files not only for the
desired PICs, but for all PICs supported by the JalV2 compiler!

<p> The advantages of using a script to generate include files are
pretty obvious, such as:
<ul>
<li>creation of device files for all PICmicros available in MPLAB
<li>automatic new device files for new chips in MPLAB
<li>no manual maintenance
<li>consistent layout
<li>consistent naming convention
<li>no errors due to typo's with manual editing
</ul>

<p>The advantages of a consistent naming convention are also obvious:
<ul>
<li>Easy migration of a program from one target PICmicro to another.
<li>Same for libraries using this naming convention.
</ul>

<p>This document gives some design information and user instruction
about these JalV2 device files.
The sources of information are the xxxx.dev files and xxxx.lkr of MPLAB,
supplemented and corrected with information in the datasheets.

<hr>
<h1>The Overall Picture</h1>
<p>With the design of the device files I had in mind a structure as shown
below.
<pre>
                      +----------+   +------------------+
                      | device   |   |     general      |
                      | specific |---|     include      |
                      | include  |   |chipdef_jallib.jal|
                      +----------+   +------------------+
                           |
           +---------------+---------------+-------------
           |               |               |
     +----------+    +----------+    +----------+    +-------
     | function |    | function |    | function |    |
     | include  |    | include  |    | include  |    |   etc
     |'delay_..'|    | 'adc_...'|    |'lcd_....'|    |
     +----------+    +----------+    +----------+    +-------
</pre>

<p>These device files are now part of the central JalV2 library
repository <a href="http://jallib.googlecode.com/">JalLib</a> at
code.google.com, which uses globally the same structure.


<h2>Device Files</h2>

<p>The device files are the base for other include files and contain:
<ul>
<li>An include statement for the common include file 'chipdef_jallib'
<li>CPU type specification (12-, 14- or 16-bits core).
<li>Program memory size specification.
<li>Data memory (EEPROM) location and size specification.
<li>Configuration (fuses) and ID memory specification.
<li>Default fuse settings.
<li>Specification of General Purpose Register (GPR, RAM) location range and
sharing.
<li>Declaration of Special Function Register (SFR) address and mirror adresses,
alias names and bit naming.
<li>Declaration of procedures and functions for shadowing of I/O ports.
<li>Declaration of symbolic names for configuration bits (fuses).
<li>Procedures to switch the ports to digital I/O.
</ul>

<h2>Common Include File 'chipdef_jallib.jal'</h2>

<p>The file 'chipdef_jallib.jal' which comes with these device files
replaces the file 'chipdef.jal' which comes with the compiler distribution.
It is included by each of the device files and contains:
<ul>
<li>Constants required by the compiler.
<li>Commonly used constants by the device files and other libraries.
</ul>

<p>With the statement 'pragma target chip = .....' in every device file the
compiler assigns a value to the variable 'target_chip'.
The program may reference this variable with a symbolic name.
This symbolic name consists of 'pic_' followed by the type of the PIC,
which makes it possible to use the same source file to generate a hex file
for different types of PICs, as the following example shows:

<pre>
    include 16f88

    if (target_chip == PIC_16F88) then          -- (not for 16f87)

      ....                                      -- 16F88 unique code

    end if
</pre>

<p>By changing the include statement to 16f87 (or any other) the statements
between 'if' and 'end if' will be skipped by the compiler.

<p>The list of targets in chipdef_jallib.jal makes sure that every possible
target name and the corresponding value of target_chip is known by the
compiler.

<p>Note: The original chipdef.jal file of the compiler package specifies
a different value for 'target_chip' and not for all PIC type.
Therefore it has to be replaced when using this set of device files.


<h2>Function Include Files</h2>

<p>Function specific include files offer facilities to ease the use of
PIC peripherals (such as USART, ADC), external devices (such as LCDs,
sensors), or extensions to the Jal language such as for data
formatting, mathematical functions, etc.

<p>Function specific include files should be included explicitly as
required by the application program, this is not done by the device files.

<p>In most cases the function include files require some statements to
couple function specific registers and pins with the device.
Read the comments in the library sources and the library documentation
for instructions.
Most libraries contain comments with user instructions in the header of
include files and just ahead of the procedures and functions in these files.



<hr>

<h1>User Information</h1>

<h2>Sample program</h2>

<p>The device files define static device (PICmicro) specific matter.
This allows writing elementary programs, such as for a blinking LED, which
are almost device independent
(differences are mostly in the fuse settings).

<p>The device files are also the base for extensions, such as
libraries for more complicated functions like displaying text on an LCD
display or handling analog devices.

<p>Below a simple blink-an-LED program (LED on pin 1 of Port A) for a
PIC16F886 using a 20 MHz resonator.
In addition to the device-specific information obtained from the include
file '16f886.jal' some run-time iformation is needed, like the speed and
type of the oscillator and some other 'environmental' variables.
No extra function libraries are required.

<pre>
-- ------ Blink-an-LED on pin A1 of a PIC16F886 --------

  include 16f886                        -- target is a PIC16F886
                                        -- Notes: - The extension .jal is
                                        --          added by the compiler!
                                        --        - No other includes needed.

  pragma target clock 20_000_000        -- oscillator frequency (in Hz)
                                        -- required for delays

  pragma target OSC         HS          -- high speed external oscillator
  pragma target WDT         Disabled    -- watchdog off
  pragma target MCLR        External    -- external chip reset
  pragma target LVP         Disabled    -- no low voltage programming

  enable_digital_io()                   -- disable analog module(s)

  var volatile bit led           is pin_A1     -- define alias for pin_A1
  var volatile bit led_direction is pin_A1_direction

  led_direction = output                -- make LED-pin output
  forever loop                          -- endless loop
    led = on                            -- there is light!
    _usec_delay(250000)                 -- spin 1/4 seconds
    led = off                           -- flip (on-&gt;off,off-&gt;on)
    _usec_delay(250000)                 -- spin 1/4 seconds
  end loop

</pre>

<p>When loaded in a 16F886 with 20 MHz resonator or crystal an LED connected
(with series resistor!) to pin 3 (RA1) should blink twice a second.

<h2>Naming conventions for Ports and Pins</h2>

<p>Unfortunately MPLAB of Microchip is not particularly consistent in its
choice of names!
The datasheets and various informational files in MPLAB not infrequently use
different names for the same entity!
Since application programmers are supposed to read the datasheets, the most
obvious would be to use the datasheet names, but these are not part of MPLAB
and would have to be downloaded separately.
And these PDF files are not so easily processed with a script.
So the chosen names are possibly not to what you may be familiar with.

<p>For all registers of the chip a name is defined and where appropriate
also the individual bits or groups of bis are declared.
Also some popular aliases for registers are defined, for example: TMR0IF and
T0IF, TMR0IE and T0IE, etc.

<h3>PORTx and TRISx</h3>
<p>For all ports and port pins a device independent alias is defined and a
similar direction definition, as the following examples show:
<pre>
  var  volatile  byte  PORTA  at  &lt;addr&gt;
  var            byte  PORTA_low                 -- low order nibble
  var            byte  PORTA_high                -- high order nibble
  var  volatile  bit   pin_A0  at  PORTA : 0
  var  volatile  byte  TRISA  at  &lt;addr&gt;
  var  volatile  byte  PORTA_direction at TRISA
  var  volatile  bit   pin_A0_direction at TRISA : 0
</pre>
<p>etc. (for all other existing pins and ports)

<h3>GPIO and TRISIO (with the smaller chips)</h3>
<p>Although the smaller PICs have no 'official' PORTA and TRISA registers,
the device files contain aliases for these.
So even with the smaller PICs you can use the names PORTA, pin_A0, etc.
<pre>
  var  volatile  byte  GPIO   at  &lt;addr&gt;
  var  volatile  byte  PORTA  at  GPIO
  var            byte  PORTA_low                -- low order nibble
  var            byte  PORTA_high               -- high order nibble
  var  volatile  bit   pin_A0  at  GPIO : 0
  var  volatile  byte  TRISIO  at &lt;addr&gt;
  var  volatile  byte  TRISA  at  TRISIO
  var  volatile  byte  PORTA_direction at TRISIO
  var  volatile  bit   pin_A0_direction at TRISIO : 0
</pre>
<p>etc. (for all other existing pins)

<h3>Non-memory-mapped registers</h3>
<p>Some PICs, especially in the baseline series, are missing some memory
mapped registers.
For example the 12-bit core (10Fs, 12F5x, etc) have no memory mapped
TRISx registers, in stead these PICs have TRISx instructions to set
the direction of ports or pins.
This would make it impossible for application programs or function
libraries to use statements like:
<pre>
  PORTA_direction = all_output
</pre>
<p>For this reason the device files contain pseudo variables which mimic
the existence of memory mapped registers.
This makes it possible to use statement like the one above.
<p>For example: even though a 16F59 has no addressable TRISC register,
you can still use
<pre>
  pin_C5_direction = output
</pre>
<p>

<h3>Nibbles</h3>
<p>Since frequently the upper and lower 4 bits ('nibble') of a port are
used as a unit, some procedures and functions are defined to use port
nibbles as a regular variable and set pin directions by 4:
<pre>
  PORTx_low             - bits 0..3
  PORTx_high            - bits 4..7
  PORTx_low_direction
  PORTx_high_direction
</pre>
<p>This makes it possible to use statements like:
<pre>
   PORTA_low_direction = all_output
   PORTA_low = "7"                   -- upper nibble remains unchanged
</pre>
<p>Several Jallib function libraries use this facility.

<h3>Names of MSSP modules</h3>
<p>Names of registers of MSSP modules have been normalized as follows:
<ul>
<li>MSSP module of midrange PICs
<pre>
       SSPADD
       SSPBUF
       SSPCON   - first or only control register
       SSPCON2  - second control register (if present)
       SSPSTAT
</pre>
<li>First or only MSSP module of 18F family:
<pre>
       SSP1ADD
       SSP1BUF
       SSP1CON  - first or only control register
       SSP1CON2 - second control register (if present)
       SSP1MASK
       SSP1STAT
</pre>
<li>Second MSSP module of 18F family
<pre>
       SSP2ADD
       SSP2BUF
       SSP2CON  - control register second module
       SSP2CON2 - second control register (if present)
       SSP2STAT
</pre>
</ul>

<h3>Miscellaneous remarks about names</h3>
<p>When you have used Jal before with other device files or libraries
you may notice some differences in the naming convention:
<ul>
<li>PORTA is used consistently, while previously PORT_A was a
    popular naming convention especially for PORT_A_low/high,
    PORT_A_direction, etc.
    For individual pins the convention 'pin_Ax' is used.
<li>Subfields of registers have the registername as prefix, like
    <br>var volatile bit  INTCON_GIE  at INTCON : 7
<li>When you hit compile errors related to undefined names, scan the
    device files to search for 'our' name of the register or port.
</ul>

<h2>About Port Shadowing</h2>

<p>Port shadowing is a technique to prevent the Read-Modify-Write problem
with I/O ports of PICmicro's.
This is a problem related to its hardware design.
Search the Internet for "PIC  and  read-modify-read" and you'll get many
hits to more or less interesting articles!
None of the explanations are repeated here!
And you don't absolutely need to understand the problem, since by using
the Jallib device files you won't face the problem when you follow some
simple rules and a avoid a few pitfalls.

<p>With port shadowing for the baseline and midrange PICs
(10F, 12F, 16F) a RAM location is used as replacement for the port for
output.
The 18F series have a special register for this purpose (LATx).
Although the techniques are slightly different, the general rules are:
reading is done from the port directly, while writing is done to the
shadow register of which the contents is subsequently passed to the
real port.

<p>With the Jallib device files shadowing is automatic, as long
as you use the following names:
<pre>
  PORTx          - all bits of port x
  PORTx_low      - low order nibble of port x (bits 3..0)
  PORTx_high     - high order nibble of port x (bits 7..4)
  pin_xy         - single bit 'y' of port 'x'
</pre>
(in which 'x' is a port-letter and 'y' a bit number).
<p>Note: The value for both Portx_low and Portx_high is passed with
reading from (and must be passed with writing to) in the lower nibble
(bits 3..0) of a constant or variable.
Portx_low is read from or written to bits 3..0 of Portx,
Portx_high is read from or written to bits 7..4 of Portx.

<p>If you want to use other names for ports, nibbles or individual pins
you must specify an alias.
For example when you have a red LED connected to pin 0 of PortA, you could
specify:
<pre>
  var  bit  led_red  is  pin_A0
</pre>
and use 'led_red = on' or 'led_red = off' in your program.

<p>You should <b>avoid direct pin and I/O port manipulation</b>, because
it will be overruled by the automatic shadowing mechanism. For example
do <b>not</b> specify:
<pre>
  var bit led_red at portA : 0
</pre>

With this specification a 'led-red = on' will have the desired result, but
it will not update the shadow register.
Any next operation which uses the shadowing mechanism will override the
previous direct control operation.

<p>Shadowing is also bypassed when you initialise the alias with the
declaration.
So declaring and initialising an alias as follows:
<pre>
  var  bit led_red is pin_A0 = off
</pre>
is bad practice!
Initialize an alias separatedly after the declaration.

<h2>Naming convention for configuration bits (fuses)</h2>

<p>The configuration bits or groups of bits is such a large variety that it
is almost impossible to obtain a naming convention which covers it all.
<ul>
<li>For all implemented configuration bits an option name and two or more
tags are defined, but the chosen names may not always be intuitive or
convenient.
Some names or tags are very long!
<li>When the compiler stalls over a fuse-def line a correction should
be applied.
If you encounter such occasion please report it in the Jallib
discussion group at Google Groups or Jallist at Yahoo! groups.
<li>For the most frequently used configuration bits a 'standard' option
name is defined, along with a 'standard' tag, see the list below.
</ul>

<p>Only for the oscillator specification the MPLAB information files contain
more than 140 different descriptions!
Because of synonyms this number could be normalized to a much smaller
number!
The first part is the oscillator type, the [optional] second part indicates
a related subfunction.
For example it may indicate if the OSC2 pin is CLKOUT or I/O, or if PLL is
active for the 18F series.
Descriptions in MPLAB which do not fit in the normalization scheme are copied
almost literally.

<h3>Fuse_Def OSC  (oscillator)</h3>
<pre>
      LP              - Low Power crystal on OSC1,OSC2
      XT              - Crystal or Resonator on OSC1,OSC2
      HS              - High Speed Crystal or Resonator on OSC1,OSC2
      HS_PLL          - as HS, PLL active
      EC_CLKOUT       - External Clock (TTL) signal on OSC1, OSC2 is ClockOut
      EC_NOCLKOUT     - External Clock (TTL) signal on OSC1, OSC2 is I/O
      EC_PLL          - as EC, PLL active
      RC_CLKOUT       - RC oscillator on OSC1, OSC2 is ClockOut
      RC_NOCLKOUT     - RC oscillator on OSC1, OSC2 is I/O
      EXTOSC_CLKOUT   - External oscillator on OSC1, ClockOut on OSC2
      EXTOSC_NOCLKOUT - External oscillator on OSC1, OSC2 is I/O
      INTOSC_CLKOUT   - Internal oscillator, OSC1 is I/O, ClockOut on OSC2
      INTOSC_NOCLKOUT - Internal oscillator, OSC1 and OSC2 are I/O
      (other keywords may be used as well)
</pre>

<h3>Fuse_Def WDT  (watchdog)</h3>
<pre>
      ENABLED          - Watchdog enabled
      DISABLED         - Watchdog disabled
</pre>

<h3>Fuse_Def WDTPS  (Watchdog postscaler)</h3>
<pre>
      P32768           -  1 : 32,768
      P16384           -  1 : 16,384
      P...             -  1 : ...
      P..              -  1 : ..
      P2               -  1 : 2
      P1               -  1 : 1
</pre>

<h3>Fuse_Def MCLR  (reset)</h3>
<pre>
      EXTERNAL         - /MCLR pin enabled
      INTERNAL         - /MCLR pin is digital I/O
</pre>

<h3>Fuse_Def PWRTE  (power reset timeout)</h3>
<pre>
      ENABLED          - Power up timer enabled
      DISABLED         - Power Up timer disabled
</pre>

<h3>Fuse_Def BROWNOUT  (Brown Out detect)</h3>
<pre>
      ENABLED          - BOD enabled, SBOREN disabled
      RUNONLY          - BOD enabled in run, disabled in sleep
      CONTROL          - SBOREN controls BOR function
      DISABLED         - BOD and SBOREN disabled
</pre>

<h3>Fuse_Def VOLTAGE  (Brown Out voltage)</h3>
<pre>
      V20              - 2.0 Volt
      V27              - 2.7 Volt
      V42              - 4.0 Volt
      V45              - 4.5 Volt
      ...  etc (whatever voltages are applicable)
</pre>

<h3>Fuse_Def LVP  (Low Voltage Programming)</h3>
<pre>
      ENABLED          - LVP on, enabled
      DISABLED         - LVP off, disabled
</pre>

<h3>Fuse_Def CP  (Code Protection)</h3>
<pre>
      ENABLED          - Code protection on, enabled
      DISABLED         - Code Protection off, disabled
</pre>

<h3>Fuse_Def CPD  (EEPROM Data Protection)</h3>
<pre>
      ENABLED          - Data Protection on, enabled
      DISABLED         - Data Protection off, disabled
</pre>

<h3>Fuse_Def IOSCFS  (Internal Oscillator Frequency Select)</h3>
<pre>
      F4MHZ            - 4 MHz
      F8MHZ            - 8 MHz
</pre>

<p><b>Notes:</b>
<ol>
<li>In addition to these 'standard' fuse_defs above there may be others,
depending on the features of the specific PICmicro.
Please read the device file to see which fuse-defs are available for your
target PICmicro.
<li>The terms 'Enabled' and 'Disabled' may need to be specified where
usually 'On' and 'Off' are used.
</ol>

<p>When a fuse_def statement causes compile-time error messages you may
simply delete it and specify the fuse-word(s) or -byte(s) explicitly with
bit patterns in stead of using fuse option pragma statements.
For example for the PIC16F690 the following group of statements:
<pre>
   pragma target OSC       HS
   pragma target WDT       Disabled
   pragma target PWRTE     Enabled
   pragma target MCLR      External
   pragma target CP        Disabled
   pragma target CPD       Disabled
   pragma target BROWNOUT  Enabled
   pragma target IESO      Disabled
   pragma target FCMEN     Disabled
</pre>
is equivalent with:
<pre>
   pragma target fuses   0b11_0011_1110_0010
</pre>

<p>PICs with 16-bits core (the 18F series) have such a large set and
variety of configuration bits that explicit specification is probably
the best way to make sure all configuration bits are set correctly for
your program.
As an example see the following list for a simple blink-a-LED program
with an 18F242.
<pre>
  pragma  target fuses 0  0b0000_0000       -- (n/a)
  pragma  target fuses 1  0b0010_0010       -- not switchable, HS osc, no PLL
  pragma  target fuses 2  0b0000_0001       -- BOR disabled, PWTR disabled
  pragma  target fuses 3  0b0000_0000       -- watchdog disabled
  pragma  target fuses 4  0b0000_0000       -- (n/a)
  pragma  target fuses 5  0b0000_0001       -- CCP2 on RC1
  pragma  target fuses 6  0b1000_0001       -- no bg debug, no LVP, STVREN
  pragma  target fuses 7  0b0000_0000       -- (n/a)
  pragma  target fuses 8  0b0000_1111       -- no code protection
  pragma  target fuses 9  0b1100_0000       -- no data protection
  pragma  target fuses 10 0b0000_1111       -- no code write protection
  pragma  target fuses 11 0b1110_0000       -- no other write protection
  pragma  target fuses 12 0b0000_1111       -- no table read protection
  pragma  target fuses 13 0b0100_0000       -- no boot block write protect
</pre>

<p>Notes:
<ol>
<li>All pragma statements must be specified after the include statement of
the device file.
<li>When a PIC has multiple configuration words or bytes the index value
of the word or byte must be specified before the value.
<li>The device file contains a fuses specification:
how many words/bytes and their corresponding memory addresses.
Also a default fuse setting is specified, which may or may not be
suitable for your application!
</ol>

<p>The meaning of configuration bits can in most cases be found in the
DataSheet of the specific chip, in the section 'Special Features of the
CPU'.
This info can certainly be found in the Programming Specifications of the chip.
For your convenience the MicroChip document numbers are mentioned in the
heading of the device files.

<hr>

<h2>Compiler requirements</h2>

<p>The compiler - at the moment of this writing version 2.4j - has a
number of requirements for device specifications.
The most important from a user perspective are the following:

<h3>Memory allocation</h3>
<p>The device files specify the amounts of available shared and unshared
memory (RAM, gpr) in bytes.
<p>For user program memory (variables, constants) the compiler allocates
memory first in unshared RAM then in shared RAM.
Some specific compiler 'internally' used bytes can be and should
be allocated in shared RAM for optimum performance.
<br>For the compiler 'shared' means: accessible in all banks.
Memory which is accessible in more than one bank but not in all
is declared as unshared RAM.
<p>Most PICS have both shared and unshared RAM and then there is no
issue, but some PICs have only shared memory while some others have no
shared memory at all.
This complication is solved in the device files as follows:
<ul>
<li>For PICs with <b>only shared</b> memory all memory is declared as
unshared, except for the compiler-required bytes.
Examples: 12F675, 16F676, 16F873A.
<li>For PICs with <b>only unshared</b> memory the compiler-required
bytes are declared in unshared memory (upper address limit)
Examples: 10Fs, 16f54, 16F74.
</ul>

<p>The compiler supports a maximum of 4 memory banks for baseline and
midrange PICs.
When a PIC has more memory banks the device file declares only 4 of
these, memory in the other banks is unusable.
Example: 16F59.


<h3>Analog modules</h3>
<p>(to be done)


<h2>Miscellaneous</h2>

<p>These device files are part of the central JalV2 repository 'Jallib'
(http://jallib.googlecode.com).
Other libraries of Jallib have been or are being converted to use the names
in these device files.
You are strongly recommended to use only this combination of include files.
Using these device files in combination with other libraries may cause
problems, especially with libraries for the old (pre JalV2) compiler.

<ul>

<p>Bank switching functions are not needed with JalV2 and do not appear in
the device files.
This may cause compile-time errors when using programs or libraries which
still use these procedures.
You must remove these bank switching functions from your programs and
libraries!

<li>The device specific include files are generated from the MPLAB .dev and
.lkr files.
This may cause confusion or even conflicts because the register and bit
names are not always identical to those in the datasheets!
Apart from that, MPLAB is not errorfree, consequently include files generated
from this source cannot be guaranteed to be errorfree either!

<li>The naming convention of ports and subfields maybe different, you may
have to convert the other libraries.

</body>
</html>
