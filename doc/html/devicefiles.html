<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Jallib Device Files Users Guide</title>
  <meta http-equiv="content-type" content="text/html; charset=US-ASCII">
  <meta name="author" content="Rob Hamerling">
  <meta name="description" content="Jallib Device File Users Guide">
  <meta name="copyright" content="Copyright (c) Rob Hamerling 2008..2010, All rights reserved">
  <meta name="project" content="This file is part of jallib  http://jallib.googlecode.com">
  <meta name="license" content="Released under the BSD license"
                             "http://www.opensource.org/licenses/bsd-license.php">
  <meta name="compiler" content="2.4n">
  <link rel="stylesheet" href="jallib.css" type="text/css">
</head>
<body lang="en-US" dir="LTR">

<h1>Jallib Device Files Users Guide</h1>
<p><center>by Rob Hamerling</center>

<h2>Table of contents</h2>
<ol>
<li><a href="#intro">Introduction</a>
<li><a href="#overall">The Overall Picture</a>
  <ul>
  <li><a href="#device_files">Device files</a>
  <li><a href="#chipdef_jallib">Common include file Chipdef_Jallib</a>
  <li><a href="#function_includes">Function include files</a>
  </ul>
<li><a href="#user">User Information</a>
  <ul>
  <li><a href="#sample_program">Sample Program</a>
  <li><a href="#ports_and_pins">Naming conventions for ports and pins</a>
     <ul>
     <li><a href="#portregs">PORTx and pins, TRISx and pin directions</a>
     <li><a href="#gpioregs">GPIO and TRISIO</a>
     <li><a href="#nibbles">Nibbles</a>
     <li><a href="#aliases">Alias names</a>
     <li><a href="#nmmregs">Non-memory-mapped registers</a>
     </ul>
  <li><a href="#peripherals">Names for function modules and peripherals</a>
     <ul>
     <li><a href="#MSSPregs">MSSP</a>
     <li><a href="#CCPregs">CCP</a>
     <li><a href="#ANSELregs">ANSEL</a>
     <li><a href="#ADCregs">ADC</a>
     <li><a href="#EUSARTregs">[E]USART</a>
     <li><a href="#multi_modules">Multiple SPI or I2C modules</a>
     <li><a href="#TIMERregs">Timers</a>
     <li><a href="#RTCCregs">RTCC</a>
     <li><a href="Status_Shadow">Shadow STATUS</a>
     <li><a href="#miscregs">Miscellaneous</a>
     </ul>
  <li><a href="#shadowing">About port shadowing</a>
  <li><a href="#osccal">About OSCCAL</a>
  <li><a href="#usbprov">Provisions for USB</a>
  <li><a href="#ppsgroup">Peripheral Pin Selection</a>
  <li><a href="#fuses">Naming convention for configuration bit fields (fuses)</a>
  <li><a href="#compiler">Compiler requirements</a>
  </ul>
<li><a href="#gen">Generating device files</a>
</eol>

<h1><a name="intro">1. Introduction</a></h1>

<p>The Jallib device files are generated by means of a Rexx script 'dev2jal'.
Its name is an abbreviation of 'MPLAB .dev to .jal' because it uses the .dev
files of the MPLAB-IDE to create the Jallib device files.
<br>Notes:
<ul>
<li>The .lkr files of the MPASM component of MPLAB are used too!
<li>Rexx is an interpreted language, see for example:
http://www.rexxinfo.org/ and
http://en.wikipedia.org/wiki/REXX
</ul>

<p>The advantages of automated generation of device files are pretty
obvious, such as:
<ul>
<li>creation of device files for all PICmicros available in MPLAB
<li>automatic new device files for new chips
<li>no manual maintenance of device files
<li>consistent layout
<li>consistent naming convention
<li>no errors due to typos with manual editing
</ul>

<p>The advantages of a consistent naming convention are also obvious:
<ul>
<li>Easy migration of a program from one target PICmicro to another.
<li>Same for libraries using this naming convention.
</ul>

<p>This document gives some design information and some instructions for the
use of these JalV2 device files.
The sources of information are the xxxx.dev files and xxxx.lkr of MPLAB,
supplemented and corrected with information from the datasheets.

<hr>
<h1><a name="overall">2. The Overall Picture</a></h1>

<p>With the design of the device files I had in mind a structure as shown
below.
<pre>
                   +----------+   +------------------+
                   | device   |   |     general      |
                   | specific |---|     include      |
                   | include  |   |chipdef_jallib.jal|
                   +----------+   +------------------+
                        |
         +--------------+--------------+-------------+-----------
         |              |              |             |
   +----------+   +----------+   +----------+   +----------+
   | function |   | function |   | function |   | function |
   | include  |   | include  |   | include  |   | include  |   etc
   | 'delay'  |   |  'jal'   |   |'adc.....'|   |'pwm....' |
   +----------+   +----------+   +----------+   +----------+
</pre>

<p>These device files are now part of the central JalV2 library
repository <a href="http://jallib.googlecode.com/">Jallib</a> at
<b>GoogleCode</b>, which uses the same structure.


<h2><a name="device_files">Device Files</a></h2>

<p>The device files are the base for other include files and contain:
<ul>
<li>An include statement for the common include file 'chipdef_jallib'
<li>CPU type specification (12-, 14-, extended 14-, or 16-bits core).
<li>Program memory size specification.
<li>Data memory (EEPROM) location and size specification.
<li>Configuration (fuses) and ID memory specification.
<li>Default fuse settings.
<li>Specification of General Purpose Register (GPR, RAM) location range and
sharing.
<li>Declaration of Special Function Register (SFR) address and mirror adresses,
alias names and bit naming.
<li>Declaration of procedures and functions for shadowing of I/O ports.
<li>Declaration of symbolic names for configuration bits (fuses).
<li>Procedures to switch the ports to digital I/O.
</ul>

<p>Including a device file doesn't change anything to the PIC.
For example pins which are input after power-on or reset remain input,
etc.
Required changes are the responsibility of the application program or
function libraries.
<br>For user convenience every device file contains a procedure to
disable all analog modules of the PIC and to change all pins which are
by default analog to digital I/O: enable_digital_io().
This procedure calls on its turn a procedure to disable ADC modules,
Comparator modules and a procedure to set analog pins to digital,
all when applicable to the specific PIC.

<p>The device file contains also a set of configuration bits settings
with default values,
which may be different than the specifications in the datasheet!
<b>Never trust defaults!</b>
Always specify the way you want the configuration bits set.

<h2><a name="chipdef_jallib">Common Include File 'chipdef_jallib.jal'</a></h2>

<p>The file 'chipdef_jallib.jal' which comes with these device files
replaces the file 'chipdef.jal' which comes with the compiler distribution.
It is included by every device file and contains:
<ul>
<li>Constants required by the compiler.
<li>Commonly used constants by the device files and other libraries.
</ul>

<p>With the statement 'pragma target chip = .....' in every device file the
compiler assigns a unique value to the constant 'target_chip'.
The program may reference this variable with a symbolic name.
This symbolic name consists of 'pic_' followed by the type of the PIC,
which makes it possible to use the same source file to generate a hex file
for different types of PICs, as the following example shows:

<pre>
   include 16f88

   if (target_chip == PIC_16F88) then          -- (not for 16f87)

     ....                                      -- 16F88 unique code

   end if
</pre>

<p>By changing the include statement to 16f87 (or any other) the statements
between 'if' and 'end if' will be skipped by the compiler.

<p>The list of targets in chipdef_jallib.jal makes sure that every possible
target name and the corresponding value of target_chip is known by the
compiler.

<p>Note: The original chipdef.jal file of the compiler package specifies
a different value for 'target_chip' and not for all PIC types.
Therefore it had to be replaced when using this set of device files.


<h2><a name="function_includes">Function Include Files</a></h2>

<p>Function specific include files offer facilities to ease the use of
PIC peripherals (such as USART, ADC), external devices (such as LCDs,
sensors), or extensions to the Jal language such as for data
formatting, mathematical functions, etc.

<p>Function specific include files should be included explicitly as
required by the application program, this is not done by the device files.

<p>In most cases the function include files require some statements to
couple function specific registers and pins with the device.
Read the comments in the library sources and the library documentation
for instructions.
Most libraries contain comments with user instructions in the header of
include files and just ahead of the procedures and functions in these files.


<hr>

<h1><a name="user">3. User Information</a></h1>

<p>We'll start with a very elementary sample program (blink-a-led) to show
how device files make programming in JAL a piece of cake,
followed by a description of other features of the device files which are
aimed at writing device independent libraries.

<h2><a name="sample_program">Sample program</a></h2>

<p>The device files define static device (PICmicro) specific matter.
This allows writing elementary programs, such as for a blinking led, which
are almost device independent.
Differences are mostly in the fuse settings.

<p>The device files are also the base for extensions, such as
libraries for more complicated functions like displaying text on an LCD
display or handling analog devices.

<p>Below a simple blink-a-led program (led on pin 1 of port A) for a
PIC16F886 using a 20 MHz resonator.
In addition to the device-specific information obtained from the include
file '16f886.jal' some run-time information is needed, like the speed and
type of the oscillator and some other 'environmental' variables.
No extra function libraries are required.

<pre>
-- ------ blink-a-led on pin_A1 of a PIC16F886 --------

   include 16f886                        -- target is a PIC16F886
                                         -- Notes: - The extension .jal is
                                         --          added by the compiler!
                                         --        - No other includes needed.

   pragma target clock  20_000_000       -- oscillator frequency (in Hz)
                                         -- required for delays

   pragma target OSC    HS               -- high speed external oscillator
   pragma target WDT    Disabled         -- watchdog off
   pragma target MCLR   External         -- external chip reset
   pragma target LVP    Disabled         -- no low voltage programming

   enable_digital_io()                   -- set all pins to digital I/O

   alias  led           is pin_A1        -- declare alias for pin_A1
   alias  led_direction is pin_A1_direction   -- and for its direction

   led_direction = output                -- make led-pin output
   forever loop                          -- endless loop
      led = on                           -- there is light!
      _usec_delay(250000)                -- spin 1/4 seconds
      led = off                          -- flip (on-&gt;off,off-&gt;on)
      _usec_delay(250000)                -- spin 1/4 seconds
   end loop

</pre>
When loaded in a 16F886 with 20 MHz resonator or crystal a led connected
(with series resistor!) to pin 3 (RA1) should blink twice a second.

<h2><a name="ports_and_pins">Naming conventions for Ports and Pins</a></h2>

<p>Unfortunately MPLAB of Microchip is not particularly consistent in
its choice of names!
The datasheets and the various informational files in MPLAB not
infrequently use different names for the same entity!
As a rule the device files use the names as used by the datasheets.
However the device files have been generated from the MPLAB information
files, not from the datasheets!
So it is possible that some names may not be conform to the datasheet.
When you find such a deviation not mentioned in this document, please
report to the Jallib team, and most likely the next release will contain
the corrected name.

<p>For all registers of the chip a name is declared and where appropriate
also the individual bits or groups of bits are declared.
<br>Subfields of registers have the name of the register as prefix, like
<pre>
   var volatile bit  INTCON_GIE  at INTCON : 7
</pre>
Some aliases are declared for easy migration or conversion of
existing JalV2 libraries and programs to the Jallib environment.

<p>There are exceptions to the rules above.
<br>The aim of 'normalization' (using a consistent naming) is:
<ol>
<li>to be able to use all libraries for all types of PICmicros
<li>to ease the migration of programs to other types of PICs.
</ol>

<h3><a name="portregs">PORTx and pins, TRISx and pin directions</a></h3>
<p>For all ports and port pins a device independent alias is declared and a
similar direction declaration, as the following examples show:
<pre>
   var  volatile  byte  PORTA  at  &lt;addr&gt;
   var  volatile  byte  TRISA  at  &lt;addr&gt;
   var  volatile  byte  PORTA_direction at TRISA
   var  volatile  bit   pin_A0  at  PORTA : 0
   var  volatile  bit   pin_A0_direction at TRISA : 0
</pre>
etc. (for all other existing pins and ports).


<h3><a name="gpioregs">GPIO and TRISIO (with the smaller chips)</a></h3>
<p>Although the smaller PICs have no 'official' PORTA and TRISA registers,
the device files contain aliases for these.
So even with the smaller PICs you can use the names PORTA, pin_A0, etc.
<pre>
   var  volatile  byte  GPIO   at  &lt;addr&gt;
   var  volatile  byte  PORTA  at  GPIO
   var  volatile  byte  TRISIO  at &lt;addr&gt;
   var  volatile  byte  TRISA  at  TRISIO
   var  volatile  byte  PORTA_direction at TRISIO
   var  volatile  bit   pin_A0  at  GPIO : 0
   var  volatile  bit   pin_A0_direction at TRISIO : 0
</pre>
etc. (for all other existing pins)
<p>Pins which can be input-only may have no corresponding _direction
variable, for example pin_E3 of the 18F4550.


<h3><a name="nibbles">Nibbles</a></h3>
<p>Because the upper and lower 4 bits ('nibble') of a port are
used frequently as a unit, these are declared as pseudo variables.
<pre>
   PORTx_low               - bits 0..3    (low order bits)
   PORTx_high              - bits 4..7    (high order bits)
   PORTx_low_direction
   PORTx_high_direction
</pre>
This allows nibbles to be used as a regular variables,
and can also be used to set pin directions by 4 at a time:
<pre>
   PORTA_high = "7"                  -- low nibble remains unchanged
   PORTA_low_direction = all_output  -- direction upper nibble unchanged
</pre>
Several function libraries in the Jallib collection use this facility.
<P>Note: Nibbles are always declared even if the register doesn't have the
nibble fully populated, or even not populated at all!


<h3><a name="aliases">Alias names</a></h3>
<p>When a pin is multiplexed (has a different function depending on
control registers or configuration bit settings), aliases are declared
to make the pin accessible by a more functional name.
For example: of the 16F88 pin_B6 is usable as analog input for the ADC
module as channel 5 and therefore pin_B6 has been given an alias name
pin_AN5.
You can find the 'AN5' name with the pin layout pictures and tables in the
datasheet.
<br>Of course also for the pin_B6_direction an alias is declared and
called similarly pin_AN5_direction!
<br>Libraries (for this example the ADC library) will use the alias
names in stead of the physical pin names.
Another PIC may have pin_AN5 associated with a different physical pin,
but by using the alias name the ADC library becomes indenpent of the
physical pin configuration
and and makes it to a large extent device independent.

<p>If you want to use another name for a port, nibble or individual pin
you can also specify an alias in your program.
For example when you have a red led connected to pin 0 of PortA, you could
specify:
<pre>
   alias led_red  is  pin_A0
</pre>
and use 'led_red = on' or 'led_red = off' assignments in your program.
<p>Pin aliases in the device files are declared in this
way and therefore also make use of the port shadowing provided by
the device files.
<br<i>This way of aliasing - using the keyword 'alias' - is only
available since JalV2 compiler version 2.4n.</i>

<p>You should <b>avoid direct pin and I/O port manipulation</b>, because
it will be overruled by the automatic shadowing mechanism
(see the chapter about <A href="#ch_shadowing">Shadowing</a>).
For example do <b>not</b> specify:
<pre>
   var bit led_red at portA : 0
</pre>
With this specification a 'led-red = on' will have the desired result, but
it will not update the shadow register.
Any next operation which uses the shadowing mechanism will override the
previous direct control operation.

<p>Some pin alias names are not acceptable for the JalV2 compiler, in
which case a special name is used.
For example PICs with USB support have a D+ and D- pin.
These are declared (for the 18F4550) as:
<pre>
   alias  pin_D_POS     is  pin_C5
   alias  pin_D_NEG     is  pin_C4
</pre>

<p>Some function pins can be on one or another pin of a PIC,
controlled by a register or a configuration bit setting.
In these cases the name has to be suffixed to prevent duplicate names.
For example the 16F737 can have the CCP2 bit on pin_B3 or pin_C1,
controlled by a configuration bit (fuse_def CCP2MUX).
<pre>
   alias  pin_CCP2_RB3  is  pin_B3
   alias  pin_CCP2_RC1  is  pin_C1
</pre>
The program or library has to detect the actual use of the CCP2 pin.

<p>Some high end 18Fs have an even more complex multiplexing mode.
With the 18F8310 for example the multiplexing depends also on the
processor mode.
One position of CCP2 is pin_C1, the alternate pin is pin_E7
(in Microcontroller mode) or pin_B3 (in Microprocessor,
Extended Microcontroller and Microcontroller with Boot Block modes).
This variant is not always available in the current device files!


<h3><a name="nmmregs">Non-memory-mapped registers</a></h3>
<p>Some PICs, mainly in the baseline series are missing some addressable
('memory mapped') Special Function Registers (SFRs).
For example the 12-bit core PICs (10Fs, 12F5x, etc) have no memory
mapped TRISx registers, in stead these PICs have a TRISx instruction to
set the direction of ports or pins.
This would make it impossible for function libraries and application
programs to use statements like:
<pre>
   PORTA_direction = all_output
</pre>
To make this possible the device files contain pseudo variables which mimic
the existence of memory mapped registers.
<p>For example even though a 16F509 has no addressable TRISA register,
you can still specify:
<pre>
   pin_A5_direction = output
</pre>
to make pin_A5 (alias of pin_GP5) an output pin.

<p>Some PICs of the 18F series have SFRs which are only accessible when
the ADSHR bit in WDTCON is set (when not set a different SFR is accessed).
For example with the 18F65J50 ADCON0 and ANCON1 share address FC2h.
When the ADSHR bit of WDTCON is reset (0) ADCON0 is accessed,
when the ADSHR bit is set (1) ANCON1 is accessed.
<br>The device files will do this automatically with the help of pseudo
variables.
For example when ANCON1 is used in a JALV2 statement the ADSHR bit is set
automatically (and reset afterwards).


<h2><a name="peripherals">Names of functions modules</a></h2>

<h3><a name="MSSPregs">Names of MSSP registers</a></h3>
<p>Names of registers of MSSP modules have been normalized as follows:
<ul>
<li>MSSP module of midrange PICs
<pre>
   SSPADD
   SSPBUF
   SSPCON    -- first or only control register
   SSPCON2   -- second control register (if present)
   SSPSTAT
</pre>
<li>First or only MSSP module of 18F and extended midrange family:
<pre>
   SSP1ADD
   SSP1BUF
   SSP1CON or SSP1CON1  -- first or only control register
   SSP1CON2             -- second control register
   SSP1CON3             -- third control register
   SSP1MASK
   SSP1STAT
</pre>
<li>Second MSSP module of 18F and extended midrange family
<pre>
   SSP2ADD
   SSP2BUF
   SSP2CON or SSP2CON1  -- control register second module
   SSP2CON2             -- second control register
   SSP2CON3             -- third control register
   SSP2STAT
</pre>
</ul>
<p>This naming convention has been chosen because of the differences
between the midrange and 18F series.

<p>In many cases the first SSP module (SSP1) of the 18Fs and extended
midrange PICS can be used in the same way as the SSP module of a
midrange PIC.
For this purpose the following aliases are declared for registers and
their subfields of the first SSP module in the relevant device files:
<table>
<tr><th>field                <th>alias         <th>remarks </tr>
<tr><td>SSP1CON or SSP1CON1  <td>SSPCON        <td> </tr>
<tr><td>SSP1CON2             <td>SSPCON2       <td>when present</tr>
<tr><td>SSP1CON3             <td>SSPCON3       <td>when present</tr>
<tr><td>SSP1STAT             <td>SSPSTAT       <td> </tr>
<tr><td>SSP1BUF              <td>SSPBUF        <td> </tr>
<tr><td>SSP1MSK              <td>SSPMSK        <td>when present</tr>
</table>
<p>All subfields of these registers have a similar alias
(the register prefix is changed, the subfield name kept asis).
<p>In addition some related subfields have an alias, like:
<table>
<pre>
<tr><th>field                <th>alias         <th>remarks </tr>
<tr><td>PIE1_SSP1IE          <td>PIE1_SSPIE    <td> </tr>
<tr><td>PIR1_SSP1IF          <td>PIR1_SSPIF    <td> </tr>
</pre>
</table>


<h3><a name="CCPregs">Names for registers and subfields of CCP modules</a></h3>
<p>There are CCP modules and Enhanced CCP modules.
The first is also called 'legacy' CPP modules in this document and elsewhere.
Most legacy CCP modules have registers names starting with CCP,
most registers of enhanced CCP modules start with ECCP.
The same is true for subfields of these registers.
However there are many deviations from these rules and contradictions
between MPLAB .dev files and the datasheets!

<p>Enhanced CCP modules can be used as legacy CCP modules,
in particular for PWM operations.
For this purpose a number aliases are added to the device files which
allow access of enhanced CCP registers and subfields with legacy names.
An example of this is the pwm_hardware library.
<p>The following aliases for enhanced CCP modules are declared:
<table>
<tr><th>field           <th>alias         <th>remarks          </tr>
<tr><td>ECCPxCON        <td>CCPxCON       <td>x in range 1..10 </tr>
<tr><td>ECCPxCON_EDCxB  <td>CCPxCON_DCxB  <td>bits*2           </tr>
<tr><td>ECCPxCON_ECCPxM <td>CCPxCON_CCPxM <td>bits*4           </tr>
<tr><td>ECCPRx          <td>CCPRx         <td>                 </tr>
<tr><td>ECCPRxH         <td>CCPRxH        <td>                 </tr>
<tr><td>ECCPRxL         <td>CCPRxL        <td>                 </tr>
</table>
<p>Extended midrange PICs (12/16F18/19xx) have only enhanced CCP modules
which have 'legacy' names.
Therefore no special naming is needed to use these as legacy CCP modules.
<p>For PICs with both an CCP1CON and a ECCP1CON register
(18f448,4480,458,4580,4585,4680,4682,4685)
to allow the enhanced CCP module to be used as second legacy CCP module
the following aliases are declared:
<table>
<tr><th>field           <th>alias         <th>remarks          </tr>
<tr><td>ECCP1CON        <td>CCP2CON       <td>                 </tr>
<tr><td>ECCP1CON_EDC1B  <td>CCP2CON_DC2B  <td>                 </tr>
<tr><td>ECCP1CON_ECCP1M <td>CCP2CON_CCP2M <td>                 </tr>
<tr><td>ECCPR1          <td>CCPR2         <td>                 </tr>
<tr><td>ECCPR1H         <td>CCPR2H        <td>                 </tr>
<tr><td>ECCPR1L         <td>CCPR2L        <td>                 </tr>
</table>
<br>Corresponding pins when called ECCP1 have an alias CCP1.

<p>Some PICs (16F91x,946, 18F2321,2480,2580,4321,4480,4580) have the
CCPxCON 2-bits subfield DCxB defined as 2 separate bits CCPxX and CCPxY,
other PICs (16F88x) have this field enumerated and defined as
DCxB1 and DCxB0.
For compatibility with most other PICs a 2 bits field CCPxCON_DCxB has
been added in the device files for these cases.


<h3><a name="ANSELregs">Names of ANSEL bits</a></h3>
<p>For the control of the ADC channel the ADC library has to set the
appropriate pin(s) to analog (input).
There are generally 3 methods used by the different PICs:
<ul>
<li>with the PCFG field of the ADCON1 register
<li>with the PCFG bits in ANCONx registers
<li>with bits of the ANSELx register(s)
</ul>
<p>The first two methods as covered by the ADC libraries,
this section is about the third method with ANSEL register(s).
There are a couple of issues with this method:
<ul>
<li>Pins with analog capability are not evenly and sequentially distributed
over the ports.
Sometimes channel numbers are not present and the numbering in the PORT
register is sometimes 'chaotic'.
<li>There is no direct relation between the number of the analog channel
(pin_ANx, x in the range 0..28) and the bit in the ANSEL register with which
the channel is controlled.
And the ANSEL registers are not uniformly named (e.g. the first register can
be ANSEL, ANSEL0, ANSELA, the second can be ANSELH, ANSEL1, ANSELB, etc.).
</ul>
<p>The first item is no problem when always referring to the logical pin
name pin_ANx (an alias of the physical pin name).
A solution for the second item has been found by declaring aliases for the
channel selection bits in ANSEL registers (name normalization).
In stead of enumerating the bits of all ANSELx registers individually, a
number of bit aliases 'JANSEL_ANSx' is declared, in which 'x' represents
the ADC channel and which point to the appropriate AN-pin.
<br>For example the declaration of the JANSEL bits of a 16F722 looks like:
<pre>
   var volatile byte   ANSELA           at  { 0x185 }
   var volatile bit    JANSEL_ANS4      at  ANSELA : 5     -- pin_AN4 = pin_A5
   var volatile bit    JANSEL_ANS3      at  ANSELA : 3     -- pin_AN3 = pin_A3
   var volatile bit    JANSEL_ANS2      at  ANSELA : 2     -- pin_AN2 = pin_A2
   var volatile bit    JANSEL_ANS1      at  ANSELA : 1     -- pin_AN1 = pin_A1
   var volatile bit    JANSEL_ANS0      at  ANSELA : 0     -- pin_AN0 = pin_A0
   -- -------------------------------------------------
   var volatile byte   ANSELB           at  { 0x186 }
   var volatile bit    JANSEL_ANS13     at  ANSELB : 5     -- pin_AN13 = pin_B5
   var volatile bit    JANSEL_ANS11     at  ANSELB : 4     -- pin_AN11 = pin_B4
   var volatile bit    JANSEL_ANS9      at  ANSELB : 3     -- pin_AN9  = pin_B3
   var volatile bit    JANSEL_ANS8      at  ANSELB : 2     -- pin_AN8  = pin_B2
   var volatile bit    JANSEL_ANS10     at  ANSELB : 1     -- pin_AN10 = pin_B1
   var volatile bit    JANSEL_ANS12     at  ANSELB : 0     -- pin_AN12 = pin_B0
</pre>
As you can see the JANSEL_ANSx numbering is not restricted to bits 0..7
of the first ANSEL register (whatever its name),
it is also used for channel numbers higher than 7 controlled by another
ANSEL register.
Note further that:
<ul>
<li>channels 0..3 are regularly sequenced on pin_A0..3
<li>channel 4 is on pin_A5 (pin_A4 is not an ADC pin)
<li>channels 5..7 are missing
<li>channels 8..13 are <b>ir</b>regularly sequenced on pin_B0..5
</ul>
<p>Other PICs, like for example the 18F43K22, have 28 ADC channels spread
over 5 ANSEL registers, also largely irregularly numbered.
For example pin_AN5..7 are controlled by ANSELE.
The declaration of JANSEL_ANS0..27 hides all these irregularities from the
ADC library.
<p>Another example, now for the 10F222:
<pre>
   var volatile byte   ADCON0           at  { 0x7 }
   var volatile bit    JANSEL_ANS1      at  ADCON0 : 7
   var volatile bit    JANSEL_ANS0      at  ADCON0 : 6
</pre>
In this case the channel selection bits are in register ADCON0
(the 10Fs have no ANSEL register), but the ADC library doesn't need
to know when it uses the JANSEL_ANSx alias.
<br><i>Note: in reality the channel selection of the 10F220/222 is
somewhat more complicated, but the ADC library takes care of that!</i>.


<h3><a name="ADCregs">Names of other ADC registers and subfields</a></h3>
<p>Names of registers and subfields of ADC modules have been normalized as follows:

<p>When the ADCONx_VCFG subfield is a multi-bit field it is declared
both as a multi-bit field ADCONx_VCFG and as enumerated bits
(ADCONx_VCFG0 and ADCONx_VCFG1).
Same for ADCONx_PVCFG and ADCONx_NVCFG.

<p>While most PICS with more than 8 ADC channels have a 4-bits subfield
ADCONx_CHS, some PICs have the channel selection bits scattered over
more than 1 subfield.
For example the 16F7x7s have a 3-bits CHS field plus a single CHS3 bit
to be able to support channel 8 and up.
In this and similar cases a pseudo variable ADCONx_CHS has been declared
which takes care of the scattering of channel selection bits.
So an ADC library can always address the variable ADCONx_CHS as multibit
'binary' field, regardless if the bits are scattered over the register or not.

<p>A similar situation exists for the ADCS bits of ADCONx of some PICs.
For PICs which have their ADCS bits scattered over ADCON0 and ADCON1 a
pseudo-variable ADCON0_ADCS is added which takes care of setting the
proper bits.
In this way an ADC library can always address the variable ADCONx_ADCS as
single multibit field, regardless if the bits are scattered over registers
or not and regardless if it is a bit*2 or a bit*3 variable.

<h3><a name="EUSARTregs">Names of registers and subfields of [E]USART modules</a></h3>
<p>PICs can have zero, one or two USART modules, of which zero, one or both
can be 'extended' (EUSART) modules.
Compared to a 'legacy' USART an 'extended' USART has a BAUDCON
register and can use a 16 bits in stead of an 8-bits value for the
baudrate divisor,
allowing a more accurate baudrate setting, especially at high speeds.
<p>The names of USART related registers and -subfields are not particular
constent in the MPLAB .dev files, so it is desired to normalize these.
And it would be convenient if serial libraries supporting a single serial
interface could be used one of both USARTs of PICs with two USARTs.
These are the primary reasons for the following naming convention in the
Jallib device files:
<ul>
<li>for PICs with 1 USART:
  <ul>
  <li>no suffix
  </ul>
<li>for PICS with 2 USARTs:
  <ul>
  <li>first USART: suffix '1' and an alias without suffix
  <li>second USART: suffix '2'
  </ul>
</ul>
<p>Application of these rules results in the following list of names:
<table>
<tr><th>single USART <th>first of 2 USARTs               <th>second of 2 USARTs</tr>
<tr><td>BAUDCON      <td>BAUDCON1<br>BAUDCON (alias)     <td>BAUDCON2   </tr>
<tr><td>BAUDCTL      <td>BAUDCTL1<br>BAUDCTL (alias)     <td>BAUDCTL2   </tr>
<tr><td>RCREG        <td>RCREG1<br>RCREG (alias)         <td>RCREG2     </tr>
<tr><td>RCSTA        <td>RCSTA1<br>RCSTA (alias)         <td>RCSTA2     </tr>
<tr><td>SPBRG        <td>SPBRG1<br>SPBRG (alias)         <td>SPBRG2     </tr>
<tr><td>SPBRGH       <td>SPBRGH1<br>SPBRGH (alias)       <td>SPBRGH2    </tr>
<tr><td>TXREG        <td>TXREG1<br>TXREG (alias)         <td>TXREG2     </tr>
<tr><td>TXSTA        <td>TXSTA1<br>TXSTA (alias)         <td>TXSTA2     </tr>
<tr><td>PIE1_RCIE    <td>PIE1_RC1IE<br>PIE1_RCIE (alias) <td>PIE3_RC2IE </tr>
<tr><td>PIE1_TXIE    <td>PIE1_TX1IE<br>PIE1_TXIE (alias) <td>PIE3_TX2IE </tr>
<tr><td>PIR1_RCIF    <td>PIR1_RC1IF<br>PIR1_RCIF (alias) <td>PIR3_RC2IF </tr>
<tr><td>PIR1_TXIF    <td>PIR1_TX1IF<br>PIR1_TXIF (alias) <td>PIR3_TX2IF </tr>
</table>
<p>Notes:
<ul compact>
<li>BAUDCON and SPBGRH registers are only available with extended USARTs.
<li>Some PICs with ESUART have a BAUDCTL register in stead of BAUDCON.
In that case the device files have an additional alias: BAUDCON,
and the bit fields of BAUDCTL have a BAUDCON alias too.
<li>The original name and the alias might appear exchanged.
</ul>
<p>With these names serial libaries or application programs supporting only
a single serial interface can use the register and field names without
suffix for the only USART or the first of two USARTs.
Libraries supporting two serial interfaces will preferrably use the
qualified names (with suffix).


<h3><a name="multi_modules">Multiple SPI or I2C Modules</a></h3>
<p>Like multiple USARTs PICs can have other multiple peripheral modules
like SPI and I2C.
With multiple modules of the same type the related pins have names with
a suffix ('1' or '2'), while with a single module the pin names have no
suffix.
Currently the libraries for SPI and I2C support only a single module and
use pin names without suffix.
To make it possible to use these libraries for the first of both modules
the related pins with suffix '1' have been given an extra alias name
without suffix.
<ul>
<li>For PICS with 2 SPI modules:
  <pre>
  alias pin_SDI           is &lt;pin_SDI1&gt;
  alias pin_SDO           is &lt;pin_SDO1&gt;
  alias pin_SCK           is &lt;pin_SCK1&gt;
  alias pin_SS            is &lt;pin_SS1&gt;
  alias pin_SDI_direction is &lt;pin_SDI1_direction&gt;
  alias pin_SDO_direction is &lt;pin_SDO1_direction&gt;
  alias pin_SCK_direction is &lt;pin_SCK1_direction&gt;
  alias pin_SS_direction  is &lt;pin_SS1_direction&gt;
  </pre>
<li>For PICS with 2 I2C modules:
  <pre>
  alias pin_SDA           is &lt;pin_SDA1&gt;
  alias pin_SCL           is &lt;pin_SCL1&gt;
  alias pin_SDA_direction is &lt;pin_SDA1_direction&gt;
  alias pin_SCL_direction is &lt;pin_SCL1_direction&gt;
  </pre>
</ul>
Note: In the device files the extra aliases refer to the original 'real'
pins (are not aliases of an aliases), hence the notation
&lt;pin_xxxx&gt; above!
For example a device file might contain:
<pre>
  alias      pin_SDI1       is pin_C4
  alias      pin_SDI        is pin_C4
</pre>
and similar definitions for the other pins.


<h3><a name="TIMERregs">Names of Timer fields</a></h3>
<p>Some register subfields of timer control registers have inconsistent
names in the MPLAB .dev files.
<p>For these subfields the following naming convention has been chosen:
<ul>
<li>The interrupt bits of Timer 0 are declared as TMR0IE and TMR0IF
    for <b>all</b> PICs, even though some datasheets use the names
    T0IE and T0IF.
<li>Bit TxSYNC in TxCON registers is normalized to NTxSYNC for:
  <ul>
  <li>T1CON of baseline and midrange
  <li>T1CON, T3CON, T5CON and T7CON of 18F series.
  </ul>
<li>TxCON_TOUTPS is normalized to TxCON_TxOUTPS (x = timer number) for
    the 18Fs.
    Since the midrange PICs have only 1 timer with TOUTPS bit this name
    has been maintained for these PICs.
    Extended midrange PICs have T2CON, T4CON and T6CON and
    follow the same naming convention.
<li>A variable 'bit*4 PS' in T0CON is splitted in 'bit PSA' and 'bit*3 PS'
<li>Aliases are provided for Timer 0 related fields in OPTION_REG
    of baseline and midrange PICS to simulate the existence of a T0CON
    register - like there are T0CON, T1CON, T2CON, etc. registers
    with other PICs: T0CON_T0SE, T0CON_T0CS, T0CON_PSA and T0CON_T0PS.
<li>The extended midrange PICs have in OPTION_REG the bits TMR0CS1 and
    TMR0CS0 and a 2-bits prescaler TMR0PS.
    These have been given aliases bit*2 T0CON_T0CS and bit*2 T0CON_T0PS
    to be as much compatible as possible with the other midrange PICs.
</ul>


<h3><a name="RTCCregs">Names of RTCC registers</a></h3>
<p>For consistency with the ALRMCFG register and since the RTCPTR1 - and
RTCPTR0 bits of the RTCCFG register could be used as 2-bits binary field -
an additional field is declared:
<pre>
  var volatile  bit*2  RTCCFG_RTCPTR     at RTCCFG : 0
</pre>
Same for the RTSECSEL1 and RTSECSEL0 bits of PADCFG1:
<pre>
  var volatile  bit*2  PADCFG1_RTSECSEL  at PADCFG1 : 1
</pre>
For consistency the 2-bits ALRMCFG_ALRMPRT field has been enumerated:
<pre>
  var volatile  bit    ALRMCFG_ALRMPTR1  at ALRMCFG : 1
  var volatile  bit    ALRMCFG_ALRMPTR0  at ALRMCFG : 0
</pre>


<h3><a name="Status_Shadow">Subfields of STATUS_SHAD</a></h3>
<p>The shadow of the STATUS register (in the extended midrange PICs)
has its bits named like in the STATUS register:
<pre>
  STATUS_SHAD_Z
  STATUS_SHAD_DC
  STATUS_SHAD_C
</pre>


<h3><a name="miscregs">Miscellaneous remarks about names</a></h3>
<ul>
<li>The name PORTA (and a similar name for other ports) is used
    consistently, while previously PORT_A was a popular naming
    convention especially for PORT_A_low, PORT_A_high,
    PORT_A_direction, etc.
<li>For individual pins the convention 'pin_Ax' is used.
<li>Numerous minor naming inconsistences in the MPLAB .dev files
    are 'corrected'.
</ul>
When you hit compilation errors related to undefined names, scan the
device file of the specified target PIC to search for the Jallib name
of the registers and their subfields.


<h2><a name="shadowing">About Port Shadowing</a></h2>

<p>Port shadowing is a technique to prevent the Read-Modify-Write
('RMW') problem with I/O ports of PICmicro's.
This is a problem related to its hardware design.
Search the Internet for "PIC" and "read-modify-read" and you'll get many
hits to more or less interesting articles!
None of the explanations are repeated here.
And you don't absolutely need to understand the problem, since by using
the Jallib device files you won't face the problem when you follow some
simple rules and avoid a few pitfalls.

<p>With port shadowing for the baseline and midrange PICs
(10F, 12F, 16F) a RAM location is used as replacement for the port for
output.
<p>The 18F series have a special register for this purpose (LATx).
Although the techniques are slightly different, the general rules are:
reading is done from the port directly while writing is done to the
shadow register of which the contents is subsequently passed to the
real port.

<p>With the Jallib device files shadowing is automatic, as long
as you use the following names:
<pre>
   PORTx          -- all bits of port x
   PORTx_low      -- low order nibble of port x (bits 3..0)
   PORTx_high     -- high order nibble of port x (bits 7..4)
   pin_xy         -- single bit 'y' of port 'x'
</pre>
(in which 'x' is a port-letter and 'y' a bit number).
<p>Note: The value for both Portx_low and Portx_high is passed with
reading from (and must be passed with writing to) in the lower nibble
(bits 3..0) of a constant or variable.
Portx_low is read from or written to bits 3..0 of Portx,
Portx_high is read from or written to bits 7..4 of Portx.

<h2><a name="osccal">About OSCCAL</a></h2>

<p>A number of low end PICS have a reserved word in high memory, provided by
the manufacturer, which contains information for calibration of the internal
oscillator.
When your PIC application needs the frequency of the internal oscillator to
be accurate the OSCCAL register should be loaded with the provided value.
This is not done automatically by compiler or device files.
You may want to insert the following statements into the beginning of your
program:
<pre>
  assembler
    page call &lt;end-of-memory&gt;
    bank movwf OSCCAL
  end assembler
</pre>
in which you have to specify for &lt;end-of-memory&gt; the offset of the highest
program memory word.
For example when your PIC has 1K words of program memory you should specify:
<pre>
  page call 0x3FF
</pre>
<p><b>This technique is not without danger.</b>
The factory provided contents of the high memory word is a return
instruction which loads the calibration value in the W register.
When the high memory word is accidentally destroyed
- for example by an erase operation of a PIC programmer whereby the
contents of the high memory word is not preserved -
you should <b>not</b> use this technique!
When the high memory does not contain a return instruction the PIC will
most likely enter an endless reset loop.
When you are not sure or want to play it safe, you better move a
'medium' value directly into OSCCAL, for example with:
<pre>
   OSCCAL = 0x80
</pre>
See the datasheet for acceptable values: frequently the low order bits
should be zero.
<p>By varying the value in OSCCAL and measuring the result you may fine
tune the oscillator frequency.


<h2><a name="usbprov">Provisions for USB</a></h2>

<p>When the USB module of a PIC is activated, memory for data buffers is
needed.
For some PICs the address and size of data buffers is fixed, other PICs
offer more freedom.
The USB data buffers are specified in the Buffer Descriptor Table (BDT).
This BDT is at a fixed location in RAM but not the same for all PICs.
To help the USB library with finding the actual location of the BDT for a
specific PIC a constant <b>USB_BDT_ADDRESS</b> is defined indicating the
address of the Buffer Descriptor Table.


<h2><a name="ppsgroup">Peripheral Pin Selection</a></h2>

<p>A number of 18F PICs have a feature called Peripheral Pin Selection.
For the input and/or output of some modules a pin can be selected.
There are limitations in the choice of pins, but more importantly there a
many similarities and a few differences between PICs.
Currently there are 2 groups of PICs with the same possibilities:
<table>
<tr><th>PPS group <th>Datasheet <th>PICs </tr>
<tr><td>1         <td>39932     <td>18f24j11 18f25j11 18f26j11 18f44j11 18f45j11 18f46j11</tr>
<tr><td>          <td>39931     <td>18f24j50 18f25j50 18f26j50 18f44j50 18f45j50 18f46j50</tr>
<tr><td>2         <td>39974     <td>18f26j13 18f27j13 18f46j13 18f47j13</tr>
<tr><td>          <td>39964     <td>18f26j53 18f27j53 18f46j53 18f47j53</tr>
</table>
<p>The 'LF' variants of the listed chips have the Peripheral Pin Selection feature too!
<p>The differences between the groups are in the number of selectable
(output) pins and in the assignment of function number, as shown in the
following table:
<table>
<tr><th>Func.<th> Group 1  <th> Group 2   </tr>
<tr><td>  0  <td> NULL     <td> NULL      </tr>
<tr><td>  1  <td> C1OUT    <td> C1OUT     </tr>
<tr><td>  2  <td> C2OUT    <td> C2OUT     </tr>
<tr><td>  3  <td>          <td> C3OUT     </tr>
<tr><td>  4  <td>          <td>           </tr>
<tr><td>  5  <td> TX2/CK2  <td>           </tr>
<tr><td>  6  <td> DT2      <td> TX2/CK2   </tr>
<tr><td>  7  <td>          <td> DT2       </tr>
<tr><td>  8  <td>          <td>           </tr>
<tr><td>  9  <td> SDO2     <td>           </tr>
<tr><td> 10  <td> SCK2     <td> SDO2      </tr>
<tr><td> 11  <td>          <td> SCK2      </tr>
<tr><td> 12  <td> SSDMA    <td> SSDMA     </tr>
<tr><td> 13  <td> ULPOUT   <td> ULPOUT    </tr>
<tr><td> 14  <td> CCP1/P1A <td> CCP1/P1A  </tr>
<tr><td> 15  <td> P1B      <td> P1B       </tr>
<tr><td> 16  <td> P1C      <td> P1C       </tr>
<tr><td> 17  <td> P1D      <td> P1D       </tr>
<tr><td> 18  <td> CCP2/P2A <td> CCP2/P2A  </tr>
<tr><td> 19  <td> P2B      <td> P2B       </tr>
<tr><td> 20  <td> P2C      <td> P2C       </tr>
<tr><td> 21  <td> P2D      <td> P2D       </tr>
<tr><td> 22  <td>          <td> CCP3/P3A  </tr>
<tr><td> 23  <td>          <td> P3B       </tr>
<tr><td> 24  <td>          <td> P3C       </tr>
<tr><td> 25  <td>          <td> P3D       </tr>
</table>
<p>Every device files contains the specification of a constant PPSGROUP with
the appropriate symbolic group number 'PPS_x', in which x is 0,1 or 2
('PPS_0' means: this PIC does not support Peripheral Pin Selection).
With new PICS more groups may have to be introduced.
<p>Handling of the differences between the groups is left to the PPS library.


<h2><a name="fuses">Naming convention for configuration bit fields (fuses)</a></h2>

<h3>Pragma fuse_def</h3>
<p>The MPLAB .dev files contain a <b>keyword</b> for every configuration
bit or group of bits,
and a <b>description</b> of the possible bit settings.
Unfortunately not always the same keyword is used for essentially the same
configuration bit or bit-field, and the keyword is sometimes different from
the keyword in the datasheet, or is simply spelled wrongly!
The descriptions have an even larger variation and are sometimes very long.
<p>For use with Jal, in particular for the 'pragma fuse_def' declarations,
a consistent keyword (in JalV2 called 'opt') and single-word symbolic values
(in JalV2 called 'tag') are desired.
The Jallib 'standard' is described below.

<h3>Fuse_def keywords, synonyms and replaced words</h3>
<p>For all pragma fuse_defs a keyword and
a number of symbolic values are declared in the device files.
This section deals with the keywords, the next section with symbolic values.

<p>Every configuration word or byte is preceeded with a comment line
indicating its address in memory.
<br>The meaning of configuration bits can in most cases be found in the
DataSheet of the specific chip, in the section 'Special Features of the
CPU'.
This info can also be found in the Programming Specifications of the chip.
For convenience the MicroChip document numbers of the specific PIC are
mentioned in the heading of its device file.

<p>To minimize misunderstanding and confusion the description for every
keyword as found in the MPLAB .dev file is appended as comment on the
'pragma fuse_def' line.
The combination of memory address and description should unambiguously
identify which configuration bits are controlled by the keyword,
even though the name might be different from that in the datasheet.

<p>Where convenient and intuitive enough the keywords found in the MPLAB
.dev files are used.
But synonyms are eliminated and some apparent misspellings are
corrected.
Sometimes an arbitrary keyword is chosen.

<p>The list below shows examples of most deviations of keywords from MPLAB .dev files:

<table>
<tr><th> keyword   </th><th>replaces synonym(s) and typo(s)</th></tr>
<tr><th> ABW       </th><td>ADDRBW                </td></tr>
<tr><th> BBSIZ     </th><td>BBSIZ0                </td></tr>
<tr><th> BROWNOUT  </th><td>BODEN, BOREN, DSBOREN </td></tr>
<tr><th> BW        </th><td>DATABW                </td></tr>
<tr><th> CCP(x)MUX </th><td>CCP(x)MX              </td></tr>
<tr><th> CPD       </th><td>CPDF, CPSW            </td></tr>
<tr><th> CPx       </th><td>CP_x                  </td></tr>
<tr><th> DEBUG     </th><td>BACKBUG, BKBUG        </td></tr>
<tr><th> EBTRx     </th><td>EBTR_x, EBRTx (typo)  </td></tr>
<tr><th> ECCPMUX   </th><td>ECCPMX                </td></tr>
<tr><th> EXCLKMUX  </th><td>EXCLKMX               </td></tr>
<tr><th> FCMEN     </th><td>FSCM                  </td></tr>
<tr><th> FLTAMUX   </th><td>FLTAMX                </td></tr>
<tr><th> OSC       </th><td>FOSC                  </td></tr>
<tr><th> IOSCFS    </th><td>IOFSCS (typo)         </td></tr>
<tr><th> MCLR      </th><td>MCLRE                 </td></tr>
<tr><th> MSSPMASK  </th><td>MSSP7B_EN, MSSPMSK    </td></tr>
<tr><th> P2BMUX    </th><td>P2BMX                 </td></tr>
<tr><th> PMODE     </th><td>PM                    </td></tr>
<tr><th> PMPMUX    </th><td>PMPMX                 </td></tr>
<tr><th> PWM4MUX   </th><td>PWM4MX                </td></tr>
<tr><th> PWRTE     </th><td>PUT, PWRT, PWRTEN, NPWRTE, NPWRTEN </td></tr>
<tr><th> RTCOSC    </th><td>RTCSOSC               </td></tr>
<tr><th> SOSCSEL   </th><td>SOSCEL                </td></tr>
<tr><th> SSPMUX    </th><td>SSPMX                 </td></tr>
<tr><th> STVR      </th><td>STVREN                </td></tr>
<tr><th> T1OSCMUX  </th><td>T1OSCMX               </td></tr>
<tr><th> T3CMUX    </th><td>T3CMX                 </td></tr>
<tr><th> VOLTAGE   </th><td>BODENV, BOR4V, BORV   </td></tr>
<tr><th> WDT       </th><td>WDTEN                 </td></tr>
<tr><th> WRT       </th><td>WRT_ENABLE, WRTE      </td></tr>
<tr><th> WRTx      </th><td>WRT_x                 </td></tr>
</table>
Notes:
<ol>
<li>Keywords for pin multiplexing end in 'MUX', like CPPxMUX.
<li>Not all declared keywords in the MPLAB .dev files may be 'catched',
there may be some inconveniently (long) keywords left.
<li>When the compiler stalls over a fuse-def line a correction should be
applied.
If you encounter such an occasion please report it in the Jallib
discussion group at Google Groups.
</ol>

<h3>Fuse_def symbolic values</h3>
<p>As mentioned above the MPLAB .dev files contain frequently long and
descriptions with many variations of the same story.
Only for the oscillator specification alone the MPLAB .dev files contains
about 200 different descriptions!
But often the description is a single word like DISABLED or ACTIVE.

Multi-word descriptions have been reduced to a single word or at least a
single string (multiple words coupled by underscore characters).

<p>Like for the keywords also for the symbolic values many synonyms can be
found in the MPLAB .dev files.
These synonyms are eliminated to a large extent.
For example 'ENABLE' is often used even when the datasheet or MPLAB .dev
file specifies 'ON' or 'ACTIVE'.

<p>Below a set of 'normalized' pragma fuse_def:

<h4>Fuse_def  ADSEL  (ADC resolution)</h4>
<pre>
   B10                -- 10 bits
   B12                -- 12 bits
   B..                -- other number of bits
</pre>

<h4>Fuse_def  ABW  (Address Bus Width)</h4>
<pre>
   B8                 -- 8 bits
   B16                -- 16 bits
   B..                -- other number of bits
</pre>

<h4>Fuse_def  BBSIZ  (Boot Block Size)</h4>
<pre>
   W256               -- 256 words
   W512               -- 512 words
   W1K                -- 1024 words (1K words)
   W2K                -- 2048 words (2K words)
   W...               -- any other number of words
</pre>

<h4>Fuse_def  BG  (Band Gap)</h4>
<pre>
   ADJUST_NEG         -- negative adjustment
   ADJUST_POS         -- positive adjustment
   ...                -- other
</pre>

<h4>Fuse_def  BROWNOUT  (Brown Out detection)</h4>
<pre>
   ENABLED            -- BOD enabled, SBOREN disabled
   RUNONLY            -- BOD enabled in run, disabled in sleep
   CONTROL            -- SBOREN controls BOR function
   DISABLED           -- BOD and SBOREN disabled
</pre>
BROWNOUT is also used for Deep Sleep BrownOut (DSBOREN).

<h4>Fuse_def  BW  (Bus Width)</h4>
<pre>
   B8                 -- 8 bits
   B16                -- 16 bits
   B..                -- other number of bits
</pre>

<h4>Fuse_def  CCPxMUX (multiplexing of pin of CCP module x)</h4>
<pre>
   pin_xy             -- assigned to pin y of PORTx
   pin_..             -- any other
   Enabled            -- ) see datasheet
   Disabled           -- )
</pre>
<br>When the multiplexing is also dependend of the microprocessor mode
(with some high end 18Fs) the pin for 'Microcontroller mode' is specified.
Of course in other modes another alternate pin will actually be configured!

<h4>Fuse_def  CP  (Code Protection)</h4>
<pre>
   ENABLED            -- Code memory read protection on
   DISABLED           -- Code mewmory read protection off
</pre>

<h4>Fuse_def  CPD  (Data Code Protection)</h4>
<pre>
   ENABLED            -- Data (EEPROM) memory read protection on
   DISABLED           -- Data (EEPROM) memory read protection off
</pre>

<h4>Fuse_def  CPUDIV  (CPU clock divisor)</h4>
<pre>
   P1                 -- No divide
   P2                 -- divide by 2
   P..                -- etc.
</pre>

<h4>Fuse_def  DSWDTOSC (Watchdog oscillator selections)</h4>
<pre>
   INTOSC             -- internal oscillator
   OSC                -- oscillator determined by OSC fuse_def
</pre>

<h4>Fuse_def  DSWDTPS  and WDTPS (Deep Sleep) WatchDog Timer PostScaler</h4>
<pre>
   P2G                -- 1 : 2G  (2 * 1073741824)
   P...
   P2M                -- 1 : 2M  (2 * 1048576)
   P...
   P2K                -- 1 : 2K  (2 * 1024)
   P..
   P2                 -- 1 : 2
</pre>

<h4>Fuse_def  EBTRB  (bootblock write protection)</h4>
<pre>
   ENABLED            -- boot block table read protected
   DISABLED           -- boot block may be table read
</pre>

<h4>Fuse_def  ECCPxMUX  (ECCP pin multiplexing)</h4>
<pre>
   pin_xy             -- pin y of portx is used
</pre>

<h4>Fuse_def  EMB (External memory bus width)</h4>
<pre>
   B12                -- 12 bits
   B16                -- 16 bits
   B20                -- 20 bit
   DISABLED           -- disabled
</pre>

<h4>Fuse_def ETHLED  (Ethernet LED)</h4>
<pre>
   ENABLED            -- Ethernet LED enabled
   DISABLED           -- Ethernet LED disabled
</pre>

<h4>Fuse_def EXCLKMUX (TMR1/T5CLKI assignement)</h4>
<pre>
   pin_xy             -- Clock input assigned to pin y of portx
</pre>

<h4>Fuse_def FLTAMUX (FLTA multiplexing)</h4>
<pre>
   pin_xy             -- pin y of portx is used
</pre>

<h4>Fuse_def FOSC2  (default/reset system clock select)</h4>
<pre>
   INTOSC             -- Internal oscillator
   OSC                -- Clock selected by OSC setting
</pre>

<h4>Fuse_def HFOFST  (...)</h4>
<pre>
   ENABLED            -- enable
   DISABLED           -- disabled
</pre>

<h4>Fuse_def IOSCFS  (Internal Oscillator Frequency Select)</h4>
<pre>
   F4MHZ              -- 4 MHz
   F8MHZ              -- 8 MHz
</pre>

<h4>Fuse_def LPT1OSC  (Low Power Timer1 Oscillator)</h4>
<pre>
   LOW_POWER          -- low power, low noise immunity
   HIGH_POWER         -- high power high noise immunity
</pre>

<h4>Fuse_def LVP  (Low Voltage Programming)</h4>
<pre>
   ENABLED            -- LVP on
   DISABLED           -- LVP off
</pre>

<h4>Fuse_def MCLR  (reset)</h4>
<pre>
   EXTERNAL           -- /MCLR pin enabled
   INTERNAL           -- /MCLR pin is digital I/O
</pre>

<h4>Fuse_def OSC  (oscillator)</h4>
<pre>
   LP                 -- Low Power crystal on OSC1,OSC2
   XT                 -- Crystal or Resonator on OSC1,OSC2
   HS                 -- High Speed Crystal or Resonator on OSC1,OSC2
   HS_PLL             -- HS with (hardware) PLL active
   EC_CLKOUT          -- External Clock (TTL) signal on OSC1, ClockOut on OSC2
   EC_NOCLKOUT        -- External Clock (TTL) signal on OSC1, OSC2 is I/O
   EC_CLKOUT_PLL      -- EC_CLKOUT with PLL active
   EC_NOCLKOUT_PLL    -- EC_NOCLKOUT with PLL active
   ECH_NOCLKOUT       -- external clock, high power mode
   ECL_NOCLKOUT       -- external clock, low power mode
   ECM_NOCLKOUT       -- external clock, medium power mode
   RC_CLKOUT          -- (external) Resistor/Capacitor oscillator on OSC1, ClockOut on OSC2
   RC_NOCLKOUT        -- (external) Resistor/Capacitor oscillator on OSC1, OSC2 is I/O
   INTOSC_CLKOUT      -- Internal oscillator, OSC1 is I/O, ClockOut on OSC2
   INTOSC_NOCLKOUT    -- Internal oscillator, OSC1 and OSC2 are I/O
</pre>
The first or only part is the oscillator type, the [optional] second part
indicates a related subfunction.
For example it may indicate if the OSC2 pin is CLKOUT or I/O, or if PLL is
active.
Several other keywords are possible, for example:
<ul compact>
<li>with USB
<li>with dual oscillator sources
<li>low, medium, and high power oscillators
</ul>
The datasheet will specify the possibilities, browse the device file for
the applicable keywords.

<h4>Fuse_def PLLDIV (PLL prescaler)</h4>
<pre>
   P1                 -- 1 : 1
   P..                -- etc
   P12                -- 1 : 12
</pre>

<h4>Fuse_def PLLEN (PLL enable)</h4>
<pre>
   P1                 -- 1 : 1
   P4                 -- 4 : 1
   F500KHZ            -- freq 500 KHz
   F16MHZ             -- freq 16 MHz
</pre>

<h4>Fuse_def PWM4MUX (PWM4 multiplexing)</h4>
<pre>
   pin_xy             -- PWM4 assigned to pin_y of portx
</pre>

<h4>Fuse_def PMODE (Extended memory bus)</h4>
<pre>
   B12                 -- extended microcontroller 12-bit
   B16                 -- extended microcontroller 16-bit
   B20                 -- extended microcontroller 20-bit
   EXT                 -- extended microcontroller
   MICROCONTROLLER     -- microcontroller
   MICROPROCESSOR      -- microprocessor
   MICROPROCESSOR_BOOT -- microprocessor with boot block
</pre>

<h4>Fuse_def PMPMUX (PMP multiplexing)</h4>
<pre>
   PORTx              -- PMP on PORTx and other ports
</pre>

<h4>Fuse_def PWRTE  (Power-up Timer Enable)</h4>
<pre>
   ENABLED            -- Power up timer enabled
   DISABLED           -- Power Up timer disabled
</pre>

<h4>Fuse_def RTCOSC  (RTC reference clock selection)</h4>
<pre>
   INTOSC             -- Internal oscillator
   T1OSC              -- Timer 1 oscillator
</pre>

<h4>Fuse_def SIGN (bulk erase)</h4>
<pre>
   NOT_CONDUCATED
   AREA_COMPLETE
</pre>

<h4>Fuse_def SSPMUX (SPI I/O multiplexing)</h4>
<pre>
   pin_xy             -- SPI active on pin y of portx
   DISABLED           -- SPI not assigned
</pre>

<h4>Fuse_def T1OSCMUX  (Timer 1 multiplexing)</h4>
<pre>
   pin_A6_A7          -- pin_A6 and pin_A7 are used
   pin_B2_B3          -- pin_B2 and pin_B3 are used
</pre>

<h4>Fuse_def USBDIV  (USB clock selection)</h4>
<pre>
   P1                 -- no divide
   P2                 -- divide by 2
</pre>

<h4>Fuse_def USBPLL  (USB PLL source)</h4>
<pre>
   F48MHZ             -- from 96MHZ PLL / 2
   OSC                -- from Oscillator
</pre>

<h4>Fuse_def VCAPEN  (Voltage regulator capacitor pin)</h4>
<pre>
   DISABLED
   pin_A0
   <i>...  etc (other pins which could be assigned</i>
</pre>

<h4>Fuse_def VOLTAGE  (Brown out voltage)</h4>
<pre>
   V20                -- 2.0 Volt
   V27                -- 2.7 Volt
   V42                -- 4.0 Volt
   V45                -- 4.5 Volt
   <i>...  etc (whatever voltages are applicable)</i>
</pre>

<h4>Fuse_def WAIT  (Wait ...)</h4>
<pre>
   ENABLED            -- synchronous
   DISABLED           -- asynchronous
</pre>

<h4>Fuse_def WDT  (WatchDog Timer)</h4>
<pre>
   ENABLED            -- Watchdog enabled
   DISABLED           -- Watchdog disabled
   CONTROL            -- Software controlled (SWDTEN)
   RUNNING            -- Enabled while running, disabled in Sleep.
</pre>

<h4>Fuse_def WDTCS  (WatchDog Timer Clock Select)</h4>
<pre>
   STANDARD
   LOW_POWER
</pre>

<h4>Fuse_def WPEND  (Write protect area)</h4>
<pre>
   P0_WPFP            -- from page 0 to write protect page
   PWPFD_END          -- from write protect page to end of memory
</pre>

<h4>Fuse_def WPFP (Write Protect Flash Page)</h4>
<pre>
   P0                 -- Write protect flash page 0
   P1                 -- Write protect flash page 1
   P..                -- etc
   P127               -- Write protect flash page 127
</pre>

<h4>Fuse_def WRT  (Program Memory Self-Write Protection)</h4>
<pre>
   NO_PROTECTION      -- All program memory writable
   ALL_PROTECTED      -- Writing of program memory prohibited
   Rxxxx_yyyy         -- Protected memory range
                      -- <i>(only specific ranges can be write protected)</i>
</pre>

<h4>Fuse_def WRTx (Write Protection of Table/Region)</h4>
<pre>
   ENABLED            -- table/region is not write protected
   DISABLED           -- table/region is write protected
</pre>

Notes:
<ol>
<li>The list above in not exhaustive there may be others,
depending on the features of the specific PICmicro.
To conform to a compiler requirement names must start with a letter or
an underscore and may not contain special characters and spaces.
Multi-word descriptions as found in the MPLAB .dev files (other than those
listed above) have been transformed to a keyword as follows:
<ul>
<li>special characters and spaces are translated to underscores
<li>leading and trailing underscores are removed
<li>multiple consecutive underscores are reduced to a single underscore
<li>when the first character is a digit a letter is added as prefix,
which can be 'R' for range, 'F' for frequency, 'B' for number of bits,
or 'N' otherwise.
</ul>
<li>As an example of an address range specification for PICs with the
possibility to protect certain code memory areas you may have to specify:
<pre>
pragma target CP R0F00_0FFF
</pre>
<li>The device file contains a specification for the fuses array.
how many words or bytes and their corresponding memory addresses.
Also a default fuse setting is specified, which may or may not be
suitable for your application!
<b>Never trust defaults!</b>
</ol>

<h2>Alternate ways to specify configuration bits</h2>
<p>When you find the specification of fuse_def inconvenient or
you want to specify the bits one-by-one by yourself, the compiler
allows you to do so.
For example for the PIC16F690 the following group of statements:
<pre>
   pragma target OSC       HS
   pragma target WDT       Disabled
   pragma target PWRTE     Enabled
   pragma target MCLR      External
   pragma target CP        Disabled
   pragma target CPD       Disabled
   pragma target BROWNOUT  Enabled
   pragma target IESO      Disabled
   pragma target FCMEN     Disabled
</pre>
is equivalent with:
<pre>
   pragma target fuses   0b11_0011_1110_0010
</pre>

<p>PICs with 16-bits core (the 18F series) have such a large set and
variety of configuration bits that explicit specification is probably
the best way to make sure all configuration bits are set correctly for
your program.
As an example see the following list for a simple blink-a-led program
with an 18F242.
<pre>
   pragma  target fuses 0  0b0000_0000       -- (n/a)
   pragma  target fuses 1  0b0010_0010       -- not switchable, HS osc, no PLL
   pragma  target fuses 2  0b0000_0001       -- BOR disabled, PWTR disabled
   pragma  target fuses 3  0b0000_0000       -- watchdog disabled
   pragma  target fuses 4  0b0000_0000       -- (n/a)
   pragma  target fuses 5  0b0000_0001       -- CCP2 on RC1
   pragma  target fuses 6  0b1000_0001       -- no bg debug, no LVP, STVREN
   pragma  target fuses 7  0b0000_0000       -- (n/a)
   pragma  target fuses 8  0b0000_1111       -- no code protection
   pragma  target fuses 9  0b1100_0000       -- no data protection
   pragma  target fuses 10 0b0000_1111       -- no code write protection
   pragma  target fuses 11 0b1110_0000       -- no other write protection
   pragma  target fuses 12 0b0000_1111       -- no table read protection
   pragma  target fuses 13 0b0100_0000       -- no boot block write protect
</pre>
(n/a) means not applicable to this specific PIC, but may be specified
(as all zeroes).

<p>Notes:
<ol>
<li>When a PIC has multiple configuration words or bytes the index value
of the word or byte must be specified between 'fuses' and the value.
</ol>

<hr>

<h2><a name="compiler">Compiler requirements</a></h2>

<p>The compiler - at the moment of this writing version 2.4n - has a
number of requirements for device specifications.
The most important from a user perspective are the following:

<h3>Memory allocation</h3>
<p>The device files specify the amounts of available data memory (RAM)
for variables in bytes.
<p>There is a distinction between 'shared' and 'unshared' memory.
For the compiler 'shared' means:
<ul compact>
<li>for baseline and midrange PICs: accessible in all banks
regardless the value of STATUS_RP
<li>for the extended midrange and 18F PICS: (GPR) memory in the access
bank
</ul>
Memory which is accessible in more than one bank but not in all banks
is in this context 'unshared'.
<br>The compiler allocates memory for regular ('user') variables in
unshared memory.
When a PIC has shared memory (most PICs have) it is specified with
'pragma shared' in the device files,
while unshared memory is specified with 'pragma data'.
<br>The log of a compilation contains a line like:
<pre>
 Data area: 250 of 368
</pre>
in which the last number is the total amount of <b>unshared</b> memory,
which is in most cases lower than the total amount of data memory
according to the datasheet, because it does not inlcude shared memory.
<p>The compiler needs some data memory for internal use.
The variables are named _pic_accum and _pic_isr_w,
and <b>must</b> be in shared memory.
Each device files contains a declarations for these variables.
Most PICS have both shared and unshared RAM and then there is no
issue, neither is there an issue with PICs with only 1 memory bank.
But some midrange PICs have only shared memory while some others have
no shared memory at all.
This complication is handled by the device files as follows:
<ul>
<li>For PICs with <b>only shared</b> memory all memory is declared as
unshared, except for the compiler-required variables.
<br>Examples: 12F675, 16F676, 16F873A.
<li>For PICs with <b>only unshared</b> memory the memory for the compiler
required variables is declared 'shared' (even though it is in fact
unshared memory!)
and the locations with the same (7-bits) offset in other banks
are reserved (excluded from the available data memory for user variables).
<br>This is only partly a solution.
It avoids problems with interrupt handlers (which use _pic_isr_w), but it
does not completely avoid problems with calculations with multi-byte
variables (word, dword, etc., which uses _pic_accum) when the variables
are in different banks.
This applies to the 16F72, 16F73 and 16F74 and means:
<br><b>Programs for 16F72, 16F73 and 16F74 should not perform calculations
with multi-byte variables</b>.
</ul>
<p>Another subject of attention is data memory for USB modules.
This is 'special' data memory, sometimes dedicated to the USB module,
sometimes it can be used as normal data memory by the user program,
but only when the USB module is inactive,
and sometimes it can be shared between USB module and user program.
So the amount of available data memory as specified in the device file
can be smaller than the total amount of memory specified in the
datasheet due to reservation by the USB module.


<h3>Analog modules</h3>
<p>(to be done)

<hr>

<h2>Compatibility and Miscellaneous Remarks</h2>

<p>These device files are part of the central JalV2 repository 'Jallib'
(http://jallib.googlecode.com).
Other libraries of Jallib have been or are being converted to use the names
in these device files.
You are strongly recommended to use only this combination of include files.
Using these device files in combination with other libraries may cause
problems, especially with libraries for the old (pre JalV2) compiler.

<ul>

<li>The naming convention of ports and subfields maybe different, you may
have to convert the other libraries.

<li>Bank switching functions are not needed with JalV2 and do not appear in
the device files.
This may cause compile-time errors when using programs or libraries which
still use these procedures.
You must remove these bank switching functions from your programs and
libraries!

<li>The device specific include files are generated from the MPLAB .dev
and .lkr files.
This may cause confusion or even conflicts because the register and bit
names are not always identical to those in the datasheets!
Apart from that, MPLAB is not errorfree, consequently include files generated
from this source cannot expected to be errorfree either!

<li>The device files contain some information for specific function
libraries to make life of function library builders easier.
For example a constant 'ADC_GROUP' is declared and assigned a value.
This value can be used by ADC libraries to handle groups of PICs
similarly and groups of other PICs differently.
This grouping is inspired by the Microchip MCC18 compiler.

</ul>

<p>Note: With Jallib version 0.7 a number of constants, formerly
declared in each device file is moved to a file 'constants_jallib.jal'.
This file is included by chipdef_jallib.jal (which is on its turn
included by every device file).
Don't worry about memory occupation: unused constants are removed by the
compiler automatically and don't occupy memory!



<!- ---------------------------------------------------------------------- -->
<hr>

<h1><a name="gen">4. Generating device files</a></h1>

<h2>The process</h2>
<p>The device files are generated by transforming MPLAB files with a script
'dev2jal.cmd' in the /Jallib/tools directory.
The script is developed and executed with 'classic' Rexx as standardly delivered
with eComStation (OS/2).
To run it:
<ul>
<li>Start a commandline session ('command prompt')
<li>Go to the directory k:/Jallib/Tools
<li>Type: dev2jal test
</ul>
<p>Notes:
<ol>
<li>The dev2jal script expects both MPLAB and a local copy of Jallib
    installed on drive K.
    The script contains comments with instructions for possible changes in
    the script to run it on a different system configuration.
    This concerns only a few variables in the top of the script file.
<li>The 'test' commandline argument will put the device files in a 'test'
    subdirectory of the current directory.
</ol>

<p>The dev2jal script can be executed on other systems (Linux, Windows)
when a compatible Rexx interpreter is installed.
The free 'Regina Rexx' has proven to do fine for this script
(tested under Windows XP).
For more information about Regina Rexx see:
<ul>
<li>http://regina-rexx.sourceforge.net/index.html
</ul>
<p>Download and install the package (latest version 3.5) when you want to
run the script on a non-eComStation system.
Probably the easiest way to run the script is:
<ul>
<li>Copy /jallib/tools/dev2jal.cmd to the directory where you installed
Regina Rexx.
<li>Make the necessary changes in the script.
<li>Start a CommandLine session ('command prompt' / 'MS-DOS prompt' / 'terminal').
<li>Go to the directory with Regina Rexx.
<li>Enter the command: regina dev2jal.cmd test
</ul>
The generated device files will be in subdirectory 'test' (./test).

<h2>To do when new datasheets become available</h2>
<p>Generally MPLAB contains .dev and .lkr files of PICs of which the
datasheet is not yet available.
The dev2jal script does not generate device files when the datasheet number
is (yet) unknown.
When a datasheet becomes available the following actions are needed to
generate device files (by 'manual' editing the involved tools files):
<ul>
<li>Make a new entry in the file 'datasheet.list' in the jallib tools
directory for each new Datasheet or Programming Specifications.
<li>Make a new entry or update an existing entry in the file
'devicespecific.json' in the tools directory for each of the PICs described
in the new datasheet.
<li>Make a new entry or update an existing entry in the file 'pinmap.py' for
each of the PICs described in the new datasheet.
In most cases the datasheet contains a table 'Pinout I/O descriptions' or
'Pin allocation' with the required information to define aliases.
Run python script extract_pininfos.py to obtain an up-to-date
pinmap_pinsuffix.json and some other tools files.
<li>Now run the Rexx script dev2jal.cmd with TEST option to generate a new
set of device files.
<li>Possibly some corrections have to be applied to the dev2jal script when
new PICs have exceptions not covered yet, for example JANSEL numbering.
<li>Run the Rexx blink-a-led script with TEST option to verify the device
files and to generate blink samples.
<p>When all is satisfactory run the dev2jal.cmd script with the 'PROD'
option, SVN-add the device files of new PICs, and commit all device files
and changed files in the tools and wiki directories.
<li>Now run also the blink-a-led script with PROD option, SVN-add the
new blink samples and commit these.
<li>Run the Rexx script 'createdswikis.cmd' to generate up-to-date wiki
files related to datasheets.
Note: This script needs to be run after new device files have been generated
because it considers only 'existing' Jallib device files.
</ul>


<h2>To do after a fresh install of MPLAB</h2>
<p>The dev2jal.cmd script contains several device specific 'adaptations' to make
the device files suitable for Jallib.
Most of these are mentioned in chapter 3 of this document.
When generating Jallib device files after a fresh install of MPLAB
in addition to the 'automatic' corrections some 'manual' editing is required.
These are mainly corrections of errors or omissions in the MPLAB .dev files,
which may have been corrected by Microchip from one to another version of MPLAB!
<ul>
<li>10F200,202,204,206:
    <br>Remove Config 'OSC' field
<li>12F510:
    <br>Enumerate individual bits for GPIO_GP5..0
    <br>Rename IOSCFS values: Enabled to 8MHz and Disabled to 4MHz
<li>12F519 and 12F520:
    <br>Rename PORTB to GPIO and individual bits RBx to GPx.
    <br>Rename TRISB to TRISIO and individual bits TRISBx to TRISIOx
<li>16F506:
    <br>eNUMERATE pins of PORTB and PORTC when not already.
    <br>Rename IOSCFS values: Enabled to 8MHz, Disabled to 4MHz
<li>16F526:
    Add individual pin widths of PORTB and PORTC when missing
<li>16F627:
    Remove second option (value=0x2800) from CP cfgbits.
<li>16F87:
    <br>CCPMX -> CCP1MUX: and only desc="RB0" and "RB3"
<li>16LF1902/3
    <br>Correct devID 16lf1902 = 0x1C00, 16lf1903 = 0x1C20
<li>18F1230/1330:
    <br>Fuses ICPRT: Add value=0x8 with 'Enabled'
<li>18F13K50,14K50 and LF-variants:
    <br>Add LATA3,1,0 and TRISA3,1,0 when missing.
    Check default fuse settings for CPUDIV and PLL (should be all 1:1)
<li>18F66j16:
    <br>Make ACTQ bits in ADCON1 a bit*3 variable (not enumerated).
</ul>
<p>When there are new device files which are not in Jallib yet then before
running the dev2jal script you may have to perform the actions described
above in the section 'To do when new datasheets become available'.

<p>Now run the dev2jal script with the 'TEST' option, redirect the output to
a file and check this file for errors and warnings which need attention.
<ul>
<li>Add support for unrecognised Fuse_Def keywords to the dev2jal script.
<li>Probably the script file 'fusedefmap.cmd' needs to be updated
    because of new or changed descriptions of oscillator settings.
<li>Maybe some corrections have to be applied to the dev2jal script
    when new PICs have exceptions not covered yet,
    for example JANSEL numbering.
<li>Visually check the new device files for irregularities.
    Use a file compare program (e.g. Kdiff3) to reveal differences.
    When needed apply changes to the script and/or data files.
</ul>


</body>
</html>
