<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
    <head>
    </head>
    <body>
		        <div id="page">
        
            <div id="pagecontent">

			    
    <h1>i2c_hw_slave_isr</h1>

    <div>
		<font size="+1"><i>i2c hardware slave ISR</i></font>
	</div>

	<br/>

    <div class="narrow">
        
	<table>
	<tr>
		<td style="border: 1px solid #aaa; padding: 5px;">
			<b>Author</b>
		</td>
		<td style="border: 1px solid #aaa; padding: 5px;">
			Sebastien Lelong, Joep Suijs, Copyright (c) 2008-2009, all rights reserved.
		</td>
	</tr>
	<tr>
		<td style="border: 1px solid #aaa; padding: 5px;">
			<b>Adapted-by</b>
		</td>
		<td style="border: 1px solid #aaa; padding: 5px;">
			
		</td>
	</tr>
	<tr>
		<td style="border: 1px solid #aaa; padding: 5px;">
			<b>Compiler</b>
		</td>
		<td style="border: 1px solid #aaa; padding: 5px;">
			>=2.4i
		</td>
	</tr>
	</table>

	<br/>
	
	<b>Description</b>
	<p>
		<pre>this library provides an ISR to implement 
a stateful i2c hardware slave. This is a jalv2 implementation of
Microchip Application Note AN734.



According to AN734, there are 5 possible i2c states. During ISR, each
of this states are detected. This ISR provides a standard skeleton to implement
an i2c hardware slaves, while client code must implement several callbacks
the ISR is expecting to call while processing states.



Here there are:
 - procedure i2c_hw_slave_on_master_talks(byte in _trash):
      called when i2c address matches (master starts a talk)
         => called in state 1
 - procedure i2c_hw_slave_on_master_writes(byte in rcv):
      called when master is writing a byte. Slave is thus
      receiving this byte. This callback takes this bytes as
      argument
         => called in state 2
 - procedure i2c_hw_slave_on_master_reads():
      called when master wants to read a byte from slave. Thus,
      slave should send a byte (for instance, using i2c_hw_slave_write_i2c
      from i2c_hw_slave.jal library)
         => called in state 3
 - procedure i2c_hw_slave_on_master_stillreads():
      called when master still wants to read a byte from slave. That is,
      master required to read (state 3) and now still want to read a byte
         => called in state 4
 - procedure i2c_hw_slave_on_master_hangsup():
      called when master does not want to talk to slave anymore
      usually a good place to reset data or slave's logic
         => called in state 5
 - procedure i2c_hw_slave_on_error():
      called when something wrong happens. You can do what you want in
      this case, like resetting the PIC, log some information using usart, ...
         => called any cases other than states 1, 2, 3, 4 or 5
</pre>

	</p>
	<br/>

	<b>Sources</b>
	<p>
		<pre>  - AN734: http://www.microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=1824&appnote=en011798
</pre>

	</p>
	<br/>

	
	<b>Dependencies</b>
	<p>
		<ul>
			<li><a href="i2c_hw_slave.html">i2c_hw_slave</a></li>
		</ul>


			<br/>
				<h2><a name="summary">Summary</a></h2>

		<h3><a name="Global variables/contants">Global variables/contants</a></h3>
		<ul>
	</ul>


		<h3><a name="Procedures">Procedures</a></h3>
		<ul>
		<li>
				<b><code name="code" class="python"><a href="#850564219a39a8c3393836af4903f71d">i2c_hw_slave_proceed_state_2()</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#d26f009846e191847af6b605298fc470">i2c_hw_slave_proceed_state_3()</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#de81253e7aca80bd856e5df527eaeefc">i2c_hw_slave_proceed_state_1()</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#e4bcf072649b2d3f4c95ca04cf074b16">i2c_hw_slave_isr_handler()</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#18ed246ad047faf94bfb675c061d0a02">i2c_hw_slave_proceed_state_4()</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#d5d5edfcc92aa48e18d2ee312b00e15e">i2c_hw_slave_proceed_error()</a></code></b>
		</li>
		<li>
				<b><code name="code" class="python"><a href="#a12717a8f604ab0f3f50155e6346e825">i2c_hw_slave_proceed_state_5()</a></code></b>
		</li>
	</ul>


		<h3><a name="Functions">Functions</a></h3>
		<ul>
	</ul>



			<br/>
				<h2><a name="api">API details</a></h2>

		<h3><a name="Global variables/contants">Global variables/contants</a></h3>
		<ul>
	</ul>


		<h3><a name="Procedures">Procedures</a></h3>
		<ul>
		<li>
				<b><code name="code" class="python"><a name="850564219a39a8c3393836af4903f71d" href="#summary">i2c_hw_slave_proceed_state_2()</a></code></b>
				<p>	<pre>state 2: write operation, last byte is data, buffer full
master wants to write, it sends a byte
    => call i2c_hw_slave_on_master_writes(byte)
</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="d26f009846e191847af6b605298fc470" href="#summary">i2c_hw_slave_proceed_state_3()</a></code></b>
				<p>	<pre>state 3: read operation, last byte is address, buffer empty
master wants to get a value from us
    => call i2c_hw_slave_on_master_reads()
</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="de81253e7aca80bd856e5df527eaeefc" href="#summary">i2c_hw_slave_proceed_state_1()</a></code></b>
				<p>	<pre>state 1: write operation, last byte is address, buffer full
byte is an address, it we get here, we just know master
wants to talk to us...
and we also know address is recognized (BF is set, see spec)
anyway, we must read buffer to reset BF bit
    => call i2c_hw_slave_on_master_talks(byte)
</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="e4bcf072649b2d3f4c95ca04cf074b16" href="#summary">i2c_hw_slave_isr_handler()</a></code></b>
				<p>	<pre>i2c ISR handler. Detects states a call appropriate procedures
</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="18ed246ad047faf94bfb675c061d0a02" href="#summary">i2c_hw_slave_proceed_state_4()</a></code></b>
				<p>	<pre>state 4: read operation, last byte is data, buffer empty
master still wants to get a value from us
    => call i2c_hw_slave_on_master_stillreads()
</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="d5d5edfcc92aa48e18d2ee312b00e15e" href="#summary">i2c_hw_slave_proceed_error()</a></code></b>
				<p>	<pre>state not recognized... Error !
    => call i2c_hw_slave_on_error()
</pre>
</p>
		</li>
		<li>
				<b><code name="code" class="python"><a name="a12717a8f604ab0f3f50155e6346e825" href="#summary">i2c_hw_slave_proceed_state_5()</a></code></b>
				<p>	<pre>state 5: nack
master doesn't want to talk with us anymore
    => call i2c_hw_slave_on_master_hangsup()
</pre>
</p>
		</li>
	</ul>


		<h3><a name="Functions">Functions</a></h3>
		<ul>
	</ul>



			<br/>
				<h2><a name="related_samples">Related samples</a></h2>
	Here are the list of samples which use this library:<br/><br/>
	<table border=1>
			<tr>
			<td><b>16f88</b></td><td><a href="http://code.google.com/p/jallib/source/browse/trunk/sample/by_device/16f88/16f88_i2c_hw_slave_echo.jal" target="_blank">16f88_i2c_hw_slave_echo.jal</a></td>
			</tr>
	</table>

			<br/>

            </div>
        </div>


	</body>
</html>

