#!/usr/bin/python
# ----------------------------------------------------------------------
#  Title: pic2Jal.py  - Create JalV2 device files for flash PICs
#
#  Author: Rob Hamerling, Copyright (c) 2014..2014, all rights reserved.
#
#  Adapted-by:
#
#  Revision: $Revision$
#
#  Compiler: N/A
#
#  This file is part of jallib  http://jallib.googlecode.com
#  Released under the BSD license
#               http://www.opensource.org/licenses/bsd-license.php
#
#  Description:
#    Python script to create device specifications for JALV2, and
#    the file chipdef_jallib.jal, included by each of these.
#    Input are .pic files from MPLAB-X.
#    Apart from declaration of all registers, register-subfields, ports
#    and pins of the chip the device files contain shadowing procedures
#    to prevent the 'read-modify-write' problems and use the LATx register
#    (for PICs which have such registers) for output in stead of PORTx.
#    In addition some device dependent procedures are provided
#    for common operations, like enable_digital_io().
#    Also various aliases are declared to 'normalize' the names of
#    registers and bit fields, which makes it easier to build device
#    independent libraries.
#
#  Sources:  MPLAB-X .pic files
#
#  Notes:
#    - A summary of changes of this script is maintained in 'changes.txt'
#      (not published, available on request).
#
# ----------------------------------------------------------------------

import os, sys
import re
import fnmatch
import time
import json
from xml.dom.minidom import parse, Node


# -- basic working parameters -----------------------------

scriptversion   = "0.0.3"
scriptauthor    = "Rob Hamerling"
compilerversion = "2.4q2"
mplabxversion   = "205"
mplabxbase      = "k:/mplab-x_" + mplabxversion                # MPLAB-X base directory
jallibbase      = "k:/jallib"                                  # local copy of jallib tree

# --- input -----------------------------------------------

picdir        = os.path.join(mplabxbase, "crownking.edc.jar/content/edc")   # dir(s) with pic files
devspecfile   = os.path.join(jallibbase, "tools/devicespecific.json")       # additional PIC properties
pinmapfile    = os.path.join(jallibbase, "tools/pinmap_pinsuffix.json")     # pin aliases
datasheetfile = os.path.join(jallibbase, "tools/datasheet.list")            # list of datasheets

# --- output ----------------------------------------------

dstdir      = "./test"                                         # dest. of generated device files

# --- global constants and variables ----------------------

cfgvar     = {}                                                # PIC properties on picname
devspec    = {}                                                # PIC specific info on picname
pinmap     = {}                                                # pin mapping (pin aliases)
datasheet  = {}                                                # datasheet + suffix on DS number
fusedefosc = {}                                                # .pic -> .jal keyword mapping

sharedmem  = []                                                # begin,end allocatable shared mem


# ---------------------------------------------------------
# Add copyright, etc to header in device files and chipdef.jallib
# Input:   filespec of destination file
# Returns: nothing
# ---------------------------------------------------------
def list_copyright(fp):
   fp.write("--\n")
   fp.write("-- Author: " + scriptauthor + ", Copyright (c) 2008..2014, " +
                          "all rights reserved.\n")
   fp.write("--\n")
   fp.write("-- Adapted-by: N/A (generated file, do not change!)\n")
   fp.write("--\n")
   fp.write("-- Revision: $Revision$\n")
   fp.write("--\n")
   fp.write("-- Compiler: " + compilerversion + "\n")
   fp.write("--\n")
   fp.write("-- This file is part of jallib (http://jallib.googlecode.com)\n")
   fp.write("-- Released under the ZLIB license " +
                " (http://www.opensource.org/licenses/zlib-license.html)\n")
   fp.write("--\n")


# ---------------------------------------------------------
# List common constants in ChipDef.Jal
# Input: filespec of destination file
# Returns: nothing
# ---------------------------------------------------------
def list_chipdef_header(fp):
   list_separator(fp)
   fp.write("-- Title: Common Jallib include file for device files\n")
   list_copyright(fp)                                      # insert copyright and other info
   fp.write("-- Sources:\n")
   fp.write("--\n")
   fp.write("-- Description:\n")
   fp.write("--    Common Jallib include files for device files\n")
   fp.write("--\n")
   fp.write("-- Notes:\n")
   fp.write("--    - File creation date/time: " + time.ctime() + "\n")
   fp.write("--    - This file is generated by <pic2jal.py> script.\n")
   fp.write("--\n")
   list_separator(fp)
   fp.write("--\n")
   fp.write("-- JalV2 compiler required constants\n")
   fp.write("--\n")
   fp.write("const       PIC_12            = 1\n")
   fp.write("const       PIC_14            = 2\n")
   fp.write("const       PIC_16            = 3\n")
   fp.write("const       SX_12             = 4\n")
   fp.write("const       PIC_14H           = 5\n")
   fp.write("--\n")
   fp.write("const bit   PJAL              = 1\n")
   fp.write("--\n")
   fp.write("const byte  W                 = 0\n")
   fp.write("const byte  F                 = 1\n")
   fp.write("--\n")
   fp.write("include  constants_jallib                     -- common Jallib library constants\n")
   fp.write("--\n")
   list_separator(fp)
   fp.write("--\n")
   fp.write("-- A value assigned to const 'target_chip' by\n")
   fp.write("--    'pragma target chip' in device files\n")
   fp.write("-- can be used for conditional compilation, for example:\n")
   fp.write("--    if (target_chip == PIC_16F88) then\n")
   fp.write("--      ....                                  -- for 16F88 only\n")
   fp.write("--    endif\n")
   fp.write("--\n")


# ---------------------------------------------------------
# Generate common header
# Input:    - picname
#           - destination file
# Returns: nothing
# Notes:   - Shared memory for _pic_accum and _pic_isr_w is allocated:
#            - for core 12, 14 and 14H from high to low address
#            - for core 16 from low to high address
# ---------------------------------------------------------
def list_devicefile_header(fp, picname):
   list_separator(fp)
   fp.write("-- Title: JalV2 device include file for " + picname + "\n")
   list_copyright(fp)
   fp.write("-- Description:\n")
   fp.write("--    Device include file for PIC " + picname + ", containing:\n")
   fp.write("--    - Declaration of ports and pins of the chip.\n")
   if cfgvar["haslat"] == True:
      fp.write("--    - Procedures to force the use of the LATx register\n")
      fp.write("--      for output when PORTx or pin_xy is addressed.\n")
   else:
      fp.write("--    - Procedures for shadowing of ports and pins\n")
      fp.write("--      to circumvent the read-modify-write problem.\n")
   fp.write("--    - Symbolic definitions for configuration bits (fuses)\n")
   fp.write("--    - Some device dependent procedures for common\n")
   fp.write("--      operations, like:\n")
   fp.write("--      . enable_digital_io()\n")
   fp.write("--\n")
   fp.write("-- Sources:\n")
   fp.write("--  - {MPLAB-X " + mplabxversion[0:1] + "." + mplabxversion[1:3] + "/}" +
            "crownking.edc.jar/content/edc/../" + "PIC" + picname.upper() + ".PIC\n")
   fp.write("--\n")
   fp.write("-- Notes:\n")
   fp.write("--  - File creation date/time: " + time.ctime() + "\n")
   fp.write("--  - This file is generated by <pic2jal.py> script!\n")
   fp.write("--\n")
   list_separator(fp)
   fp.write("--\n")
   fp.write("const  word  DEVICE_ID   = " + cfgvar["devid"] + "            -- ID for PIC programmer\n")
   fp.write("const  word  CHIP_ID     = " + cfgvar["procid"] + "            -- ID in chipdef_jallib\n")
   fp.write("const  byte  PICTYPE[]   = \"" + picname.upper() + "\"\n")
   picdata = dict(devspec[picname.upper()].items())
   fp.write("const  byte  DATASHEET[] = \"" + datasheet[picdata["DATASHEET"]] + "\"\n")
   if "dsid" in cfgvar:
      dsid1 = cfgvar["dsid"]
      if (dsid1 != "0") & (dsid1 != ""):
         dsid2 = dsid1[0:1] + "000" + dsid1[1:]
         if (dsid1 != picdata["DATASHEET"]) & (dsid2 != picdata["DATASHEET"]):
            print "   Possibly conflicting datasheet numbers:"
            print "   .pic file: ", cfgvar["dsid"], ", devicespecific: ", picdata["DATASHEET"]
   if picdata["PGMSPEC"] != "-":
      fp.write("const  byte  PGMSPEC[]   = \"" + datasheet[picdata["PGMSPEC"]] + "\"\n")
   fp.write("--\n")
   fp.write("-- Vdd Range: " + cfgvar["vddmin"] + '-' + cfgvar["vddmax"] +
                " Nominal: " + cfgvar["vddnom"] + "\n")
   fp.write("-- Vpp Range: " + cfgvar["vppmin"] + '-' + cfgvar["vppmax"] +
                " Default: " + cfgvar["vppdef"] + "\n")
   fp.write("--\n")
   list_separator(fp)
   fp.write("--\n")
   fp.write("include chipdef_jallib                  -- common constants\n")
   fp.write("--\n")
   fp.write("pragma  target  cpu    PIC_" + cfgvar["core"] + "           -- (banks = %d)\n" % cfgvar["numbanks"])
   fp.write("pragma  target  chip   " + picname.upper() + "\n")
   fp.write("pragma  target  bank   0x%04x\n" % cfgvar["banksize"])
   if cfgvar["pagesize"] > 0:
      fp.write("pragma  target  page   0x%04x\n" % cfgvar["pagesize"])
   fp.write("pragma  stack          %d\n" % cfgvar["hwstack"])
   if cfgvar["osccal"] > 0:
      fp.write("pragma  code           %d" % (cfgvar["codesize"] - 1) + " "*15 + "-- (excl. high memory word)\n")
   else:
      fp.write("pragma  code           %d\n" % cfgvar["codesize"])
   if "eeaddr" in cfgvar:
      fp.write("pragma  eeprom         0x%x,%d\n" % (cfgvar["eeaddr"], cfgvar["eesize"]))
   if "idaddr" in cfgvar:
      fp.write("pragma  ID             0x%x,%d\n" % (cfgvar["idaddr"], cfgvar["idsize"]))

   if "DATA" in picdata:
      fp.write("pragma  data           " + picdata["DATA"] + "\n")
      print "   pragma data overruled by specification in devicespecific"
   else:
      for i in range(0, len(cfgvar["datarange"]), 5):       # max 5 ranges per line
         y = cfgvar["datarange"][i : i+5]
         fp.write("pragma  data           " + ",".join(("0x%X-0x%X" % (r[0], r[1]-1)) for r in y) + "\n")

   fp.write("pragma  shared         ")
   global sharedmem
   if "SHARED" in picdata:
      fp.write(picdata["SHARED"] + "\n")
      print "   pragma shared overruled by specification in devicespecific"
      x = picdata["SHARED"].split("-", 1)
      sharedmem.append(eval(x[0]))
      sharedmem.append(eval(x[1]))
   else:
      if cfgvar["core"] == '16':                            # add high range of access bank
         fp.write("0x%X-0x%X,0xF%X-0xFFF\n" %  \
             (cfgvar["sharedrange"][0],        \
             (cfgvar["sharedrange"][-1] - 1),  \
              cfgvar["accessbanksplitoffset"]) )
      elif cfgvar["core"] == "14H":                         # add core register memory
         fp.write("0x00-0x0B,0x%X-0x%X\n" %    \
             (cfgvar["sharedrange"][0],        \
             (cfgvar["sharedrange"][-1] - 1)))
      else:
         fp.write("0x%X-0x%X\n" %              \
             (cfgvar["sharedrange"][0],        \
              cfgvar["sharedrange"][-1] - 1))
      sharedmem = list(cfgvar["sharedrange"])               # take a workcopy for allocation
      sharedmem[1] = sharedmem[1]  - 1                      # high address
   fp.write("--\n")

   sharedmem_avail = sharedmem[1] - sharedmem[0]
   if (cfgvar["core"] == "12") | (cfgvar["core"] == "14"):
      if sharedmem_avail < 2:
         print "   At least 2 bytes of shared memory required! Found:", sharedmem_avail
      else:
         fp.write("var volatile byte _pic_accum at 0x%0X" % sharedmem[1] + "      -- (compiler)\n")
         sharedmem[1] = sharedmem[1] - 1
         fp.write("var volatile byte _pic_isr_w at 0x%0X" % sharedmem[1] + "      -- (compiler)\n")
         sharedmem[1] = sharedmem[1] - 1
   else:
      if sharedmem_avail < 1:
         print "   At least 1 byte of shared memory required! Found:", sharedmem_avail
      elif (cfgvar["core"] == "14H"):
         fp.write("var volatile byte _pic_accum at 0x%0X" % sharedmem[1] + "      -- (compiler)\n")
         sharedmem[1] = sharedmem[1] - 1
      else:                                                 # 16-bits core
         fp.write("var volatile byte _pic_accum at 0x%0X" % sharedmem[0] + "      -- (compiler)\n")
         sharedmem[0] = sharedmem[0] + 1
   fp.write("--\n")


# ---------------------------------------------------------
# Generate configuration memory declaration and defaults
# Input:    - picname
#           - output file
# Output:   part of device files
# Returns:  (nothing)
# ---------------------------------------------------------
def list_fuses(fp, picname):
   fp.write("const word   _FUSES_CT             = " + "%d" % cfgvar["fusesize"] + "\n")
   if cfgvar["fusesize"] == 1:                    #  single word: only with baseline/midrange
      fp.write("const word   _FUSE_BASE            = 0x%X" % cfgvar["fuseaddr"] + "\n")
      fp.write("const word   _FUSES                = 0x%X" % 127 + "\n")
   else:
      if cfgvar["core"] != "16":
         fp.write("const word   _FUSE_BASE[_FUSES_CT] = { 0x%X" % cfgvar["fuseaddr"])
      else:
         fp.write("const byte*3 _FUSE_BASE[_FUSES_CT] = { 0x%X" % cfgvar["fuseaddr"])
      for i in range(cfgvar["fusesize"] - 1):
         fp.write(",\n" + " "*39 + "0x%X" % (cfgvar["fuseaddr"] + i + 1))
      fp.write(" }\n")
      if cfgvar["core"] != "16":
         fp.write("const word   _FUSES[_FUSES_CT]     = { 0x%04X," % 0 +
                  " "*10 + "-- CONFIG1\n")
         for i in range(cfgvar["fusesize"] - 2):
            fp.write(" "*39 + "0x%04X" % (i + 1) + "," +
                     " "*10 + "-- CONFIG" + "%d" % (i+2) + "\n")
         fp.write(" "*39 + "0x%04X" % (cfgvar["fusesize"] - 1) + " }" +
                  " "*9 + "-- CONFIG" + "%d\n" % (cfgvar["fusesize"]))
      else:
         fp.write("const byte   _FUSES[_FUSES_CT]     = { 0x%02X," % 0 +
                  " "*10 + "-- CONFIG1L" + "\n")
         for i in range(cfgvar["fusesize"] - 2):
            fp.write(" "*39 + "0x%02X," % (i + 1) +
                     " "*10 + "-- CONFIG" + "%d" % ((i+3)/2) + "HL"[i%2] + "\n")
         fp.write(" "*39 + "0x%02X }" % (cfgvar["fusesize"] - 1) +
                  " "*9 + "-- CONFIG" + "%d" % (cfgvar["fusesize"]/2) + "H\n")
   fp.write("--\n")



# ---------------------------------------------------------
# Generate oscillator calibration instructions
# Input:    - picname
#           - output file
# Output:   part of device files
# Returns:  (nothing)
# Notes:    - Only for PICs with OSCCAL
#           - Only safe for 12-bits core
#           - Code for 14-bits core is present but disabled
# ---------------------------------------------------------
def list_osccal(fp, picname):

   if cfgvar["osccal"] > 0:                                 # PIC has OSCCAL register
      if cfgvar["core"] == '12':                            # 10F2xx, some 12F5xx, 16f5xx
         fp.write("var volatile byte  __osccal  at  0x%x" % cfgvar["osccal"] + "\n")
         if cfgvar["numbanks"] > 1:
            fp.write("var volatile byte  __fsr     at  0x%x" % cfgvar["fsr"] + "\n")
            fp.write("asm          bcf   __fsr,5                  -- select bank 0\n")
            if cfgvar["numbanks"] > 2:
               fp.write("asm          bcf   __fsr,6                  --   \"     \"\n")
         fp.write("asm          movwf __osccal                 -- calibrate INTOSC\n")
         fp.write("--\n")
"""
      elif cfgvar["core"] == '14':                          # 12F629/675, 16F630/676
         fp.write("var  volatile byte  __osccal  at  0x%x" % cfgvar["osccal"] + "\n")
         fp.write("asm  page    call   0x%x" % (cfgvar["codesize"]-1) + " "*15 + "-- fetch calibration value\n")
         fp.write("asm  bank    movwf  __osccal            -- calibrate INTOSC\n")
         fp.write("--\n")
"""


# ---------------------------------------------------------
# Generate special purpose registers, pins, etc.
# Input:    - picname
#           - output file
# Output:   part of device files
# Returns:  (nothing)
# ---------------------------------------------------------
def list_registers(fp, root):
   sfrdatasectors = root.getElementsByTagName("edc:SFRDataSector")
   for sfrdatasector in sfrdatasectors:
      sfraddr = eval(sfrdatasector.getAttribute("edc:beginaddr"))    # current SFRaddr
      if sfrdatasector.hasChildNodes():
         child = sfrdatasector.firstChild
         sfraddr = calc_sfraddr(child, sfraddr)
         while child.nextSibling:
            child = child.nextSibling
            if child.nodeType == Node.ELEMENT_NODE:
               if child.hasAttribute("edc:cname"):
                  if child.nodeName == "edc:SFRDef":
                     list_sfr(fp, child, sfraddr)
                  elif child.nodeName == "edc:JoinedSFRDef":
                     childname = child.getAttribute("edc:cname")
                     childwidth = (eval(child.getAttribute("edc:nzwidth")) + 7) / 8
                     list_separator(fp)
                     list_variable(fp, childname, childwidth, sfraddr)
                     gchild = child.firstChild
                     sfraddr_g = sfraddr
                     if gchild.nodeName == "edc:SFRDef":
                        list_sfr(fp, gchild, sfraddr)
                        sfraddr_g = sfraddr_g + 1
                     while gchild.nextSibling:
                        gchild = gchild.nextSibling
                        if gchild.nodeName == "edc:SFRDef":
                           list_sfr(fp, gchild, sfraddr_g)
                           sfraddr_g = sfraddr_g + 1
            sfraddr = calc_sfraddr(child, sfraddr)                   # next adjust


# ---------------------------------------------------------
# Generate declaration of a single register (incl subfields)
# Input:    - output file
#           - SFRDef node
#           - current SFR addr
# Output:   part of device files
# Returns:  (nothing)
# ---------------------------------------------------------
def list_sfr(fp, sfr, addr):
   list_separator(fp)
   sfrname = sfr.getAttribute("edc:cname")
   list_variable(fp, sfrname, 1, addr)
   modelist = sfr.getElementsByTagName("edc:SFRMode")
   for mode in modelist:
      modeid = mode.getAttribute("edc:id")
      if modeid.startswith("DS.") | modeid.startswith("LT."):
         offset = 0
         child = mode.firstChild
         if child.nodeName == "edc.SFRFieldDef":
            fp.write("--      " + child.getAttribute("edc.cname") + "\n")
            offset = offset + eval(child.getAttribute("edc:nzwidth"))
         while child.nextSibling:
            child = child.nextSibling
            if child.nodeName == "edc:SFRFieldDef":
               fp.write("--      " + child.getAttribute("edc:cname") + \
                        "at 0x%X : %d\n" % (addr, offset))
               offset = offset + eval(child.getAttribute("edc:nzwidth"))



# -------------------------------------------------------
# Generate a separator line
# arguments: file
# returns:   nothing
# -------------------------------------------------------
def list_separator(fp):
   fp.write("-- " + "-"*65 + "\n")


# -------------------------------------------------------
# Generated a line with a volatile variable
# arguments: - type (byte, word, etc.)
#            - name
#            - address (decimal or string)
# returns:   nothing
# -------------------------------------------------------
def list_variable(fp, var, width, addr):
   if width == 1:
      type = "byte"
   elif width == 2:
      type = "word"
   else:
      type = "byte%d" % width
   fp.write("var volatile %-6s %-25s at { %03X }\n" % (type, var, addr))


# ---------------------------------------------------------
# Generate instructions to set all I/O to digital mode
# Input:    - picname
#           - output file
# Output:   part of device files
# Returns:  (nothing)
# ---------------------------------------------------------
def list_digital_io(fp, picname):
   fp.write("--\n")
   list_separator(fp)
   fp.write("-- Procedures to disable analog functions\n")
   list_separator(fp)


# ---------------------------------------------------------
# Generate miscellaneous information
# Input:    - picname
#           - output file
# Output:   part of device files
# Returns:  (nothing)
# ---------------------------------------------------------
def list_miscellaneous(fp, picname):

   # todo: PPS group

   fp.write("--\n")
   if (sharedmem[1] >= sharedmem[0]):
      fp.write("-- Free shared memory: 0x%X" % sharedmem[0])
      if (sharedmem[1] > sharedmem[0]):
         fp.write("-0x%X" % sharedmem[1])
      fp.write("\n")
   else:
      fp.write("-- No free shared memory!\n")
   fp.write("--\n")


# ---------------------------------------------------------
# Generate fuse_def statements
# Input:    - picname
#           - output file
# Output:   part of device files
# Returns:  (nothing)
# ---------------------------------------------------------
def list_fuse_defs(fp, picname):
   fp.write("--\n")
   list_separator(fp)
   fp.write("-- Fuse definitons\n")
   list_separator(fp)
   return 0


# -----------------------------------------------------
# Initialize dictionary 'fusedefosc' (mapping .pic -> .jal keyword)
# Input:   nothing
# Output:  fusedefosc dictionary initialized
# Returns: nothing
# -----------------------------------------------------
def init_fusedefosc():

   global fusedefosc

   fusedefosc = {"EC"             : "EC_CLKOUT",              # comment
                 "EC1"            : "ECL_NOCLKOUT",
                 "EC1IO"          : "ECL_CLKOUT",
                 "EC2"            : "ECM_NOCLKOUT",
                 "EC2IO"          : "ECM_CLKOUT",
                 "EC3"            : "ECH_NOCLKOUT",
                 "EC3IO"          : "ECH_CLKOUT",
                 "ECCLK"          : "EC_CLKOUT",
                 "ECCLKOUTH"      : "ECH_CLKOUT",
                 "ECCLKOUTL"      : "ECL_CLKOUT",
                 "ECCLKOUTM"      : "ECM_CLKOUT",
                 "ECH"            : "ECH_NOCLKOUT",
                 "ECHCLKO"        : "ECH_CLKOUT",
                 "ECHIO"          : "ECH_NOCLKOUT",
                 "ECHP"           : "ECH_CLKOUT",
                 "ECHPIO6"        : "ECH_NOCLKOUT",
                 "ECIO"           : "EC_NOCLKOUT",
                 "ECIO6"          : "EC_NOCLKOUT",
                 "ECIOPLL"        : "EC_NOCLKOUT_PLL_HW",
                 "ECIOSWPLL"      : "EC_NOCLKOUT_PLL_SW",
                 "ECIO_EC"        : "EC_NOCLKOUT",
                 "ECL"            : "ECL_NOCLKOUT",
                 "ECLCLKO"        : "ECL_CLKOUT",
                 "ECLIO"          : "ECL_NOCLKOUT",
                 "ECLP"           : "ECL_CLKOUT",
                 "ECLPIO6"        : "ECL_NOCLKOUT",
                 "ECM"            : "ECM_NOCLKOUT",
                 "ECMCLKO"        : "ECM_CLKOUT",
                 "ECMIO"          : "ECM_NOCLKOUT",
                 "ECMP"           : "ECM_CLKOUT",
                 "ECMPIO6"        : "ECM_NOCLKOUT",
                 "ECPLL"          : "EC_CLKOUT_PLL",
                 "ECPLLIO_EC"     : "EC_NOCLKOUT_PLL",
                 "ECPLL_EC"       : "EC_CLKOUT_PLL",
                 "EC_EC"          : "EC_CLKOUT",
                 "EC_OSC"         : "EC_NOCLKOUT",
                 "ERC"            : "RC_NOCLKOUT",
                 "ERCCLKOUT"      : "RC_CLKOUT",
                 "ERCLK"          : "RC_CLKOUT",
                 "ERIO"           : "RC_NOCLKOUT",
                 "EXTRC"          : "RC_NOCLKOUT",
                 "EXTRCCLK"       : "RC_CLKOUT",
                 "EXTRCIO"        : "RC_NOCLKOUT",
                 "EXTRC_CLKOUT"   : "RC_CLKOUT",
                 "EXTRC_CLKOUTEN" : "RC_CLKOUT",
                 "EXTRC_IO"       : "RC_NOCLKOUT",
                 "EXTRC_NOCLKOUT" : "RC_NOCLKOUT",
                 "EXTRC_RB4"      : "RC_NOCLKOUT",
                 "EXTRC_RB4EN"    : "RC_NOCLKOUT",
                 "FRC"            : "INTOSC_NOCLKOUT",
                 "FRC500KHZ"      : "INTOSC_500KHZ",
                 "FRCDIV"         : "INTOSC_DIV",
                 "FRCPLL"         : "INTOSC_NOCLKOUT_PLL",
                 "HS"             : "HS",
                 "HS1"            : "HSM",
                 "HS2"            : "HSH",
                 "HSH"            : "HSH",
                 "HSHP"           : "HSH",
                 "HSM"            : "HSM",
                 "HSMP"           : "HSM",
                 "HSPLL"          : "HS_PLL",
                 "HSPLL_HS"       : "HS_PLL",
                 "HSSWPLL"        : "HS_PLL_SW",
                 "HS_OSC"         : "HS",
                 "INT"            : "INTOSC_NOCLKOUT",
                 "INTIO1"         : "INTOSC_CLKOUT",
                 "INTIO2"         : "INTOSC_NOCLKOUT",
                 "INTIO67"        : "INTOSC_NOCLKOUT",
                 "INTIO7"         : "INTOSC_CLKOUT",
                 "INTOSC"         : "INTOSC_NOCLKOUT",
                 "INTOSCCLK"      : "INTOSC_CLKOUT",
                 "INTOSCCLKO"     : "INTOSC_CLKOUT",
                 "INTOSCIO"       : "INTOSC_NOCLKOUT",
                 "INTOSCIO_EC"    : "INTOSC_NOCLKOUT_USB_EC",
                 "INTOSCO"        : "INTOSC_CLKOUT",
                 "INTOSCPLL"      : "INTOSC_NOCLKOUT_PLL",
                 "INTOSCPLLO"     : "INTOSC_CLKOUT_PLL",
                 "INTOSC_EC"      : "INTOSC_CLKOUT_USB_EC",
                 "INTOSC_HS"      : "INTOSC_NOCLKOUT_USB_HS",
                 "INTOSC_XT"      : "INTOSC_NOCLKOUT_USB_XT",
                 "INTRC"          : "INTOSC_NOCLKOUT",
                 "INTRCCLK"       : "INTOSC_CLKOUT",
                 "INTRCIO"        : "INTOSC_NOCLKOUT",
                 "INTRC_CLKOUT"   : "INTOSC_CLKOUT",
                 "INTRC_CLKOUTEN" : "INTOSC_CLKOUT",
                 "INTRC_IO"       : "INTOSC_NOCLKOUT",
                 "INTRC_NOCLKOUT" : "INTOSC_NOCLKOUT",
                 "INTRC_RB4"      : "INTOSC_NOCLKOUT",
                 "INTRC_RB4EN"    : "INTOSC_NOCLKOUT",
                 "IRC"            : "INTOSC_CLKOUT",
                 "IRCCLKOUT"      : "INTOSC_CLKOUT",
                 "IRCIO"          : "INTOSC_NOCLKOUT",
                 "IRCIO67"        : "INTOSC_NOCLKOUT",
                 "IRCIO7"         : "INTOSC_CLKOUT",
                 "LP"             : "LP",
                 "LPRC"           : "INTOSC_LP",
                 "LP_OSC"         : "LP",
                 "PRI"            : "PRI",
                 "PRIPLL"         : "PRI_PLL",
                 "RC"             : "RC_CLKOUT",
                 "RC1"            : "RC_CLKOUT",
                 "RC2"            : "RC_CLKOUT",
                 "RCCLKO"         : "RC_CLKOUT",
                 "RCIO"           : "RC_NOCLKOUT",
                 "RCIO6"          : "RC_NOCLKOUT",
                 "SOSC"           : "SEC",
                 "XT"             : "XT",
                 "XTPLL_XT"       : "XT_PLL",
                 "XT_OSC"         : "XT",
                 "XT_XT"          : "XT"}


# ---------------------------------------------------------
# Calculate next SFRaddr with current Node
# Input:    - Node
#           - current SFR address (decimal)
# Output:   (nothing)
# Returns:  new SFR address (decimal)
# ---------------------------------------------------------
def calc_sfraddr(child, sfraddr):
   if child.nodeName == "edc:SFRDef":
      sfraddr = sfraddr + 1
   elif child.nodeName == "edc:AdjustPoint":
      sfraddr = sfraddr + eval(child.getAttribute("edc:offset"))
   elif child.nodeName == "edc:Mirror":
      sfraddr = sfraddr + eval(child.getAttribute("edc:nzsize"))
   elif child.nodeName == "edc:MuxedSFRDef":
      sfraddr = sfraddr + (eval(child.getAttribute("edc:nzwidth")) + 7) / 8    # bits -> bytes, rounded
   elif child.nodeName == "edc:JoinedSFRDef":
      sfraddr = sfraddr + (eval(child.getAttribute("edc:nzwidth")) + 7) / 8    # bits -> bytes, rounded
   return sfraddr


# ---------------------------------------------------------
# Compact address ranges
# Input:    list of pairs of address ranges
# Output:   (nothing)
# Returns   compacted list of pairs of address ranges
# ---------------------------------------------------------
def compact_address_range(r):
   x = list(r[:])
   x.sort()
   j = 0
   y = []
   y.append(list(x[0]))
   for i in range(len(x) - 1):
      if x[i][-1] == x[i+1][0]:
         y[j][-1] = x[i+1][-1]
      else:
         y.append(list(x[i+1]))
         j = j + 1
   return y


# ---------------------------------------------------------
# Collect PIC various configuration data
# Input:    'pic' list
# Output:   fills 'cfgvar' dictionary
# Returns:  (nothing)
# Notes:    - JalV2 compiler supports for 12- and 14-bits core only 4 memory banks
# ---------------------------------------------------------
def collect_config_info(root):

   global cfgvar

   cfgvar.clear()                                                 # empty dict. of config variables
   cfgvar["devid"] = "0x0000"                                     # no devID
   cfgvar["haslat"] = False                                       # no LATx register
   cfgvar["numbanks"] = 1                                         # # mem banks
   cfgvar["osccal"] = 0                                           # no OSCCAL

   pic = root.getElementsByTagName("edc:PIC")
   cfgvar["arch"]   = pic[0].getAttribute("edc:arch")
   if cfgvar["arch"]    == "16c5x":
      cfgvar["core"]     = "12"
      cfgvar["maxram"]   = 128
      cfgvar["banksize"] = 32
      cfgvar["pagesize"] = 512
   elif cfgvar["arch"]  == "16xxxx":
      cfgvar["core"]     = "14"
      cfgvar["maxram"]   = 512
      cfgvar["banksize"] = 128
      cfgvar["pagesize"] = 2048
   elif cfgvar["arch"]  == "16Exxx":
      cfgvar["core"]     = "14H"
      cfgvar["maxram"]   =  4096
      cfgvar["banksize"] = 128
      cfgvar["pagesize"] = 2048
   elif cfgvar["arch"]  == "18xxxx":
      cfgvar["core"]     = "16"
      cfgvar["maxram"]   = 4096
      cfgvar["banksize"] = 256
      cfgvar["pagesize"] = 0                             # no pages!
   else:
      print "   undetermined core : ", cfgvar["arch"]
   cfgvar["procid"] = pic[0].getAttribute("edc:procid").upper()      # first (only) 'PIC' node
   cfgvar["dsid"]   = pic[0].getAttribute("edc:dsid")

   power = root.getElementsByTagName("edc:Power")
   vpp = power[0].getElementsByTagName("edc:VPP")
   cfgvar["vppdef"] = vpp[0].getAttribute("edc:defaultvoltage")
   cfgvar["vppmax"] = vpp[0].getAttribute("edc:maxvoltage")
   cfgvar["vppmin"] = vpp[0].getAttribute("edc:minvoltage")
   vdd = power[0].getElementsByTagName("edc:VDD")
   cfgvar["vddnom"] = vdd[0].getAttribute("edc:nominalvoltage")
   cfgvar["vddmax"] = vdd[0].getAttribute("edc:maxvoltage")
   cfgvar["vddmin"] = vdd[0].getAttribute("edc:minvoltage")

   arch = root.getElementsByTagName("edc:ArchDef")
   memtraits = arch[0].getElementsByTagName("edc:MemTraits")
   if memtraits[0].hasAttribute("bankcount"):
      cfgvar["numbanks"] = eval(memtraits[0].getAttribute("edc:bankcount"))
   cfgvar["hwstack"]  = eval(memtraits[0].getAttribute("edc:hwstackdepth"))

   pgmspace = root.getElementsByTagName("edc:ProgramSpace")
   codesectors = pgmspace[0].getElementsByTagName("edc:CodeSector")
   cfgvar["codesize"]  = eval(codesectors[0].getAttribute("edc:endaddr")) - \
                         eval(codesectors[0].getAttribute("edc:beginaddr"))
   useridsectors = pgmspace[0].getElementsByTagName("edc:UserIDSector")
   if len(useridsectors) > 0:
      cfgvar["idaddr"] = eval(useridsectors[0].getAttribute("edc:beginaddr"))
      cfgvar["idsize"] = eval(useridsectors[0].getAttribute("edc:endaddr")) - \
                         eval(useridsectors[0].getAttribute("edc:beginaddr"))
   eedatasectors = pgmspace[0].getElementsByTagName("edc:EEDataSector")
   if len(eedatasectors) > 0:
      cfgvar["eeaddr"] = eval(eedatasectors[0].getAttribute("edc:beginaddr"))
      cfgvar["eesize"] = eval(eedatasectors[0].getAttribute("edc:endaddr")) - \
                         eval(eedatasectors[0].getAttribute("edc:beginaddr"))
   flashdatasectors = pgmspace[0].getElementsByTagName("edc:FlashDataSector")
   if len(flashdatasectors) > 0:
      cfgvar["eeaddr"] = eval(flashdatasectors[0].getAttribute("edc:beginaddr"))
      cfgvar["eesize"] = eval(flashdatasectors[0].getAttribute("edc:endaddr")) - \
                         eval(flashdatasectors[0].getAttribute("edc:beginaddr"))
   devidsectors = pgmspace[0].getElementsByTagName("edc:DeviceIDSector")
   if len(devidsectors) > 0:
      cfgvar["devid"] = devidsectors[0].getAttribute("edc:value")
   configfusesectors = pgmspace[0].getElementsByTagName("edc:ConfigFuseSector")
   if len(configfusesectors) > 0:
      cfgvar["fuseaddr"] = eval(configfusesectors[0].getAttribute("edc:beginaddr"))
      cfgvar["fusesize"] = eval(configfusesectors[0].getAttribute("edc:endaddr")) - \
                           eval(configfusesectors[0].getAttribute("edc:beginaddr"))
   wormholesectors = pgmspace[0].getElementsByTagName("edc:WORMHoleSector")
   if len(wormholesectors) > 0:
      cfgvar["fuseaddr"] = eval(wormholesectors[0].getAttribute("edc:beginaddr"))
      cfgvar["fusesize"] = eval(wormholesectors[0].getAttribute("edc:endaddr")) - \
                           eval(wormholesectors[0].getAttribute("edc:beginaddr"))


   sfraddr = 0                                                    # startvalue of SFR reg addr.
   sfrdatasectors = root.getElementsByTagName("edc:SFRDataSector")
   for sfrdatasector in sfrdatasectors:
      if sfrdatasector.hasAttribute("edc:bank"):                     # count numbanks
         cfgvar["numbanks"] = max(eval(sfrdatasector.getAttribute("edc:bank")) + 1, cfgvar["numbanks"])
      sfraddr = eval(sfrdatasector.getAttribute("edc:beginaddr"))    # current SFRaddr
      if sfrdatasector.hasChildNodes():
         child = sfrdatasector.firstChild
         sfraddr = calc_sfraddr(child, sfraddr)                         # next SFRaddr
         while child.nextSibling:
            child = child.nextSibling
            if child.nodeType == Node.ELEMENT_NODE:
               if child.hasAttribute("edc:cname"):
                  childname = child.getAttribute("edc:cname")
                  if childname == "OSCCAL":
                     cfgvar["osccal"] = sfraddr
                  elif childname == "FSR":
                     cfgvar["fsr"] = sfraddr
                  elif childname.startswith("LAT") & (len(childname) == 4) & \
                       (childname[-1] >= "A") & (childname[-1] <= "L"):
                     cfgvar["haslat"] = True
               sfraddr = calc_sfraddr(child, sfraddr)                   # next adjust

   data = []                                                         # intermediate result
   gprdatasectors = root.getElementsByTagName("edc:GPRDataSector")
   for gprdatasector in gprdatasectors:
      if gprdatasector.hasAttribute("edc:bank"):                     # count numbanks
         cfgvar["numbanks"] = max(eval(gprdatasector.getAttribute("edc:bank")) + 1, cfgvar["numbanks"])
      parent = gprdatasector.parentNode
      if parent.nodeName != "edc:ExtendedModeOnly":
         if gprdatasector.hasAttribute("edc:shadowidref") == False:
            gpraddr = eval(gprdatasector.getAttribute("edc:beginaddr"))
            gprlast = eval(gprdatasector.getAttribute("edc:endaddr"))
            data.append((gpraddr,gprlast))
            if (gprdatasector.getAttribute("edc:regionid") == "gprnobnk")  | \
               (gprdatasector.getAttribute("edc:regionid") == "gprnobank") | \
               (gprdatasector.getAttribute("edc:regionid") == "accessram"):
               cfgvar["sharedrange"] = (gpraddr, gprlast)
            if (gpraddr == 0):
               cfgvar["accessbanksplitoffset"] = gprlast
   dprdatasectors = root.getElementsByTagName("edc:DPRDataSector")
   for dprdatasector in dprdatasectors:
      if dprdatasector.hasAttribute("edc:bank"):                     # count numbanks
         cfgvar["numbanks"] = max(eval(dprdatasector.getAttribute("edc:bank")) + 1, cfgvar["numbanks"])
      parent = dprdatasector.parentNode
      if parent.nodeName != "edc:ExtendedModeOnly":
         if dprdatasector.hasAttribute("edc:shadowidref") == False:
            dpraddr = eval(dprdatasector.getAttribute("edc:beginaddr"))
            dprlast = eval(dprdatasector.getAttribute("edc:endaddr"))
            data.append((dpraddr,dprlast))
            if (dprdatasector.getAttribute("edc:regionid") == "dprnobnk")  | \
               (dprdatasector.getAttribute("edc:regionid") == "dprnobank") | \
               (dprdatasector.getAttribute("edc:regionid") == "accessram"):
               cfgvar["sharedrange"] = (dpraddr, dprlast)
            if (dpraddr == 0):
               cfgvar["accessbanksplitoffset"] = dprlast
   cfgvar["datarange"] = compact_address_range(data)


   if ((cfgvar["core"] == '12') | (cfgvar["core"] == '14')) & (cfgvar["numbanks"] > 4):
      cfgvar["numbanks"] = 4                                   # max 4 banks for core 12, 14

   if "sharedrange" not in cfgvar:                             # no shared range found
      if len(cfgvar["datarange"]) == 1:                        # single data bank
         cfgvar["sharedrange"] = cfgvar["datarange"][0]        # all data is shared
      else:
         print "   Multiple banks, but no shared data!"


# ---------------------------------------------------------
# Read devicespecific.json
# Input:    file with datasheet info
# Output:   fills 'devspec' dictionary
# Returns:  (nothing)
# ---------------------------------------------------------
def read_devspec_file():
   global devspec                                              # global variable
   fp = open(devspecfile, "r")
   devspec = json.load(fp)                                     # obtain contents devicespecific
   fp.close()


# ---------------------------------------------------------
# Read pinmap file pinmape_pinsuffix.json
# Input:    file with datasheet info
# Output:   fills 'pinmap' dictionary
# Returns:  (nothing)
# ---------------------------------------------------------
def read_pinmap_file():
   global pinmap                                               # global variable
   fp = open(pinmapfile, "r")
   pinmap = json.load(fp)                                      # obtain contents devicespecific
   fp.close()


# ---------------------------------------------------------
# Read datasheet.list
# Input:    none
# Output:   fills 'datasheet' dictionary
# Returns:  (nothing)
# ---------------------------------------------------------
def read_datasheet_file():
   global datasheet
   fp = open(datasheetfile, "r")
   for ln in fp:
      ds = ln.split(" ",1)[0]                                  # datasheet number+suffix
      datasheet[ds[:-1]] = ds                                  # number -> number + sufix
   fp.close()


# ---------------------------------------------------------
# Convert an MPLAB-X .pic file to a JalV2 device file
# Input:   - name of the PIC
#          - path of the .pic file
# Output:  - device file
# Returns: (nothing)
# Notes:
# ---------------------------------------------------------
def pic2jal(picname, picfile):
   print picname
   root = parse(picfile)                                       # load xml file
   collect_config_info(root)
   fp = open(os.path.join(dstdir, picname + ".jal"), "w")      # file path
   list_devicefile_header(fp, picname)
   list_fuses(fp, picname)
   list_osccal(fp, picname)
   list_registers(fp, root)
   list_digital_io(fp, picname)
   list_miscellaneous(fp, picname)
   list_fuse_defs(fp, picname)
   fp.write("--\n")
   fp.close()


# ---------------------------------------------------------
# Main procedure: select .pic files to be processed: 8-bits flash PICs only
# Input:    PIC types to be selected (with wildcards)
# Output:   - device file per selected PICs
#           - chipdef_jallib file
# Returns: (nothing)
# ---------------------------------------------------------
def main(selection):

   m_pic8flash  = re.compile(r"^1(0|2|6|8)(f|lf|hv).*")        # relevant PICs only
   l_pic8excl   = ["16hv540", "16f527", "16f570"]              # exclude OTP, bank select by BSR

   init_fusedefosc()
   read_datasheet_file()                                       # for datasheet suffix
   read_devspec_file()                                         # PIC specific info, like datasheet #
   read_pinmap_file()                                          # pin aliases
   fp = open(os.path.join(dstdir, "chipdef_jallib.jal"), "w")  # common include for device files
   list_chipdef_header(fp)                                     # create header of chipdef file
   count = 0
   for (root, dirs, files) in os.walk(picdir):                 # whole tree (incl subdirs!)
      files.sort()                                             # for unsorted filesystems!
      for file in files:
         picname = os.path.splitext(file)[0][3:].lower()       # 1st selection: pic type
         if (re.match(m_pic8flash, picname) != None) & \
            (picname not in l_pic8excl):                       # select 8-bits flash PICs
            if fnmatch.fnmatch(picname, selection):            # 2nd selection (user wildcard)
               if picname.upper() in devspec:                  # must be in devicespecific
                  picdata = dict(devspec[picname.upper()].items())  # properties of this PIC
                  if picdata.get("DATASHEET") != "-":               # 3rd selection (must have datasheet)
                     pic2jal(picname, os.path.join(root,file))      # create device file from .pic file
                     fp.write("const  word  PIC_%-14s" % picname.upper() + " = " + cfgvar["procid"] + "\n")
                     count = count + 1
                  else:
                     print picname, "no datasheet!"
               else:
                  print picname, "\a not present in", devspecfile    # sound a bell!
   fp.write("--\n")
   fp.close()
   return count


# --- start -----------------------------------------------

if __name__ == "__main__":

   if len(sys.argv) > 1:
      runtype = sys.argv[1].lower()
   else:
      print "Specify at least PROD or TEST as first argument"
      print "and optionally a pictype (wildcards allowed)"
#     sys.exit(1)
      runtype = "test"

   if runtype == "prod":
      dstdir = os.path.join(jallibbase, "include/device")
   elif runtype == "test":
      dstdir = "./test"
   else:
      print "Specify PROD or TEST as first argument"
      print "and optionally a pictype (wildcards allowed)"

   if len(sys.argv) > 2:
      selection = sys.argv[2].lower()
   else:
#     selection = "*"
      selection = "18f24k50"

   elapsed = time.time()
   count = main(selection)
   elapsed = time.time() - elapsed
   print "Generated %d device files in %.1f seconds (%.1f per second)" % \
         (count, elapsed, count / elapsed)


