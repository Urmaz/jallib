#!/usr/bin/python
# ----------------------------------------------------------------------
#  Title: pic2Jal.py  - Create JalV2 device files for flash PICs
#
#  Author: Rob Hamerling, Copyright (c) 2014..2014, all rights reserved.
#
#  Adapted-by:
#
#  Revision: $Revision$
#
#  Compiler: N/A
#
#  This file is part of jallib  http://jallib.googlecode.com
#  Released under the BSD license
#               http://www.opensource.org/licenses/bsd-license.php
#
#  Description:
#    Python script to create device specifications for JALV2, and
#    the file chipdef_jallib.jal, included by each of these.
#    Input are .pic files from MPLAB-X.
#    Apart from declaration of all registers, register-subfields, ports
#    and pins of the chip the device files contain shadowing procedures
#    to prevent the 'read-modify-write' problems and use the LATx register
#    (for PICs which have such registers) for output in stead of PORTx.
#    In addition some device dependent procedures are provided
#    for common operations, like enable_digital_io().
#    Also various aliases are declared to 'normalize' the names of
#    registers and bit fields, which makes it easier to build device
#    independent libraries.
#
#  Sources:  MPLAB-X .pic files
#
#  Notes:
#    - A summary of changes of this script is maintained in 'changes.txt'
#      (not published, available on request).
#    - This script does not use an xml library to parse the .pic files!
#
# ----------------------------------------------------------------------

import os, sys
import re
import fnmatch
import time
import json

# -- basic working parameters -----------------------------

scriptversion   = "0.0.1"
scriptauthor    = "Rob Hamerling"
compilerversion = "2.4q2"
mplabxversion   = "205"
mplabxbase      = "k:/mplab-x_" + mplabxversion                # MPLAB-X base directory
jallibbase      = "k:/jallib"                                  # local copy of jallib tree

# --- input -----------------------------------------------

picdir        = os.path.join(mplabxbase, "crownking.edc.jar/content/edc")   # dir(s) with pic files
devspecfile   = os.path.join(jallibbase, "tools/devicespecific.json")       # additional PIC properties
datasheetfile = os.path.join(jallibbase, "tools/datasheet.list")            # list of datasheets

# --- output ----------------------------------------------

dstdir      = "k:/jal/pic2jal/testpy"                          # dest. of generated device files

# --- global constants and variables ----------------------

pic       = []                                                 # contents of this .pic file
cfgvar    = {}                                                 # PIC properties on picname
devspec   = {}                                                 # PIC specific info on picname
datasheet = {}                                                 # datasheet + suffix on DS number


# --- regular expressions for parsing ---------------------



# ---------------------------------------------------------
# Add copyright, etc to header in device files and chipdef.jallib
# Input:   filespec of destination file
# Returns: nothing
# ---------------------------------------------------------
def copyright(fp):
   fp.write("--\n")
   fp.write("-- Author: " + scriptauthor + ", Copyright (c) 2008..2014, " +
                          "all rights reserved.\n")
   fp.write("--\n")
   fp.write("-- Adapted-by: N/A (generated file, do not change!)\n")
   fp.write("--\n")
   fp.write("-- Revision: $Revision$\n")
   fp.write("--\n")
   fp.write("-- Compiler: " + compilerversion + "\n")
   fp.write("--\n")
   fp.write("-- This file is part of jallib (http://jallib.googlecode.com)\n")
   fp.write("-- Released under the ZLIB license " +
                " (http://www.opensource.org/licenses/zlib-license.html)\n")
   fp.write("--\n")


# ---------------------------------------------------------
# List common constants in ChipDef.Jal
# Input: filespec of destination file
# Returns: nothing
# ---------------------------------------------------------
def chipdef_header(fp):
   fp.write("-- " + "="*65 + "\n")
   fp.write("-- Title: Common Jallib include file for device files\n")
   copyright(fp)                                      # insert copyright and other info
   fp.write("-- Sources:\n")
   fp.write("--\n")
   fp.write("-- Description:\n")
   fp.write("--    Common Jallib include files for device files\n")
   fp.write("--\n")
   fp.write("-- Notes:\n")
   fp.write("--    - File creation date/time: " + time.ctime() + "\n")
   fp.write("--    - This file is generated by <pic2jal.py> script.\n")
   fp.write("--\n")
   fp.write("-- " + "-"*65 + "\n")
   fp.write("--\n")
   fp.write("-- JalV2 compiler required constants\n")
   fp.write("--\n")
   fp.write("const       PIC_12            = 1\n")
   fp.write("const       PIC_14            = 2\n")
   fp.write("const       PIC_16            = 3\n")
   fp.write("const       SX_12             = 4\n")
   fp.write("const       PIC_14H           = 5\n")
   fp.write("--\n")
   fp.write("const bit   PJAL              = 1\n")
   fp.write("--\n")
   fp.write("const byte  W                 = 0\n")
   fp.write("const byte  F                 = 1\n")
   fp.write("--\n")
   fp.write("include  constants_jallib                     -- common Jallib library constants\n")
   fp.write("--\n")
   fp.write("-- " + "="*65 + "\n")
   fp.write("--\n")
   fp.write("-- A value assigned to const 'target_chip' by\n")
   fp.write("--    'pragma target chip' in device files\n")
   fp.write("-- can be used for conditional compilation, for example:\n")
   fp.write("--    if (target_chip == PIC_16F88) then\n")
   fp.write("--      ....                                  -- for 16F88 only\n")
   fp.write("--    endif\n")
   fp.write("--\n")


# ---------------------------------------------------------
# Generate common header
# Input:    - picname
#           - destination file
# Returns: nothing
# Notes:   - Shared memory for _pic_accum and _pic_isr_w is allocated:
#            - for core 12, 14 and 14H from high to low address
#            - for core 16 from low to high address
# ---------------------------------------------------------
def devicefile_header(picname, fp):
   fp.write("-- " + "="*65 + "\n")
   fp.write("-- Title: JalV2 device include file for " + picname + "\n")
   copyright(fp)
   fp.write("-- Description:\n")
   fp.write("--    Device include file for PIC " + picname + ", containing:\n")
   fp.write("--    - Declaration of ports and pins of the chip.\n")
   if "haslat" in cfgvar:                              # PIC has LATx register(s)
      fp.write("--    - Procedures to force the use of the LATx register\n")
      fp.write("--      for output when PORTx or pin_xy is addressed.\n")
   else:
      fp.write("--    - Procedures for shadowing of ports and pins\n")
      fp.write("--      to circumvent the read-modify-write problem.\n")
   fp.write("--    - Symbolic definitions for configuration bits (fuses)\n")
   fp.write("--    - Some device dependent procedures for common\n")
   fp.write("--      operations, like:\n")
   fp.write("--      . enable_digital_io()\n")
   fp.write("--\n")
   fp.write("-- Sources:\n")
   fp.write("--  - {MPLAB-X " + mplabxversion[0:1] + "." + mplabxversion[1:3] + "}" +
            "crownking.edc.jar/content/edc/../" + "PIC" + picname.upper() + ".PIC\n")
   fp.write("--\n")
   fp.write("-- Notes:\n")
   fp.write("--  - File creation date/time: " + time.ctime() + "\n")
   fp.write("--  - This file is generated by <pic2jal.py> script! Do not change!\n")
   fp.write("--\n")
   fp.write("-- " + "="*65 + "\n")
   fp.write("--\n")
   fp.write("const  word  DEVICE_ID   = " + cfgvar["devid"] + "            -- ID for PIC programmer\n")
   fp.write("const  word  CHIP_ID     = " + cfgvar["procid"] + "            -- ID in chipdef_jallib\n")
   fp.write("const  byte  PICTYPE[]   = \"" + picname + "\"\n")
   picdata = dict(devspec[picname.upper()].items())
   fp.write("const  byte  DATASHEET[] = \"" + datasheet[picdata["DATASHEET"]] + "\"\n")
   if "dsid" in cfgvar:
      dsid1 = cfgvar["dsid"]
      if (dsid1 != "0") & (dsid1 != ""):
         dsid2 = dsid1[0:1] + "000" + dsid1[1:]
         if (dsid1 != picdata["DATASHEET"]) & (dsid2 != picdata["DATASHEET"]):
            print "   Possibly conflicting datasheet numbers:"
            print "   .pic file: ", cfgvar["dsid"], ", devicespecific: ", picdata["DATASHEET"]
   if picdata["PGMSPEC"] != "-":
      fp.write("const  byte  PGMSPEC[]   = \"" + datasheet[picdata["PGMSPEC"]] + "\"\n")
   fp.write("--\n")
   fp.write("-- Vdd Range: " + cfgvar["vddmin"] + '-' + cfgvar["vddmax"] +
                " Nominal: " + cfgvar["vddnom"] + "\n")
   fp.write("-- Vpp Range: " + cfgvar["vppmin"] + '-' + cfgvar["vppmax"] +
                " Default: " + cfgvar["vppdef"] + "\n")
   fp.write("--\n")
   fp.write("-- " + "-"*65 + "\n")
   fp.write("--\n")
   fp.write("include chipdef_jallib                  -- common constants\n")
   fp.write("--\n")
   fp.write("pragma  target  cpu    PIC_" + cfgvar["core"] + "           -- (banks = %d" % cfgvar["numbanks"] + ")\n")
   fp.write("pragma  target  chip   " + picname + "\n")
   fp.write("pragma  target  bank   0x%04x" % cfgvar["banksize"] + "\n")
   if cfgvar["pagesize"] > 0:
      fp.write("pragma  target  page   0x%04x" % cfgvar["pagesize"] + "\n")
   fp.write("pragma  stack          %d" % cfgvar["hwstack"] + "\n")
   if cfgvar["osccal"] > 0:
      fp.write("pragma  code           %d" % (cfgvar["codesize"] - 1) + " "*15 + "-- (excl. high memory word)\n")
   else:
      fp.write("pragma  code           %d" % cfgvar["codesize"] + "\n")
   if "eeaddr" in cfgvar:
      fp.write("pragma  eeprom         0x%x" % cfgvar["eeaddr"] + ",%d" % cfgvar["eesize"] + "\n")
   if "idaddr" in cfgvar:
      fp.write("pragma  ID             0x%x" % cfgvar["idaddr"] + ",%d" % cfgvar["idsize"] + "\n")
#  fp.write("pragma  data           0x" + cfgvar["datarange"] + "\n")
#  fp.write("pragma  shared         0x" + cfgvar["sharedrange"] + "\n")
   fp.write("--\n")


# ---------------------------------------------------------
# Generate configuration memory declaration and defaults
# Input:    - picname
#           - output file
# Output:   part of device files
# Returns:  (nothing)
# ---------------------------------------------------------
def devicefile_fuses(picname, fp):
   return 0


# ---------------------------------------------------------
# Generate oscillator calibration instructions
# Input:    - picname
#           - output file
# Output:   part of device files
# Returns:  (nothing)
# ---------------------------------------------------------
def devicefile_osccal(picname, fp):
   return 0

# ---------------------------------------------------------
# Generate special purpose registers, pins, etc.
# Input:    - picname
#           - output file
# Output:   part of device files
# Returns:  (nothing)
# ---------------------------------------------------------
def devicefile_registers(picname, fp):
   return 0


# ---------------------------------------------------------
# Generate instructions to set all I/O to digital mode
# Input:    - picname
#           - output file
# Output:   part of device files
# Returns:  (nothing)
# ---------------------------------------------------------
def devicefile_enable_digital_io(picname, fp):
   return 0

# ---------------------------------------------------------
# Generate miscellaneous information
# Input:    - picname
#           - output file
# Output:   part of device files
# Returns:  (nothing)
# ---------------------------------------------------------
def devicefile_miscellaneous(picname, fp):
   return 0


# ---------------------------------------------------------
# Generate fuse_def statements
# Input:    - picname
#           - output file
# Output:   part of device files
# Returns:  (nothing)
# ---------------------------------------------------------
def devicefile_fuse_defs(picname, fp):
   return 0


# ---------------------------------------------------------
# Collect PIC various configuration data
# Input:    'pic' list
# Output:   fills 'cfgvar' dictionary
# Returns:  (nothing)
# Notes:
# ---------------------------------------------------------
def collect_config_info():

# --- regular expressions for parsing ---------------------

   m_adjust     = re.compile(r"<edc:AdjustPoint .?edc:offset=\"(?P<adjust>.*?)\".*")
   m_bank       = re.compile(r"<edc:SFRDataSector .?edc:bank=\"(?P<bank>.*?)\".*")
   m_codemem    = re.compile(r"<edc:CodeSector .?edc:beginaddr=\"(?P<begin>.*?)\" edc:endaddr=\"(?P<end>.*?)\".*")
   m_core       = re.compile(r"<edc:PIC .*?edc:arch=\"(?P<core>.*?)\".*")
   m_devid      = re.compile(r"<edc:DeviceIDSector .*?edc:value=\"(?P<devid>.*?)\".*")
   m_dsid       = re.compile(r"<edc:PIC .*?edc:dsid=\"(?P<dsid>.*?)\".*")
   m_eemem      = re.compile(r"<edc:EEDataSector .?edc:beginaddr=\"(?P<begin>.*?)\" edc:endaddr=\"(?P<end>.*?)\".*")
   m_flash      = re.compile(r"<edc:FlashDataSector .?edc:beginaddr=\"(?P<begin>.*?)\" edc:endaddr=\"(?P<end>.*?)\".*")
   m_fsr        = re.compile(r"<edc:SFRDef .*?edc:cname=\"(?P<fsr>FSR)\".*")
   m_haslat     = re.compile(r"<edc:SFRDef .*?edc:cname=\"(?P<latreg>LAT[A-L])\".*")
   m_hwstack    = re.compile(r"<edc:MemTraits .*?edc:hwstackdepth=\"(?P<hwstack>.*?)\".*")
   m_idmem      = re.compile(r"<edc:UserIDSector .?edc:beginaddr=\"(?P<begin>.*?)\" edc:endaddr=\"(?P<end>.*?)\".*")
   m_numbanks   = re.compile(r"<edc:MemTraits .*?edc:bankcount=\"(?P<numbanks>.*?)\".*")
   m_osccal     = re.compile(r"<edc:SFRDef .*?edc:cname=\"(?P<osccal>OSCCAL)\".*")
   m_procid     = re.compile(r"<edc:PIC .*?edc:procid=\"(?P<procid>.*?)\".*")
   m_sfrdata    = re.compile(r"<edc:SFRDataSector .*?edc:beginaddr=\"(?P<sfrdata>.*?)\".*")
   m_vddmax     = re.compile(r"<edc:VDD .*?edc:maxvoltage=\"(?P<vddmax>.*?)\".*")
   m_vddmin     = re.compile(r"<edc:VDD .*?edc:minvoltage=\"(?P<vddmin>.*?)\".*")
   m_vddnom     = re.compile(r"<edc:VDD .*?edc:nominalvoltage=\"(?P<vddnom>.*?)\".*")
   m_vppdef     = re.compile(r"<edc:VPP .*?edc:defaultvoltage=\"(?P<vppdef>.+?)\".*")
   m_vppmax     = re.compile(r"<edc:VPP .*?edc:maxvoltage=\"(?P<vppmax>.*?)\".*")
   m_vppmin     = re.compile(r"<edc:VPP .*?edc:minvoltage=\"(?P<vppmin>.*?)\".*")

   global cfgvar
   cfgvar.clear()                                                 # empty dict. of config variables
   cfgvar["numbanks"] = 1                                         # default
   cfgvar["osccal"] = 0                                           # no osccal

   sfraddr = 0                                                    # startvalue of SFR reg addr.

   for i in range(len(pic)):                                      # i is index in pic list

      ln = pic[i]

      if ln.startswith("<edc:PIC "):                              # PIC node
         result = m_core.search(ln)
         if result != None:
            if result.group("core") == "16c5x":
               cfgvar["core"]     = "12"
               cfgvar["maxram"]   = 128
               cfgvar["banksize"] = 32
               cfgvar["pagesize"] = 512
            elif result.group("core") == "16xxxx":
               cfgvar["core"]     = "14"
               cfgvar["maxram"]   = 512
               cfgvar["banksize"] = 128
               cfgvar["pagesize"] = 2048
            elif result.group("core") == "16Exxx":
               cfgvar["core"]     = "14H"
               cfgvar["maxram"]   =  4096
               cfgvar["banksize"] = 128
               cfgvar["pagesize"] = 2048
            elif result.group("core") == "18xxxx":
               cfgvar["core"]     = "16"
               cfgvar["maxram"]   = 4096
               cfgvar["banksize"] = 256
               cfgvar["pagesize"] = 0                             # no pages!
            else:
               print "   \aUndetermined core: " + result.group("core")
         result = m_dsid.search(ln)
         if result != None:
            cfgvar["dsid"] = result.group("dsid")  # datasheet number
         result = m_procid.search(ln)
         if result != None:
            cfgvar["procid"] = result.group("procid")             # processor ID (for chipdef_jallib)

      elif ln.startswith("<edc:Power"):                           # start of Power block
         while not ln.startswith("</edc:Power"):
            result = m_vddnom.search(ln)
            if result != None:
               cfgvar["vddnom"] = result.group("vddnom")
            result = m_vddmin.search(ln)
            if result != None:
               cfgvar["vddmin"] = result.group("vddmin")
            result = m_vddmax.search(ln)
            if result != None:
               cfgvar["vddmax"] = result.group("vddmax")
            result = m_vppdef.search(ln)
            if result != None:
               cfgvar["vppdef"] = result.group("vppdef")
            result = m_vppmin.search(ln)
            if result != None:
               cfgvar["vppmin"] = result.group("vppmin")
            result = m_vppmax.search(ln)
            if result != None:
               cfgvar["vppmax"] = result.group("vppmax")
            i = i + 1
            ln = pic[i]

      elif ln.startswith("<edc:ArchDef"):                         # start of ArchDef block
         while not ln.startswith("</edc:ArchDef"):
            result = m_hwstack.search(ln)
            if result != None:
               cfgvar["hwstack"] = eval(result.group("hwstack"))
            result = m_numbanks.search(ln)
            if result != None:
               cfgvar["numbanks"] = eval(result.group("numbanks"))
            i = i + 1
            ln = pic[i]

      elif ln.startswith("<edc:SFRDataSector"):                   # start of SFR
         if ln.endswith("/>\n"):                                  # without nested nodes
            result = m_bank.search(ln)
            if result != None:
               cfgvar["numbanks"] = max(eval(result.group("bank")) + 1, cfgvar["numbanks"])
            result = m_sfrdata.search(ln)
            if result != None:
               sfraddr = eval(result.group("sfrdata"))            # new sfrdata begin address
            continue
         while not ln.startswith("</edc:SFRDataSector"):
            result = m_bank.search(ln)
            if result != None:
               cfgvar["numbanks"] = max(eval(result.group("bank")) + 1, cfgvar["numbanks"])
            result = m_haslat.search(ln)
            if result != None:
               cfgvar["haslat"] = True                            # any LATx register
            result = m_osccal.search(ln)
            if result != None:
               cfgvar["osccal"] = sfraddr                         # address of OSCCAL
            result = m_fsr.search(ln)
            if result != None:
               cfgvar["fsr"] = sfraddr                            # address of FSR
            result = m_sfrdata.search(ln)
            if result != None:
               sfraddr = eval(result.group("sfrdata"))            # new sfrdata begin address
            result = m_adjust.search(ln)
            if result != None:
               sfraddr = sfraddr + eval(result.group("adjust"))   # adjust SFRdata
            i = i + 1
            ln = pic[i]

      elif ln.startswith("<edc:DeviceIDSector"):                  # start of SFR
         result = m_devid.search(ln)
         if result != None:
            cfgvar["devid"] = result.group("devid")  # device ID

      elif ln.startswith("<edc:ProgramSpace"):                    # start of SFR
         while not ln.startswith("</edc:ProgramSpace"):
            result = m_codemem.search(ln)
            if result != None:
               cfgvar["codesize"] = eval(result.group("end")) - eval(result.group("begin"))
            result = m_eemem.search(ln)
            if result != None:
               cfgvar["eeaddr"] = eval(result.group("begin"))
               cfgvar["eesize"] = eval(result.group("end")) - cfgvar["eeaddr"]
            result = m_flash.search(ln)
            if result != None:
               cfgvar["eeaddr"] = eval(result.group("begin"))
               cfgvar["eesize"] = eval(result.group("end")) - cfgvar["eeaddr"]
            result = m_idmem.search(ln)
            if result != None:
               cfgvar["idaddr"] = eval(result.group("begin"))
               cfgvar["idsize"] = eval(result.group("end")) - cfgvar["idaddr"]
            i = i + 1
            ln = pic[i]

   if "devid" not in cfgvar:
      cfgvar["devid"] = "0x0000"


# ---------------------------------------------------------
# Read devicespecific.json
# Input:    file with datasheet info
# Output:   fills 'devspec' dictionary
# Returns:  (nothing)
# ---------------------------------------------------------
def read_devspec_file():
   global devspec                                              # global variable
   fp = open(devspecfile, "r")
   devspec = json.load(fp)                                     # obtain contents devicespecific
   fp.close()


# ---------------------------------------------------------
# Read datasheet.list
# Input:    none
# Output:   fills 'datasheet' dictionary
# Returns:  (nothing)
# ---------------------------------------------------------
def read_datasheet_file():
   global datasheet
   fp = open(datasheetfile, "r")
   for ln in fp:
      ds = ln.split(" ",1)[0]                                  # datasheet number+suffix
      datasheet[ds[:-1]] = ds                                  # number -> number + sufix
   fp.close()


# ---------------------------------------------------------
# Read MPLAB-X .pic file into a list
# Input:   - path to MPLAB-X .pic file
#          - name of the PIC
# Output:  - list 'pic'
# Returns: (nothing)
# Notes:   - All lines left aligned to simplify parsing
#          - Lines with multiple nodes splitted into 1 node per line
#          - Skip the following blocks:
#            comments, import, pinlist, extendedmode
#          - Skip incomplete nodes on a line
# ---------------------------------------------------------
def read_pic_file(picname, picfile):

   global pic                                                  # global variable
   del(pic[:])                                                 # start with an empty list

   skipcomment = False
   skipextmode = False
   skippinlist = False
   skipimport = False

   fp = open(picfile, "r")
   for ln in fp:

      ln = ln.strip()

      if skipcomment == False:                                 # not in skip state
         if ln.startswith("<!--"):
            skipcomment = True                                 # enter comment skip state
            continue                                           # next line
      else:
         if ln.find("-->") >= 0:
            skipcomment = False                                # leave comment skip state
         continue                                              # next line

      if skipextmode == False:
         if ln.startswith("<edc:ExtendedModeOnly"):
            skipextmode = True
            continue
      else:
         if ln.startswith("</edc:ExtendedModeOnly"):
            skipextmode = False
         continue

      if skippinlist == False:
         if ln.startswith("<edc:PinList"):
            skippinlist = True
            continue
      else:
         if ln.startswith("</edc:PinList"):
            skippinlist = False
         continue

      if skipimport == False:
         if ln.startswith("<edc:Import"):
            skipimport = True
            continue
      else:
         if ln.startswith("</edc:Import"):
            skipimport = False
         continue

      xa = ln.find("<", 0)                                     # start of node
      while xa >= 0:                                           # all nodes on this line
         xz = ln.find(">", xa+1)                               # end of first or only node
         if xz >= 0:                                           # must have end on same line!
            pic.append(ln[xa : xz+1] + "\n")                   # line with single xml node
            xa = ln.find("<", xz + 1)                          # start of next node if any
         else:                                                 # no end of node on this line
            xa = -1                                            # no more (complete) nodes

   fp.close()
# check:
   fp = open(os.path.join(dstdir, picname + ".pic"), "w")      # file path
   fp.writelines(pic)
   fp.close()


# ---------------------------------------------------------
# Convert an MPLAB-X .pic file to a JalV2 device file
# Input:   - name of the PIC
#          - path of the .pic file
# Output:  - device file
# Returns: (nothing)
# Notes:
# ---------------------------------------------------------
def pic2jal(picname, picfile):
   print picname
   read_pic_file(picname, picfile)
   collect_config_info()
   fp = open(os.path.join(dstdir, picname + ".jal"), "w")      # file path
   devicefile_header(picname, fp)
   devicefile_fuses(picname, fp)
   devicefile_osccal(picname, fp)
   devicefile_registers(picname, fp)
   devicefile_enable_digital_io(picname, fp)
   devicefile_miscellaneous(picname, fp)
   devicefile_fuse_defs(picname, fp)
   fp.close()


# ---------------------------------------------------------
# Main procedure: select .pic files to be processed: 8-bits flash PICs only
# Input:    PIC types to be selected (with wildcards)
# Output:   - device file per selected PICs
#           - chipdef_jallib file
# Returns: (nothing)
# ---------------------------------------------------------
def main(selection):

   m_pic8flash  = re.compile(r"^(PIC|pic)1(0|2|6|8)(F|f|LF|lf|HV|hv).*\.(PIC|pic)")   # relevant .pic files only

   read_datasheet_file()
   read_devspec_file()
   fp = open(os.path.join(dstdir, "chipdef_jallib.jal"), "w")  # common include for device files
   chipdef_header(fp)                                          # create header of chipdef file
   for (root, dirs, files) in os.walk(picdir):                 # whole tree (incl subdirs!)
      files.sort()                                             # for unsorted filesystems!
      for file in files:
         if re.match(m_pic8flash, file) != None:               # 1st selection (8-bits flash PICs)
            picname = os.path.splitext(file)[0][3:].lower()
            if fnmatch.fnmatch(picname, selection):            # 2nd selection (user wildcard)
               if picname.upper() in devspec:                  # must be in devicespecific
                  picdata = dict(devspec[picname.upper()].items())  # properties of this PIC
                  if picdata.get("DATASHEET") != "-":               # 3rd selection (must have datasheet)
                     pic2jal(picname, os.path.join(root,file))      # create device file from .pic file
                     fp.write("const   PIC_%-14s" % picname.upper() + " = " + cfgvar["procid"] + "\n")
                  else:
                     print picname, "no datasheet!"
               else:
                  print picname, "\a not present in", devspecfile    # sound a bell!
   fp.write("--\n")
   fp.close()



# --- start -----------------------------------------------

if __name__ == "__main__":

   if len(sys.argv) > 1:
      runtype = sys.argv[1].lower()
   else:
      print "Specify at least PROD or TEST as first argument"
      print "and optionally a pictype (wildcards allowed)"
#     sys.exit(1)
      runtype = "test"

   if runtype == "prod":
      dstdir = os.path.join(jallibbase, "include/device")
   elif runtype == "test":
      dstdir = "./testpy"
   else:
      print "Specify PROD or TEST as first argument"
      print "and optionally a pictype (wildcards allowed)"

   if len(sys.argv) > 2:
      selection = sys.argv[2].lower()
   else:
      selection = "*"
#     selection = "18f65j94"

   main(selection)


